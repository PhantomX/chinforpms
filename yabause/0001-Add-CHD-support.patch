From eabdb1bee2db26ff7212fa76d35a9c086726861e Mon Sep 17 00:00:00 2001
From: Phantom X <PhantomX@users.noreply.github.com>
Date: Tue, 21 Jul 2020 14:32:21 -0300
Subject: [PATCH] Add CHD and ZIP support

Borrowed from devmiyax fork: https://github.com/devmiyax/yabause

Also, link to system libchdr
---
 yabause/src/CMakeLists.txt        |   10 +
 yabause/src/cdbase.c              | 1166 +++++++++++++++++++++++------
 yabause/src/cdbase.h              |   13 +
 yabause/src/qt/ui/UISettings.cpp  |    2 +-
 yabause/src/qt/ui/UIYabause.cpp   |    2 +-
 yabause/src/tools/junzip/junzip.c |  285 +++++++
 yabause/src/tools/junzip/junzip.h |  122 +++
 7 files changed, 1383 insertions(+), 217 deletions(-)
 create mode 100644 yabause/src/tools/junzip/junzip.c
 create mode 100644 yabause/src/tools/junzip/junzip.h

diff --git a/yabause/src/CMakeLists.txt b/yabause/src/CMakeLists.txt
index 4bd7730..474cdf9 100755
--- a/yabause/src/CMakeLists.txt
+++ b/yabause/src/CMakeLists.txt
@@ -6,6 +6,8 @@ include(CheckIncludeFile)
 
 cmake_minimum_required(VERSION 2.8)
 
+find_package(PkgConfig REQUIRED)
+
 set(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} ${CMAKE_SOURCE_DIR}/CMakeTests)
 
 set(yabause_HEADERS
@@ -306,6 +308,14 @@ if (MINI18N_FOUND)
 	endif()
 endif()
 
+include_directories(tools/junzip)
+set(yabause_SOURCES ${yabause_SOURCES} tools/junzip/junzip.c)
+
+add_library(chdr-shared INTERFACE IMPORTED GLOBAL)
+pkg_check_modules(CHDR REQUIRED libchdr)
+include_directories(${CHDR_INCLUDE_DIRS})
+set(YABAUSE_LIBRARIES ${YABAUSE_LIBRARIES} ${CHDR_LIBRARIES})
+
 # APPLE // not necessary mac os x, but i don't care ;)
 if (APPLE)
 	FIND_LIBRARY(COREFOUNDATION_LIBRARY NAMES CoreFoundation )
diff --git a/yabause/src/cdbase.c b/yabause/src/cdbase.c
index d56d5dd..ffb1ed1 100644
--- a/yabause/src/cdbase.c
+++ b/yabause/src/cdbase.c
@@ -1,7 +1,7 @@
 /*  Copyright 2004-2008, 2013 Theo Berkau
     Copyright 2005 Joost Peters
     Copyright 2005-2006 Guillaume Duhamel
-    
+
     This file is part of Yabause.
 
     Yabause is free software; you can redistribute it and/or modify
@@ -20,18 +20,24 @@
 */
 
 /*! \file cdbase.c
-    \brief Dummy and ISO, BIN/CUE, MDS, CCD CD Interfaces
+    \brief Dummy and ISO, BIN/CUE, MDS CD Interfaces
 */
-
+#define _GNU_SOURCE
 #include <string.h>
+#ifndef WIN32
+#include <strings.h>
+#include <dirent.h>
+#endif
 #include <stdlib.h>
 #include <assert.h>
 #include <ctype.h>
 #include <wchar.h>
 #include "cdbase.h"
-#include "cs2.h"
 #include "error.h"
 #include "debug.h"
+#include "junzip.h"
+#include "zlib.h"
+#include "chd.h"
 
 #ifndef HAVE_STRICMP
 #ifdef HAVE_STRCASECMP
@@ -93,6 +99,7 @@ static s32 DummyCDReadTOC(u32 *);
 static s32 DummyCDReadTOC10(CDInterfaceToc10 *);
 static int DummyCDReadSectorFAD(u32, void *);
 static void DummyCDReadAheadFAD(u32);
+static void DummyCDSetStatus(int status );
 
 CDInterface DummyCD = {
 CDCORE_DUMMY,
@@ -104,6 +111,7 @@ DummyCDReadTOC,
 DummyCDReadTOC10,
 DummyCDReadSectorFAD,
 DummyCDReadAheadFAD,
+DummyCDSetStatus,
 };
 
 static int ISOCDInit(const char *);
@@ -113,6 +121,7 @@ static s32 ISOCDReadTOC(u32 *);
 static s32 ISOCDReadTOC10(CDInterfaceToc10 *);
 static int ISOCDReadSectorFAD(u32, void *);
 static void ISOCDReadAheadFAD(u32);
+static void ISOCDSetStatus(int status);
 
 CDInterface ISOCD = {
 CDCORE_ISO,
@@ -124,8 +133,10 @@ ISOCDReadTOC,
 ISOCDReadTOC10,
 ISOCDReadSectorFAD,
 ISOCDReadAheadFAD,
+ISOCDSetStatus,
 };
 
+static int dmy_status = 2;
 //////////////////////////////////////////////////////////////////////////////
 // Dummy Interface
 //////////////////////////////////////////////////////////////////////////////
@@ -163,7 +174,15 @@ static int DummyCDGetStatus(void)
 	// player, etc. recognizes when you've ejected the tray and popped in
 	// another disc.
 
-	return 0;
+	return dmy_status;
+}
+
+static void DummyCDSetStatus(int status){
+  dmy_status = status;
+  if (dmy_status != 3) {
+    dmy_status = 2;
+  }
+	return;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -179,7 +198,7 @@ static s32 DummyCDReadTOC(UNUSED u32 *TOC)
 	//
 	// Any Unused tracks should be set to 0xFFFFFFFF
 	//
-	// TOC[99] - Point A0 information 
+	// TOC[99] - Point A0 information
 	// Uses the following format:
 	// bits 0 - 7: PFRAME(should always be 0)
 	// bits 7 - 15: PSEC(Program area format: 0x00 - CDDA or CDROM,
@@ -266,10 +285,19 @@ typedef struct
    u32 file_offset;
    u32 sector_size;
    FILE *fp;
-	FILE *sub_fp;
    int file_size;
    int file_id;
    int interleaved_sub;
+   u32 frames;
+   u32 extraframes;
+   u32 pregap;
+   u32 postgap;
+   u32 physframeofs;
+   u32 chdframeofs;
+   u32 logframeofs;
+   int isZip;
+   char* filename;
+   ZipEntry* tr;
 } track_info_struct;
 
 typedef struct
@@ -283,6 +311,8 @@ typedef struct
 typedef struct
 {
    int session_num;
+   JZFile *zip;
+   JZEndRecord* endRecord;
    session_info_struct *session;
 } disc_info_struct;
 
@@ -368,30 +398,142 @@ typedef struct
 } ccd_struct;
 
 static const s8 syncHdr[12] = { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00 };
-enum IMG_TYPE { IMG_NONE, IMG_ISO, IMG_BINCUE, IMG_MDS, IMG_CCD, IMG_NRG };
+enum IMG_TYPE { IMG_NONE, IMG_ISO, IMG_BINCUE, IMG_MDS, IMG_CCD, IMG_CHD, IMG_NRG };
 enum IMG_TYPE imgtype = IMG_ISO;
 static u32 isoTOC[102];
 static CDInterfaceToc10 isoTOC10[102];
 int isoTOCnum=0;
 static disc_info_struct disc;
+static int iso_cd_status = 0;
+
+static int current_file_id = 0;
 
 #define MSF_TO_FAD(m,s,f) ((m * 4500) + (s * 75) + f)
 
 //////////////////////////////////////////////////////////////////////////////
+static int shallBeEscaped(char c) {
+  return ((c=='\\'));
+}
+
+static int charToEscape(char *buffer) {
+  int i;
+  int ret = 0;
+  for (i=0; i<strlen(buffer); i++) {
+    if(shallBeEscaped(buffer[i])) ret++;
+  }
+  return ret;
+}
+
+#ifndef WIN32
+static FILE* fopenInPath(char* filename, char* path){
+  int nbFiles,i,k;
+  char* tmp;
+  int l = strlen(filename) + 2;
+  struct dirent **fileListTemp;
+  nbFiles = scandir(path, &fileListTemp, NULL, alphasort);
+  for(i = 0; i < nbFiles; i++){
+    if (strncasecmp(filename, fileListTemp[i]->d_name, l) == 0) {
+      int p= (l + charToEscape(filename) + charToEscape(path)+strlen(path));
+      char* filepath = malloc(p*sizeof(char));
+      tmp = filepath;
+      for (k=0; k<strlen(path); k++) {
+        if (shallBeEscaped(path[k])) *tmp++='\\';
+           *tmp++ = path[k];
+      }
+      *tmp++ = '/';
+      for (k=0; k<strlen(fileListTemp[i]->d_name); k++) {
+        if (shallBeEscaped(fileListTemp[i]->d_name[k])) *tmp++='\\';
+           *tmp++ = fileListTemp[i]->d_name[k];
+      }
+      *tmp++ = '\0';
+      return fopen(filepath,"rb");
+    }
+  }
+  return NULL;
+
+}
+#else
+static FILE* fopenInPath(char* filename, char* path){
+  int l = strlen(filename)+2;
+  int k;
+  char* filepath = malloc((l + charToEscape(filename) + charToEscape(path)+strlen(path))*sizeof(char));
+  char* tmp;
+  tmp = filepath;
+  for (k=0; k<strlen(path); k++) {
+    if (shallBeEscaped(path[k])) *tmp++='\\';
+    *tmp++ = path[k];
+  }
+  *tmp++ = '\\';
+  for (k=0; k<strlen(filename); k++) {
+    if (shallBeEscaped(filename[k])) *tmp++='\\';
+    *tmp++ = filename[k];
+  }
+  *tmp++ = '\0';
+  return fopen(filepath,"rb");
+}
+#endif
+
+static FILE* OpenFile(char* buffer, const char* cue) {
+   char *filename, *endofpath;
+   char *path;
+   int tmp;
+   FILE *ret_file = NULL;
+   // Now go and open up the image file, figure out its size, etc.
+   if ((ret_file = fopen(buffer, "rb")) == NULL)
+   {
+      // Ok, exact path didn't work. Let's trim the path and try opening the
+      // file from the same directory as the cue.
+
+      // find the start of filename
+      filename = buffer;
+      for (tmp=0; tmp < strlen(buffer); tmp++)
+      {
+         if ((buffer[tmp] == '/') || (buffer[tmp] == '\\'))
+           filename = &buffer[tmp+1];
+      }
+
+      // append directory of cue file with bin filename
+      // find end of path
+      endofpath = (char*)cue;
+      for (tmp=0; tmp < strlen(cue); tmp++)
+      {
+         if ((cue[tmp] == '/') || (cue[tmp] == '\\'))
+           endofpath = (char*)&cue[tmp];
+      }
+
+      if ((path = (char *)calloc((endofpath - cue +1)*sizeof(char), 1)) == NULL)
+      {
+         return NULL;
+      }
+      strncpy(path, cue, endofpath - cue);
+
+      // Let's give it another try
+      ret_file = fopenInPath(filename, path);
+      free(path);
+      if (ret_file == NULL)
+      {
+         YabSetError(YAB_ERR_FILENOTFOUND, buffer);
+      }
+   }
+   return ret_file;
+}
+
+static int LoadCHD(const char *chd_filename, FILE *iso_file);
+static int ISOCDReadSectorFADFromCHD(u32 FAD, void *buffer);
 
 static int LoadBinCue(const char *cuefilename, FILE *iso_file)
 {
    long size;
-   char *temp_buffer, *temp_buffer2;
-   unsigned int track_num;
+   char* temp_buffer;
+   unsigned int track_num = 0;
    unsigned int indexnum, min, sec, frame;
    unsigned int pregap=0;
-   char *p, *p2;
    track_info_struct trk[100];
-   int file_size;
    int i;
-   FILE * bin_file;
    int matched = 0;
+   FILE *trackfp = NULL;
+   int trackfp_size = 0;
+   int fad = 150;
 
 	memset(trk, 0, sizeof(trk));
    disc.session_num = 1;
@@ -417,13 +559,6 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
    if ((temp_buffer = (char *)calloc(size, 1)) == NULL)
       return -1;
 
-   // Skip image filename
-   if (fscanf(iso_file, "FILE \"%*[^\"]\" %*s\r\n") == EOF)
-   {
-      free(temp_buffer);
-      return -1;
-   }
-
    // Time to generate TOC
    for (;;)
    {
@@ -431,6 +566,26 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
       if (fscanf(iso_file, "%s", temp_buffer) == EOF)
          break;
 
+      if (strncmp(temp_buffer, "FILE", 4) == 0)
+      {
+         matched = fscanf(iso_file, " \"%[^\"]\"", temp_buffer);
+         trackfp = OpenFile(temp_buffer, cuefilename);
+         if (trackfp == NULL) {
+           printf("Can not open file %s\n", temp_buffer);
+           free(temp_buffer);
+           return -1;
+         }
+         fseek(trackfp, 0, SEEK_END);
+         trackfp_size = ftell(trackfp);
+         fseek(trackfp, 0, SEEK_SET);
+         current_file_id++;
+         if(track_num>0) {
+           trk[track_num-1].fad_end = trk[track_num-1].fad_start+(trk[track_num-1].file_size-trk[track_num-1].file_offset)/trk[track_num-1].sector_size;
+           fad = trk[track_num-1].fad_end;
+         }
+         continue;
+      }
+
       // Figure out what it is
       if (strncmp(temp_buffer, "TRACK", 5) == 0)
       {
@@ -438,6 +593,10 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
          if (fscanf(iso_file, "%d %[^\r\n]\r\n", &track_num, temp_buffer) == EOF)
             break;
 
+         trk[track_num-1].fp = trackfp;
+         trk[track_num-1].file_size = trackfp_size;
+         trk[track_num-1].file_id = current_file_id;
+
          if (strncmp(temp_buffer, "MODE1", 5) == 0 ||
             strncmp(temp_buffer, "MODE2", 5) == 0)
          {
@@ -462,8 +621,14 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
          if (indexnum == 1)
          {
             // Update toc entry
-            trk[track_num-1].fad_start = (MSF_TO_FAD(min, sec, frame) + pregap + 150);
+            fad += MSF_TO_FAD(min, sec, frame) + pregap;
+            trk[track_num-1].fad_start = fad;
             trk[track_num-1].file_offset = MSF_TO_FAD(min, sec, frame) * trk[track_num-1].sector_size;
+            CDLOG("Start[%d] %d\n", track_num, trk[track_num-1].fad_start);
+            if (track_num > 1) {
+              trk[track_num-2].fad_end = trk[track_num-1].fad_start-1;
+              CDLOG("End[%d] %d\n", track_num-1, trk[track_num-2].fad_end);
+            }
          }
       }
       else if (strncmp(temp_buffer, "PREGAP", 6) == 0)
@@ -478,97 +643,337 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
          if (fscanf(iso_file, "%d:%d:%d\r\n", &min, &sec, &frame) == EOF)
             break;
       }
-      else if (strncmp(temp_buffer, "FILE", 4) == 0)
-      {
-         YabSetError(YAB_ERR_OTHER, "Unsupported cue format");
-         free(temp_buffer);
-         return -1;
-      }
    }
 
    trk[track_num].file_offset = 0;
    trk[track_num].fad_start = 0xFFFFFFFF;
 
-   // Go back, retrieve image filename
-   fseek(iso_file, 0, SEEK_SET);
-   matched = fscanf(iso_file, "FILE \"%[^\"]\" %*s\r\n", temp_buffer);
+   if (track_num == 0) {
+     YabSetError(YAB_ERR_FILENOTFOUND, NULL);
+     free(disc.session);
+     disc.session = NULL;
+     return -1;
+   }
 
-   // Now go and open up the image file, figure out its size, etc.
-   if ((bin_file = fopen(temp_buffer, "rb")) == NULL)
+   trk[track_num-1].fad_end = trk[track_num-1].fad_start+(trk[track_num-1].file_size-trk[track_num-1].file_offset)/trk[track_num-1].sector_size;
+
+   //for (int i =0; i<track_num; i++) printf("Track %d [%d - %d]\n", i+1, trk[i].fad_start, trk[i].fad_end);
+
+   disc.session[0].fad_start = 150;
+   disc.session[0].fad_end = trk[track_num-1].fad_end;
+   disc.session[0].track_num = track_num;
+   disc.session[0].track = malloc(sizeof(track_info_struct) * disc.session[0].track_num);
+   if (disc.session[0].track == NULL)
    {
-      // Ok, exact path didn't work. Let's trim the path and try opening the
-      // file from the same directory as the cue.
+      YabSetError(YAB_ERR_MEMORYALLOC, NULL);
+      free(disc.session);
+      disc.session = NULL;
+      return -1;
+   }
 
-      // find the start of filename
-      p = temp_buffer;
+   memcpy(disc.session[0].track, trk, track_num * sizeof(track_info_struct));
 
-      for (;;)
-      {
-         if (strcspn(p, "/\\") == strlen(p))
-         break;
+   // buffer is no longer needed
+   free(temp_buffer);
+
+   fclose(iso_file);
+   return 0;
+}
 
-         p += strcspn(p, "/\\") + 1;
+
+int infoFile(JZFile *zip, int idx, JZFileHeader *header, char *filename, void *user_data) {
+    long offset;
+    char name[1024];
+    ZipEntry *entry;
+    offset = zip->tell(zip); // store current position
+    entry = (ZipEntry*)user_data;
+
+   if (entry == NULL) exit(-1);
+
+    if(zip->seek(zip, header->offset, SEEK_SET)) {
+        printf("Cannot seek in zip file!\n");
+        return 0; // abort
+    }
+
+    if (entry->filename == NULL){
+      //look for *.cue file
+       char *last = strstr(filename, ".cue");
+       if (last == NULL) last = strstr(filename, ".Cue");
+       if (last == NULL) last = strstr(filename, ".CUE");
+       if (last != NULL) {
+        if(jzReadLocalFileHeader(zip, header, name, sizeof(name))) {
+          printf("Couldn't read local file header!\n");
+          exit(-1);
+        }
+        entry->zipBuffer = NULL;
+        entry->size = header->uncompressedSize;
+        return 0;
+       }
+    } else {
+      char *last = strrchr(filename, '/');
+      char* fileToSearch = entry->filename;
+      if (last == NULL) last = filename;
+      else last = last+1;
+      if (strcmp(last, fileToSearch) == 0) {
+        //File found
+        entry->zipBuffer = NULL;
+        entry->size = header->uncompressedSize;
+        return 0;
       }
+    }
 
-      // append directory of cue file with bin filename
-      if ((temp_buffer2 = (char *)calloc(strlen(cuefilename) + strlen(p) + 1, 1)) == NULL)
-      {
-         free(temp_buffer);
-         return -1;
+    zip->seek(zip, offset, SEEK_SET); // return to position
+
+    return 1; // continue
+}
+
+int deflateFile(JZFile *zip, int idx, JZFileHeader *header, char *filename, void *user_data) {
+    long offset;
+    char name[1024];
+    offset = zip->tell(zip); // store current position
+    ZipEntry *entry = (ZipEntry*)user_data;
+   if (entry == NULL) exit(-1);
+    if(zip->seek(zip, header->offset, SEEK_SET)) {
+        printf("Cannot seek in zip file!\n");
+        return 0; // abort
+    }
+    if (entry->filename == NULL){
+      //look for *.cue file
+       char *last = strstr(filename, ".cue");
+       if (last == NULL) last = strstr(filename, ".Cue");
+       if (last == NULL) last = strstr(filename, ".CUE");
+       if (last != NULL) {
+        if(jzReadLocalFileHeader(zip, header, name, sizeof(name))) {
+          printf("Couldn't read local file header!\n");
+          exit(-1);
+        }
+        CDLOG("uncompressed %d %f %f\n", header->uncompressedSize, header->uncompressedSize/2448.0, header->uncompressedSize/2352.0);
+        if((entry->zipBuffer = (u8*)malloc(header->uncompressedSize)) == NULL) {
+          printf("Couldn't allocate memory!\n");
+          exit(-1);
+        }
+        if (jzReadData(zip, header, entry->zipBuffer) == Z_OK)
+          entry->size = header->uncompressedSize;
+        else {
+          free (entry->zipBuffer);
+          entry->zipBuffer = NULL;
+          entry->size = 0;
+        }
+        return 0;
+       }
+    } else {
+      char *last = strrchr(filename, '/');
+      char* fileToSearch = entry->filename;
+      if (last == NULL) last = filename;
+      else last = last+1;
+      if (strcmp(last, fileToSearch) == 0) {
+        if(jzReadLocalFileHeader(zip, header, name, sizeof(name))) {
+          printf("Couldn't read local file header!\n");
+          exit(-1);
+        }
+        CDLOG("uncompressed %d %f %f\n", header->uncompressedSize, header->uncompressedSize/2448.0, header->uncompressedSize/2352.0);
+        if((entry->zipBuffer = (u8*)malloc(header->uncompressedSize)) == NULL) {
+          printf("Couldn't allocate memory!\n");
+          exit(-1);
+        }
+        if (jzReadData(zip, header, entry->zipBuffer) == Z_OK)
+          entry->size = header->uncompressedSize;
+        else {
+          free (entry->zipBuffer);
+          entry->zipBuffer = NULL;
+          entry->size = 0;
+        }
+        return 0;
       }
+    }
+    zip->seek(zip, offset, SEEK_SET); // return to position
+    return 1; // continue
+}
 
-      // find end of path
-      p2 = (char *)cuefilename;
+static ZipEntry* getZipFileLocalInfo(JZFile *zip, JZEndRecord* endRecord, char* filename, int deflate) {
+   ZipEntry* entry = (ZipEntry*)malloc(sizeof(ZipEntry));
+   entry->filename = NULL;
+   entry->zipBuffer = NULL;
+   entry->size = 0;
+   if (filename != NULL)
+     entry->filename = strdup(filename);
+   if (deflate != 0) {
+     if(jzReadCentralDirectory(zip, endRecord, deflateFile, entry)) {
+      printf("Couldn't read ZIP file central record.\n");
+      return NULL;
+     }
+  } else {
+     if(jzReadCentralDirectory(zip, endRecord, infoFile, entry)) {
+      printf("Couldn't read ZIP file central record.\n");
+      return NULL;
+     }
+  }
+  return entry;
+}
+
+
+static int LoadBinCueInZip(const char *filename, FILE *fp)
+{
+   long size;
+   char* temp_buffer;
+   unsigned int track_num = 0;
+   unsigned int indexnum, min, sec, frame;
+   unsigned int pregap=0;
+   track_info_struct trk[100];
+   int i;
+   int matched = 0;
+   char *trackfp = NULL;
+   int trackfp_size = 0;
+   int fad = 150;
+   int pos;
+
+   JZEndRecord* endRecord = (JZEndRecord*)malloc(sizeof(JZEndRecord));
+   JZFileHeader header;
+   u8* data;
+   ZipEntry* tracktr = NULL;
+   JZFile *zip;
+   FILE *iso_file;
+   ZipEntry *cue;
+   int index = 0;
 
-      for (;;)
+  zip = jzfile_from_stdio_file(fp);
+
+  if(jzReadEndRecord(zip, endRecord)) {
+    printf("Couldn't read ZIP file end record.\n");
+    return -1;
+  }
+
+  cue = getZipFileLocalInfo(zip, endRecord, NULL, 1);
+  if (cue == NULL) return -1;
+
+   memset(trk, 0, sizeof(trk));
+   disc.session_num = 1;
+   disc.zip = zip;
+   disc.endRecord = endRecord;
+   disc.session = malloc(sizeof(session_info_struct) * disc.session_num);
+   if (disc.session == NULL)
+   {
+      YabSetError(YAB_ERR_MEMORYALLOC, NULL);
+      return -1;
+   }
+
+   size = cue->size;
+
+   if(size == 0)
+   {
+      YabSetError(YAB_ERR_FILEREAD, filename);
+      return -1;
+   }
+
+   data = cue->zipBuffer;
+   // Allocate buffer with enough space for reading cue
+   if ((temp_buffer = (char *)calloc(size, 1)) == NULL)
+      return -1;
+   // Time to generate TOC
+   for (;;)
+   {
+      // Retrieve a line in cue
+      if (sscanf(&data[index], "%s%n", temp_buffer, &pos) == EOF)
+         break;
+      index+= pos;
+      if (strncmp(temp_buffer, "FILE", 4) == 0)
       {
-         if (strcspn(p2, "/\\") == strlen(p2))
-            break;
-         p2 += strcspn(p2, "/\\") + 1;
+         ZipEntry *f;
+         matched = sscanf(&data[index], " \"%[^\"]\"%n", temp_buffer, &pos);
+         index+= pos;
+         f = getZipFileLocalInfo(zip, endRecord, temp_buffer, 1);
+         if (f == NULL) return -1;
+         trackfp_size = f->size;
+         current_file_id++;
+         trackfp = strdup(temp_buffer);
+         tracktr = f;
+         if(track_num > 0) {
+           trk[track_num-1].fad_end = trk[track_num-1].fad_start+(trk[track_num-1].file_size-trk[track_num-1].file_offset)/trk[track_num-1].sector_size;
+           fad = trk[track_num-1].fad_end;
+         }
+         continue;
       }
 
-      // Make sure there was at least some kind of path, otherwise our
-      // second check is pretty useless
-      if (cuefilename == p2 && temp_buffer == p)
+      // Figure out what it is
+      if (strncmp(temp_buffer, "TRACK", 5) == 0)
       {
-         free(temp_buffer);
-         free(temp_buffer2);
-         return -1;
-      }
+         // Handle accordingly
+         if (sscanf(&data[index], "%d %[^\r\n]\r\n%n", &track_num, temp_buffer, &pos) == EOF)
+            break;
+         index+= pos;
+         trk[track_num-1].isZip = 1;
+         trk[track_num-1].filename = trackfp;
+         trk[track_num-1].file_size = trackfp_size;
+         trk[track_num-1].tr = tracktr;
+         trk[track_num-1].file_id = current_file_id;
 
-      strncpy(temp_buffer2, cuefilename, p2 - cuefilename);
-      strcat(temp_buffer2, p);
+         if (strncmp(temp_buffer, "MODE1", 5) == 0 ||
+            strncmp(temp_buffer, "MODE2", 5) == 0)
+         {
+            // Figure out the track sector size
+            trk[track_num-1].sector_size = atoi(temp_buffer + 6);
+            trk[track_num-1].ctl_addr = 0x41;
+         }
+         else if (strncmp(temp_buffer, "AUDIO", 5) == 0)
+         {
+            // Update toc entry
+            trk[track_num-1].sector_size = 2352;
+            trk[track_num-1].ctl_addr = 0x01;
+         }
+      }
+      else if (strncmp(temp_buffer, "INDEX", 5) == 0)
+      {
+         // Handle accordingly
 
-      // Let's give it another try
-      bin_file = fopen(temp_buffer2, "rb");
-      free(temp_buffer2);
+         if (sscanf(&data[index], "%d %d:%d:%d\r\n%n", &indexnum, &min, &sec, &frame,&pos) == EOF)
+            break;
+         index+= pos;
 
-      if (bin_file == NULL)
+         if (indexnum == 1)
+         {
+            // Update toc entry
+            fad += MSF_TO_FAD(min, sec, frame) + pregap;
+            trk[track_num-1].fad_start = fad;
+            trk[track_num-1].file_offset = MSF_TO_FAD(min, sec, frame) * trk[track_num-1].sector_size;
+            CDLOG("Start[%d] %d\n", track_num, trk[track_num-1].fad_start);
+            if (track_num > 1) {
+              trk[track_num-2].fad_end = trk[track_num-1].fad_start-1;
+              CDLOG("End[%d] %d\n", track_num-1, trk[track_num-2].fad_end);
+            }
+         }
+      }
+      else if (strncmp(temp_buffer, "PREGAP", 6) == 0)
       {
-         YabSetError(YAB_ERR_FILENOTFOUND, temp_buffer);
-         free(temp_buffer);
-         return -1;
+         if (sscanf(&data[index], "%d:%d:%d\r\n%n", &min, &sec, &frame, &pos) == EOF)
+            break;
+         index+= pos;
+         pregap += MSF_TO_FAD(min, sec, frame);
+      }
+      else if (strncmp(temp_buffer, "POSTGAP", 7) == 0)
+      {
+         if (sscanf(&data[index], "%d:%d:%d\r\n%n", &min, &sec, &frame, &pos) == EOF)
+            break;
+         index+= pos;
       }
    }
 
-   fseek(bin_file, 0, SEEK_END);
-   file_size = ftell(bin_file);
-   fseek(bin_file, 0, SEEK_SET);
+   trk[track_num].file_offset = 0;
+   trk[track_num].fad_start = 0xFFFFFFFF;
 
-   for (i = 0; i < track_num; i++)
-   {
-      trk[i].fad_end = trk[i+1].fad_start-1;
-      trk[i].file_id = 0;
-      trk[i].fp = bin_file;
-      trk[i].file_size = file_size;
+   if (track_num == 0) {
+     YabSetError(YAB_ERR_FILENOTFOUND, NULL);
+     free(disc.session);
+     disc.session = NULL;
+     return -1;
    }
 
-   trk[track_num-1].fad_end = trk[track_num-1].fad_start+(file_size-trk[track_num-1].file_offset)/trk[track_num-1].sector_size;
+    trk[track_num-1].fad_end = trk[track_num-1].fad_start+(trk[track_num-1].file_size-trk[track_num-1].file_offset)/trk[track_num-1].sector_size;
+
+   //for (int i =0; i<track_num; i++) printf("Track %d [%d - %d]\n", i+1, trk[i].fad_start, trk[i].fad_end);
 
    disc.session[0].fad_start = 150;
    disc.session[0].fad_end = trk[track_num-1].fad_end;
    disc.session[0].track_num = track_num;
-
    disc.session[0].track = malloc(sizeof(track_info_struct) * disc.session[0].track_num);
    if (disc.session[0].track == NULL)
    {
@@ -583,7 +988,6 @@ static int LoadBinCue(const char *cuefilename, FILE *iso_file)
    // buffer is no longer needed
    free(temp_buffer);
 
-   fclose(iso_file);
    return 0;
 }
 
@@ -896,23 +1300,23 @@ int LoadParseCCD(FILE *ccd_fp, ccd_struct *ccd)
 	int lineno = 0, error = 0, max_size = 100;
 
 	ccd->dict = (ccd_dict_struct *)malloc(sizeof(ccd_dict_struct)*max_size);
-	if (ccd->dict == NULL) 
+	if (ccd->dict == NULL)
 		return -1;
 
 	ccd->num_dict = 0;
 
 	// Read CCD file
-	while (fgets(text, sizeof(text), ccd_fp) != NULL) 
+	while (fgets(text, sizeof(text), ccd_fp) != NULL)
 	{
 		lineno++;
 
 		start = StripPreSuffixWhitespace(text);
 
-		if (start[0] == '[') 
+		if (start[0] == '[')
 		{
 			// Section
 			end = strchr(start+1, ']');
-			if (end == NULL) 
+			if (end == NULL)
 			{
 				// ] missing from section
 				error = lineno;
@@ -925,11 +1329,11 @@ int LoadParseCCD(FILE *ccd_fp, ccd_struct *ccd)
 				old_name[0] = '\0';
 			}
 		}
-		else if (start[0]) 
+		else if (start[0])
 		{
 			// Name/Value pair
 			end = strchr(start, '=');
-			if (end) 
+			if (end)
 			{
 				end[0] = '\0';
 				name = StripPreSuffixWhitespace(start);
@@ -976,9 +1380,15 @@ static int GetIntCCD(ccd_struct *ccd, char *section, char *name)
 	int i;
 	for (i = 0; i < ccd->num_dict; i++)
 	{
+#if (defined(IOS) || defined(ANDROID))
+        if (strcasecmp(ccd->dict[i].section, section) == 0 &&
+            strcasecmp(ccd->dict[i].name, name) == 0)
+#else
 		if (stricmp(ccd->dict[i].section, section) == 0 &&
 			 stricmp(ccd->dict[i].name, name) == 0)
+#endif
 			return strtol(ccd->dict[i].value, NULL, 0);
+
 	}
 
 	return -1;
@@ -1009,8 +1419,13 @@ static int LoadCCD(const char *ccd_filename, FILE *iso_file)
 
 	if (fp == NULL)
 	{
-		YabSetError(YAB_ERR_FILEREAD, img_filename);
-		return -1;
+		ext = strrchr(img_filename, '.');
+		strcpy(ext, ".iso");
+		fp = fopen(img_filename, "rb");
+		if (fp == NULL){
+			YabSetError(YAB_ERR_FILEREAD, img_filename);
+			return -1;
+		}
 	}
 
 	fseek(iso_file, 0, SEEK_SET);
@@ -1050,8 +1465,6 @@ static int LoadCCD(const char *ccd_filename, FILE *iso_file)
 		return -1;
 	}
 
-	isoTOCnum = num_toc;
-
 	// Find track number and allocate
 	for (i = 0; i < num_toc; i++)
 	{
@@ -1059,18 +1472,6 @@ static int LoadCCD(const char *ccd_filename, FILE *iso_file)
 		int point;
 
 		sprintf(sect_name, "Entry %d", i);
-
-		isoTOC10[i].ctrladr = (GetIntCCD(&ccd, sect_name, "Control") << 4) | GetIntCCD(&ccd, sect_name, "ADR");
-		isoTOC10[i].tno = GetIntCCD(&ccd, sect_name, "TrackNo");
-		isoTOC10[i].point = GetIntCCD(&ccd, sect_name, "Point");
-		isoTOC10[i].min = GetIntCCD(&ccd, sect_name, "AMin");
-		isoTOC10[i].sec = 2;
-		isoTOC10[i].frame = 0;
-		isoTOC10[i].zero = GetIntCCD(&ccd, sect_name, "Zero");
-		isoTOC10[i].pmin = GetIntCCD(&ccd, sect_name, "PMin");
-		isoTOC10[i].psec = GetIntCCD(&ccd, sect_name, "PSec");
-		isoTOC10[i].pframe = GetIntCCD(&ccd, sect_name, "PFrame");
-
 		point = GetIntCCD(&ccd, sect_name, "Point");
 
 		if (point == 0xA1)
@@ -1121,12 +1522,13 @@ static int LoadCCD(const char *ccd_filename, FILE *iso_file)
 			track_info_struct *track=&disc.session[ses-1].track[point-1];
 			track->ctl_addr = (control << 4) | adr;
 			track->fad_start = MSF_TO_FAD(pmin, psec, pframe);
-			if (point >= 2)
+			if (point >= 2) {
 			   disc.session[ses-1].track[point-2].fad_end = track->fad_start-1;
+         disc.session[ses-1].track[point-2].file_size = (disc.session[ses-1].track[point-2].fad_end+1-disc.session[ses-1].track[point-2].fad_start)*2352;
+      }
 			track->file_offset = plba*2352;
 			track->sector_size = 2352;
 			track->fp = fp;
-			track->file_size = (track->fad_end+1-track->fad_start)*2352;
 			track->file_id = 0;
 			track->interleaved_sub = 0;
 		}
@@ -1160,69 +1562,20 @@ void BuildTOC()
    isoTOC[101] = (isoTOC[session->track_num - 1] & 0xFF000000) | session->fad_end;
 }
 
-//////////////////////////////////////////////////////////////////////////////
-
-void BuildTOC10()
-{
-   int i;
-   session_info_struct *session=&disc.session[0];
-
-   for (i = 0; i < session->track_num; i++)
-   {
-      isoTOC10[3+i].ctrladr = session->track[i].ctl_addr;
-      isoTOC10[3+i].tno = 0;
-      isoTOC10[3+i].point = i+1;
-      isoTOC10[3+i].min = 0;
-      isoTOC10[3+i].sec = 2;
-      isoTOC10[3+i].frame = 0;
-      isoTOC10[3+i].zero = 0;
-      Cs2FADToMSF(session->track[i].fad_start, &isoTOC10[3+i].pmin, &isoTOC10[3+i].psec, &isoTOC10[3+i].pframe);
-   }
-
-   isoTOC10[0].ctrladr = isoTOC10[3].ctrladr;
-   isoTOC10[0].tno = 0;
-   isoTOC10[0].point = 0xA0;
-   isoTOC10[0].min = 0;
-   isoTOC10[0].sec = 2;
-   isoTOC10[0].frame = 0;
-   isoTOC10[0].zero = 0;
-   isoTOC10[0].pmin = 1;
-   isoTOC10[0].psec = 0;
-   isoTOC10[0].pframe = 0;
-
-   isoTOC10[1].ctrladr = isoTOC10[3+session->track_num-1].ctrladr;
-   isoTOC10[1].tno = 0;
-   isoTOC10[1].point = 0xA1;
-   isoTOC10[1].min = 0;
-   isoTOC10[1].sec = 2;
-   isoTOC10[1].frame = 0;
-   isoTOC10[1].zero = 0;
-   isoTOC10[1].pmin = session->track_num;
-   isoTOC10[1].psec = 0;
-   isoTOC10[1].pframe = 0;
-
-   isoTOC10[2].ctrladr = isoTOC10[1].ctrladr;
-   isoTOC10[2].tno = 0;
-   isoTOC10[2].point = 0xA2;
-   isoTOC10[2].min = 0;
-   isoTOC10[2].sec = 2;
-   isoTOC10[2].frame = 0;
-   isoTOC10[2].zero = 0;
-   Cs2FADToMSF(session->fad_end, &isoTOC10[2].pmin, &isoTOC10[2].psec, &isoTOC10[2].pframe);
-   isoTOCnum = 3+session->track_num;
-}
-
+#if (defined(IOS) || defined(ANDROID))
+#define stricmp strcasecmp
+#endif
 //////////////////////////////////////////////////////////////////////////////
 
 static int ISOCDInit(const char * iso) {
    char header[6];
    char *ext;
-   int ret;
+   int ret = -1;
    FILE *iso_file;
    size_t num_read = 0;
-
    memset(isoTOC, 0xFF, 0xCC * 2);
    memset(&disc, 0, sizeof(disc));
+   iso_cd_status = 0;
 
    if (!iso)
       return -1;
@@ -1233,28 +1586,42 @@ static int ISOCDInit(const char * iso) {
       return -1;
    }
 
-   num_read = fread((void *)header, 1, 6, iso_file);
    ext = strrchr(iso, '.');
 
    // Figure out what kind of image format we're dealing with
-   if (stricmp(ext, ".CUE") == 0 && strncmp(header, "FILE \"", 6) == 0)
+   if (stricmp(ext, ".CUE") == 0)
    {
       // It's a BIN/CUE
       imgtype = IMG_BINCUE;
       ret = LoadBinCue(iso, iso_file);
    }
-   else if (stricmp(ext, ".MDS") == 0 && strncmp(header, "MEDIA ", sizeof(header)) == 0)
+   else if (stricmp(ext, ".ZIP") == 0)
+   {
+      // It's a BIN/CUE
+      imgtype = IMG_BINCUE;
+      ret = LoadBinCueInZip(iso, iso_file);
+   }
+   else if (stricmp(ext, ".MDS") == 0) {
+     num_read = fread((void *)header, 1, 6, iso_file);
+     if (strncmp(header, "MEDIA ", sizeof(header)) == 0)
+     {
+        // It's a MDS
+        imgtype = IMG_MDS;
+        ret = LoadMDS(iso, iso_file);
+     }
+   }
+   else if (stricmp(ext, ".CCD") == 0)
    {
-      // It's a MDS
-      imgtype = IMG_MDS;
-      ret = LoadMDS(iso, iso_file);
+  	// It's a CCD
+  	imgtype = IMG_CCD;
+  	ret = LoadCCD(iso, iso_file);
    }
-	else if (stricmp(ext, ".CCD") == 0)
-	{
-		// It's a CCD
-		imgtype = IMG_CCD;
-		ret = LoadCCD(iso, iso_file);
-	}
+  else if (stricmp(ext, ".CHD") == 0)
+  {
+    // It's a CCD
+    imgtype = IMG_CHD;
+    ret = LoadCHD(iso, iso_file);
+  }
    else
    {
       // Assume it's an ISO file
@@ -1270,11 +1637,9 @@ static int ISOCDInit(const char * iso) {
          fclose(iso_file);
       iso_file = NULL;
       return -1;
-   }   
+   }
 
    BuildTOC();
-   if (imgtype != IMG_CCD)
-      BuildTOC10();
    return 0;
 }
 
@@ -1290,6 +1655,22 @@ static void ISOCDDeInit(void) {
          {
             for (j = 0; j < disc.session[i].track_num; j++)
             {
+               if (disc.session[i].track[j].isZip == 1)
+               {
+                 if(disc.session[i].track[j].tr != NULL)
+                 {
+                   if (disc.session[i].track[j].tr->zipBuffer != NULL)
+                     free(disc.session[i].track[j].tr->zipBuffer);
+                   disc.session[i].track[j].tr->zipBuffer = NULL;
+                   if (disc.session[i].track[j].tr->filename != NULL)
+                     free(disc.session[i].track[j].tr->filename);
+                   disc.session[i].track[j].tr->filename = NULL;
+                   free(disc.session[i].track[j].tr);
+                 }
+                 disc.session[i].track[j].tr = NULL;
+               }
+
+
                if (disc.session[i].track[j].fp)
                {
                   fclose(disc.session[i].track[j].fp);
@@ -1306,13 +1687,31 @@ static void ISOCDDeInit(void) {
          }
       }
       free(disc.session);
+      if (disc.zip != NULL)
+        disc.zip->close(disc.zip);
+      disc.zip = NULL;
+      if (disc.endRecord != NULL)
+        disc.endRecord = NULL;
    }
 }
 
 //////////////////////////////////////////////////////////////////////////////
 
 static int ISOCDGetStatus(void) {
-   return disc.session_num > 0 ? 0 : 2;
+	if (iso_cd_status == 0){
+		return disc.session_num > 0 ? 0 : 2;
+	}
+
+	return iso_cd_status;
+}
+
+//#define CDCORE_NORMAL 0
+//#define CDCORE_NODISC 2
+//#define CDCORE_OPEN   3
+
+static void ISOCDSetStatus(int status){
+	iso_cd_status = status;
+	return;
 }
 
 //////////////////////////////////////////////////////////////////////////////
@@ -1332,13 +1731,22 @@ static s32 ISOCDReadTOC10(CDInterfaceToc10 *TOC) {
 
 //////////////////////////////////////////////////////////////////////////////
 
+track_info_struct *currentTrack = NULL;
+
 static int ISOCDReadSectorFAD(u32 FAD, void *buffer) {
    int i,j;
    size_t num_read = 0;
-   track_info_struct *track=NULL;
+   ZipEntry *tr = NULL;
+   u8* zipBuffer;
+   int found = 0;
+   int offset = 0;
 
    assert(disc.session);
 
+   if (IMG_CHD == imgtype) {
+     return ISOCDReadSectorFADFromCHD(FAD,buffer);
+   }
+
    memset(buffer, 0, 2448);
 
    for (i = 0; i < disc.session_num; i++)
@@ -1347,68 +1755,113 @@ static int ISOCDReadSectorFAD(u32 FAD, void *buffer) {
       {
          if (FAD >= disc.session[i].track[j].fad_start &&
              FAD <= disc.session[i].track[j].fad_end)
-         {             
-            track = &disc.session[i].track[j];
+         {
+            track_info_struct *track = &disc.session[i].track[j];
+            if ((currentTrack != track) || (currentTrack == NULL)){
+              currentTrack = track;
+              found = 1;
+              if (currentTrack->isZip == 1) {
+                if (currentTrack->tr == NULL) {
+                  //This should never happen, otherwise we might suffer some delay to deflation during game
+                  printf("%s was not defalted!!!\n", currentTrack->filename);
+                  return 0;
+                }
+              }
+            }
+            tr = currentTrack->tr;
             break;
          }
+         if (found == 1) break;
       }
    }
 
-   if (track == NULL)
+   if (currentTrack == NULL)
    {
-      CDLOG("Warning: Sector not found in track list");
+      CDLOG("Warning: Sector not found in track list\n");
       return 0;
    }
+   if ((currentTrack->isZip == 1) && (tr == NULL)) {
+     CDLOG("Warning Zip file: Sector not found in track list\n");
+     return 0;
+   }
+   offset = currentTrack->file_offset + (FAD-currentTrack->fad_start) * currentTrack->sector_size;
+   if (currentTrack->isZip != 1) {
+	 if (offset > currentTrack->file_size) offset = currentTrack->file_size;
+     fseek(currentTrack->fp, offset, SEEK_SET);
+   } else {
+	 if (offset > tr->size) offset = tr->size;
+     zipBuffer = &tr->zipBuffer[offset];
+
+   }
 
-   fseek(track->fp, track->file_offset + (FAD-track->fad_start) * track->sector_size, SEEK_SET);
-	if (track->sub_fp)
-		fseek(track->sub_fp, track->file_offset + (FAD-track->fad_start) * 96, SEEK_SET);
-   if (track->sector_size == 2448)
+   if (currentTrack->sector_size == 2448)
    {
-      if (!track->interleaved_sub)
-		{
-			if (track->sub_fp)
-			{
-            num_read = fread(buffer, 2352, 1, track->fp);
-            num_read = fread((char *)buffer + 2352, 96, 1, track->sub_fp);
-			}
-			else
-            num_read = fread(buffer, 2448, 1, track->fp);
-		}
+      if (!currentTrack->interleaved_sub)
+      {
+         if (currentTrack->isZip != 1) {
+           num_read = fread(buffer, 2448, 1, currentTrack->fp);
+         } else {
+           int delta = ((tr->size - offset) < 2448)?(tr->size - offset):2448;
+           memcpy(buffer, zipBuffer, delta);
+           zipBuffer+=delta;
+         }
+      }
       else
       {
          const u16 deint_offsets[] = {
-            0, 66, 125, 191, 100, 50, 150, 175, 8, 33, 58, 83, 
-            108, 133, 158, 183, 16, 41, 25, 91, 116, 141, 166, 75, 
-            24, 90, 149, 215, 124, 74, 174, 199, 32, 57, 82, 107, 
-            132, 157, 182, 207, 40, 65, 49, 115, 140, 165, 190, 99, 
-            48, 114, 173, 239, 148, 98, 198, 223, 56, 81, 106, 131, 
-            156, 181, 206, 231, 64, 89, 73, 139, 164, 189, 214, 123, 
-            72, 138, 197, 263, 172, 122, 222, 247, 80, 105, 130, 155, 
+            0, 66, 125, 191, 100, 50, 150, 175, 8, 33, 58, 83,
+            108, 133, 158, 183, 16, 41, 25, 91, 116, 141, 166, 75,
+            24, 90, 149, 215, 124, 74, 174, 199, 32, 57, 82, 107,
+            132, 157, 182, 207, 40, 65, 49, 115, 140, 165, 190, 99,
+            48, 114, 173, 239, 148, 98, 198, 223, 56, 81, 106, 131,
+            156, 181, 206, 231, 64, 89, 73, 139, 164, 189, 214, 123,
+            72, 138, 197, 263, 172, 122, 222, 247, 80, 105, 130, 155,
             180, 205, 230, 255, 88, 113, 97, 163, 188, 213, 238, 147
          };
          u8 subcode_buffer[96 * 3];
-
-         num_read = fread(buffer, 2352, 1, track->fp);
-
-         num_read = fread(subcode_buffer, 96, 1, track->fp);
-         fseek(track->fp, 2352, SEEK_CUR);
-         num_read = fread(subcode_buffer + 96, 96, 1, track->fp);
-         fseek(track->fp, 2352, SEEK_CUR);
-         num_read = fread(subcode_buffer + 192, 96, 1, track->fp);
-         for (i = 0; i < 96; i++)
-            ((u8 *)buffer)[2352+i] = subcode_buffer[deint_offsets[i]];
+         if (currentTrack->isZip != 1) {
+           num_read = fread(buffer, 2352, 1, currentTrack->fp);
+
+           num_read = fread(subcode_buffer, 96, 1, currentTrack->fp);
+           fseek(currentTrack->fp, 2352, SEEK_CUR);
+           num_read = fread(subcode_buffer + 96, 96, 1, currentTrack->fp);
+           fseek(currentTrack->fp, 2352, SEEK_CUR);
+           num_read = fread(subcode_buffer + 192, 96, 1, currentTrack->fp);
+         } else {
+           int delta = ((tr->size - offset) < 2352)?(tr->size - offset):2352;
+           //if ((tr->size - offset) < 2352) return 0;
+           memcpy(buffer, zipBuffer, delta);
+           zipBuffer+=delta;
+           memcpy(&subcode_buffer[0], zipBuffer, 96);
+           memcpy(&subcode_buffer[96], zipBuffer, 96);
+           memcpy(&subcode_buffer[192], zipBuffer, 96);
+           zipBuffer+=96;
+         }
+           for (i = 0; i < 96; i++)
+              ((u8 *)buffer)[2352+i] = subcode_buffer[deint_offsets[i]];
       }
    }
-   else if (track->sector_size == 2352)
+   else if (currentTrack->sector_size == 2352)
    {
-      // Generate subcodes here
-      num_read = fread(buffer, 2352, 1, track->fp);
+      if (currentTrack->isZip != 1) {
+        // Generate subcodes here
+        num_read = fread(buffer, 2352, 1, currentTrack->fp);
+      } else {
+        int delta = ((tr->size - offset) < 2352)?(tr->size - offset):2352;
+        memcpy(buffer, zipBuffer, delta);
+        zipBuffer+=delta;
+      }
    }
-   else if (track->sector_size == 2048)
+   else if (currentTrack->sector_size == 2048)
    {
       memcpy(buffer, syncHdr, 12);
-      num_read = fread((char *)buffer + 0x10, 2048, 1, track->fp);
+      if (currentTrack->isZip != 1) {
+        num_read = fread((char *)buffer + 0x10, 2048, 1, currentTrack->fp);
+      } else {
+        int delta = ((tr->size - offset) < 2048)?(tr->size - offset):2048;
+        memcpy((char *)buffer + 0x10, zipBuffer, delta);
+        zipBuffer+=delta;
+      }
    }
 	return 1;
 }
@@ -1421,3 +1874,286 @@ static void ISOCDReadAheadFAD(UNUSED u32 FAD)
 }
 
 //////////////////////////////////////////////////////////////////////////////
+
+#define CD_MAX_SECTOR_DATA      (2352)
+#define CD_MAX_SUBCODE_DATA     (96)
+#define CD_FRAME_SIZE           (CD_MAX_SECTOR_DATA + CD_MAX_SUBCODE_DATA)
+#define CD_MAX_TRACKS           (99)    /* AFAIK the theoretical limit */
+#define CD_TRACK_PADDING 4
+
+typedef struct ChdInfo_ {
+  chd_file *chd;
+  core_file * image_file;
+  const chd_header * header;
+  char * hunk_buffer;
+  int current_hunk_id;
+} ChdInfo;
+
+ChdInfo * pChdInfo = NULL;
+
+static int LoadCHD(const char *chd_filename, FILE *iso_file)
+{
+  int trak_number;
+  char track_type[64];
+  char track_subtype[64];
+  int frame = 0;
+  int pregap = 0;
+  char pg_type[64];
+  char pg_sub_type[64];
+  int postgap = 0;
+
+  int meta_outlen = 512 * 1024;
+  u8 * buf = malloc(meta_outlen);
+  u32 resultlen;
+  u32 resulttag;
+  u8 resultflags;
+
+  if (pChdInfo != NULL) {
+    free(pChdInfo);
+  }
+
+  pChdInfo = malloc(sizeof(ChdInfo));
+  memset(pChdInfo, 0, sizeof(ChdInfo));
+
+  track_info_struct trk[100];
+  memset(trk, 0, sizeof(trk));
+
+  int num_tracks = 0;
+
+  chd_error error = chd_open(chd_filename, CHD_OPEN_READ, NULL, &pChdInfo->chd);
+  if (error != CHDERR_NONE) {
+    free(buf);
+    return -1;
+  }
+
+  pChdInfo->header = chd_get_header(pChdInfo->chd);
+
+  trk[num_tracks].fad_start = frame + pregap + 150;
+
+  while ( chd_get_metadata(pChdInfo->chd, 0, num_tracks, buf, meta_outlen, &resultlen, &resulttag, &resultflags) == CHDERR_NONE )  {
+
+    LOG("track info %s", buf);
+    switch (resulttag) {
+    case CDROM_TRACK_METADATA_TAG:
+      sscanf(buf, CDROM_TRACK_METADATA_FORMAT, &trak_number, track_type, track_subtype, &frame);
+      pregap = 0;
+      postgap = 0;
+      sprintf(pg_type, "NONE");
+      break;
+    case CDROM_TRACK_METADATA2_TAG:
+      sscanf(buf, CDROM_TRACK_METADATA2_FORMAT, &trak_number, track_type, track_subtype, &frame, &pregap, pg_type, pg_sub_type, &postgap);
+      break;
+    default:
+      return -1;
+    }
+
+    trk[num_tracks].pregap = pregap;
+    trk[num_tracks].postgap = postgap;
+
+    trk[num_tracks].frames = frame;
+    int padded = (frame + CD_TRACK_PADDING - 1) / CD_TRACK_PADDING;
+    trk[num_tracks].extraframes = padded * CD_TRACK_PADDING - frame;
+
+
+    if (!strcmp(track_type, "MODE1"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2048;
+    }
+    else if (!strcmp(track_type, "MODE1/2048"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2048;
+    }
+    else if (!strcmp(track_type, "MODE1_RAW"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2352;
+    }
+    else if (!strcmp(track_type, "MODE1/2352"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2352;
+    }
+    else if (!strcmp(track_type, "MODE2"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2336;
+    }
+    else if (!strcmp(track_type, "MODE2/2336"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2336;
+    }
+    else if (!strcmp(track_type, "MODE2_FORM1"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2048;
+    }
+    else if (!strcmp(track_type, "MODE2/2048"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2048;
+    }
+    else if (!strcmp(track_type, "MODE2_FORM2"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2324;
+    }
+    else if (!strcmp(track_type, "MODE2/2324"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2324;
+    }
+    else if (!strcmp(track_type, "MODE2_FORM_MIX"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2336;
+    }
+    else if (!strcmp(track_type, "MODE2/2336"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2336;
+    }
+    else if (!strcmp(track_type, "MODE2_RAW"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2352;
+    }
+    else if (!strcmp(track_type, "MODE2/2352"))
+    {
+      trk[num_tracks].ctl_addr = 0x41;
+      trk[num_tracks].sector_size = 2352;
+    }
+    else if (!strcmp(track_type, "AUDIO"))
+    {
+      trk[num_tracks].ctl_addr = 0x01;
+      trk[num_tracks].sector_size = 2352;
+      //trk[num_tracks].pregap = 0;
+    }
+
+    //trk[num_tracks].fad_start = trk[num_tracks].fad_start + pregap;
+    //trk[num_tracks].fad_end = trk[num_tracks].fad_start + (frame - 1) + postgap;
+    //frame = trk[num_tracks].fad_end+1;
+    num_tracks++;
+    //trk[num_tracks].fad_start = frame;
+  }
+  free(buf);
+
+  trk[num_tracks].file_offset = 0;
+  trk[num_tracks].fad_start = 0xFFFFFFFF;
+
+  u32 chdofs = 0;
+  u32 physofs = 0;
+  u32 logofs = 150;
+  int i;
+  for (i = 0; i < num_tracks; i++)
+  {
+    trk[i].fad_start = logofs + trk[i].pregap;
+
+    trk[i].physframeofs = physofs;
+    trk[i].chdframeofs = chdofs;
+    trk[i].logframeofs = logofs;
+
+    //logofs += trk[i].pregap;
+    //logofs += trk[i].postgap;
+    logofs += trk[i].frames;
+    trk[i].fad_end = logofs;
+
+    physofs += trk[i].frames;
+
+    chdofs += trk[i].frames;
+    chdofs += trk[i].extraframes;
+  }
+  trk[i].logframeofs = logofs;
+  trk[i].physframeofs = physofs;
+  trk[i].chdframeofs = chdofs;
+
+  //trk[num_tracks - 1].fad_end = (pChdInfo->header->logicalbytes - trk[num_tracks - 1].file_offset) / trk[num_tracks - 1].sector_size;
+
+  disc.session_num = 1;
+  disc.session = malloc(sizeof(session_info_struct) * disc.session_num);
+  if (disc.session == NULL)
+  {
+    YabSetError(YAB_ERR_MEMORYALLOC, NULL);
+    return -1;
+  }
+  disc.session[0].fad_start = 150;
+  disc.session[0].fad_end = trk[num_tracks - 1].fad_end;
+  disc.session[0].track_num = num_tracks;
+  disc.session[0].track = malloc(sizeof(track_info_struct) * disc.session[0].track_num);
+  if (disc.session[0].track == NULL)
+  {
+    YabSetError(YAB_ERR_MEMORYALLOC, NULL);
+    free(disc.session);
+    disc.session = NULL;
+    return -1;
+  }
+
+  memcpy(disc.session[0].track, trk, num_tracks * sizeof(track_info_struct));
+
+  pChdInfo->hunk_buffer = malloc(pChdInfo->header->hunkbytes);
+  chd_read(pChdInfo->chd, 0, pChdInfo->hunk_buffer);
+  pChdInfo->current_hunk_id = 0;
+
+  return 0;
+}
+
+
+static int ISOCDReadSectorFADFromCHD(u32 FAD, void *buffer) {
+  int i, j;
+  size_t num_read = 0;
+  track_info_struct *track = NULL;
+  u32 chdlba;
+  u32 physlba;
+  u32 loglba = FAD;
+
+  chdlba = loglba;
+  for (i = 0; i < disc.session_num; i++)
+  {
+    for (j = 0; j < disc.session[i].track_num; j++)
+    {
+      //if (j == 1) {
+      //  int a = 0;
+      //}
+      if (loglba < disc.session[i].track[j+1].logframeofs) {
+        //if ((loglba > disc.session[i].track[j].pregap)) {
+       //   loglba -= disc.session[i].track[j].pregap;
+       // }
+        physlba = disc.session[i].track[j].physframeofs + (loglba - disc.session[i].track[j].logframeofs);
+        //if (disc.session[i].track[j].ctl_addr == 0x01) {
+        //  physlba += disc.session[i].track[j].pregap;
+        //}
+        chdlba = physlba - disc.session[i].track[j].physframeofs + disc.session[i].track[j].chdframeofs;
+        track = &disc.session[i].track[j];
+        break;
+      }
+    }
+  }
+
+  if (track == NULL)
+  {
+    CDLOG("Warning: Sector not found in track list");
+    return 0;
+  }
+
+  int hunkid = (chdlba*CD_FRAME_SIZE) / pChdInfo->header->hunkbytes ;
+  int hunk_offset =  (chdlba*CD_FRAME_SIZE) % pChdInfo->header->hunkbytes;
+
+  if (pChdInfo->current_hunk_id != hunkid) {
+    chd_read(pChdInfo->chd, hunkid, pChdInfo->hunk_buffer);
+    pChdInfo->current_hunk_id = hunkid;
+  }
+
+  if (track->ctl_addr == 0x01) {
+    for (int i = 0; i < track->sector_size; i += 2) {
+      ((char*)buffer)[i] = pChdInfo->hunk_buffer[hunk_offset + i + 1];
+      ((char*)buffer)[i+1] = pChdInfo->hunk_buffer[hunk_offset + i];
+    }
+  }
+  else {
+    memcpy(buffer, pChdInfo->hunk_buffer + hunk_offset, track->sector_size);
+  }
+
+  return 1;
+}
diff --git a/yabause/src/cdbase.h b/yabause/src/cdbase.h
index 7130900..0ed48ae 100644
--- a/yabause/src/cdbase.h
+++ b/yabause/src/cdbase.h
@@ -33,6 +33,11 @@
 #define CDCORE_DUMMY    0
 #define CDCORE_ISO      1
 #define CDCORE_ARCH     2
+#define CDCORE_CHD      3
+
+#define CDCORE_NORMAL 0
+#define CDCORE_NODISC 2
+#define CDCORE_OPEN   3
 
 typedef struct
 {
@@ -59,8 +64,16 @@ typedef struct
         s32 (*ReadTOC10)(CDInterfaceToc10 *TOC);
         int (*ReadSectorFAD)(u32 FAD, void *buffer);
         void (*ReadAheadFAD)(u32 FAD);
+        void(*SetStatus)(int status);
 } CDInterface;
 
+typedef struct
+{
+  char* filename;
+  u8* zipBuffer;
+  u32 size;
+} ZipEntry;
+
 extern CDInterface DummyCD;
 
 extern CDInterface ISOCD;
diff --git a/yabause/src/qt/ui/UISettings.cpp b/yabause/src/qt/ui/UISettings.cpp
index 1dead65..bc05fe8 100755
--- a/yabause/src/qt/ui/UISettings.cpp
+++ b/yabause/src/qt/ui/UISettings.cpp
@@ -219,7 +219,7 @@ void UISettings::tbBrowse_clicked()
 			return;
 		}
 		else if ( cbCdRom->currentText().contains( "iso", Qt::CaseInsensitive ) )
-			requestFile( QtYabause::translate( "Select your iso/cue/bin file" ), leCdRom, QtYabause::translate( "CD Images (*.iso *.cue *.bin *.mds *.ccd)" ) );
+			requestFile( QtYabause::translate( "Select your iso/cue/bin/zip/chd file" ), leCdRom, QtYabause::translate( "CD Images (*.iso *.ISO *.cue *.CUE *.bin *.BIN *.mds *.MDS *.ccd *.CCD *.zip *.ZIP *.chd *.CHD)" ) );
 		else
 			requestFolder( QtYabause::translate( "Choose a cdrom drive/mount point" ), leCdRom );
 	}
diff --git a/yabause/src/qt/ui/UIYabause.cpp b/yabause/src/qt/ui/UIYabause.cpp
index 7431cb4..421b2bb 100644
--- a/yabause/src/qt/ui/UIYabause.cpp
+++ b/yabause/src/qt/ui/UIYabause.cpp
@@ -835,7 +835,7 @@ void UIYabause::on_aFileSettings_triggered()
 void UIYabause::on_aFileOpenISO_triggered()
 {
 	YabauseLocker locker( mYabauseThread );
-	const QString fn = CommonDialogs::getOpenFileName( QtYabause::volatileSettings()->value( "Recents/ISOs" ).toString(), QtYabause::translate( "Select your iso/cue/bin file" ), QtYabause::translate( "CD Images (*.iso *.cue *.bin *.mds *.ccd)" ) );
+	const QString fn = CommonDialogs::getOpenFileName( QtYabause::volatileSettings()->value( "Recents/ISOs" ).toString(), QtYabause::translate( "Select your iso/cue/bin/zip/chd file" ), QtYabause::translate( "CD Images (*.iso *.ISO *.cue *.CUE *.bin *.BIN *.mds *.MDS *.ccd *.CCD *.zip *.ZIP *.chd *.CHD)" ) );
 	if ( !fn.isEmpty() )
 	{
 		VolatileSettings* vs = QtYabause::volatileSettings();
diff --git a/yabause/src/tools/junzip/junzip.c b/yabause/src/tools/junzip/junzip.c
new file mode 100644
index 0000000..2afd0f3
--- /dev/null
+++ b/yabause/src/tools/junzip/junzip.c
@@ -0,0 +1,285 @@
+// JUnzip library by Joonas Pihlajamaa. See junzip.h for license and details.
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "zlib.h"
+
+#include "junzip.h"
+
+unsigned char jzBuffer[JZ_BUFFER_SIZE]; // limits maximum zip descriptor size
+
+// Read ZIP file end record. Will move within file.
+int jzReadEndRecord(JZFile *zip, JZEndRecord *endRecord) {
+    long fileSize, readBytes, i;
+    JZEndRecord *er;
+
+    if(zip->seek(zip, 0, SEEK_END)) {
+        fprintf(stderr, "Couldn't go to end of zip file!");
+        return Z_ERRNO;
+    }
+
+    if((fileSize = zip->tell(zip)) <= sizeof(JZEndRecord)) {
+        fprintf(stderr, "Too small file to be a zip!");
+        return Z_ERRNO;
+    }
+
+    readBytes = (fileSize < sizeof(jzBuffer)) ? fileSize : sizeof(jzBuffer);
+
+    if(zip->seek(zip, fileSize - readBytes, SEEK_SET)) {
+        fprintf(stderr, "Cannot seek in zip file!");
+        return Z_ERRNO;
+    }
+
+    if(zip->read(zip, jzBuffer, readBytes) < readBytes) {
+        fprintf(stderr, "Couldn't read end of zip file!");
+        return Z_ERRNO;
+    }
+
+    // Naively assume signature can only be found in one place...
+    for(i = readBytes - sizeof(JZEndRecord); i >= 0; i--) {
+        er = (JZEndRecord *)(jzBuffer + i);
+        if(er->signature == 0x06054B50)
+            break;
+    }
+
+    if(i < 0) {
+        fprintf(stderr, "End record signature not found in zip!");
+        return Z_ERRNO;
+    }
+
+    memcpy(endRecord, er, sizeof(JZEndRecord));
+
+    if(endRecord->diskNumber || endRecord->centralDirectoryDiskNumber ||
+            endRecord->numEntries != endRecord->numEntriesThisDisk) {
+        fprintf(stderr, "Multifile zips not supported!");
+        return Z_ERRNO;
+    }
+
+    return Z_OK;
+}
+
+// Read ZIP file global directory. Will move within file.
+int jzReadCentralDirectory(JZFile *zip, JZEndRecord *endRecord,
+        JZRecordCallback callback, void *user_data) {
+    JZGlobalFileHeader fileHeader;
+    JZFileHeader header;
+    int i;
+
+    if(zip->seek(zip, endRecord->centralDirectoryOffset, SEEK_SET)) {
+        fprintf(stderr, "Cannot seek in zip file!");
+        return Z_ERRNO;
+    }
+
+    for(i=0; i<endRecord->numEntries; i++) {
+        if(zip->read(zip, &fileHeader, sizeof(JZGlobalFileHeader)) <
+                sizeof(JZGlobalFileHeader)) {
+            fprintf(stderr, "Couldn't read file header %d!", i);
+            return Z_ERRNO;
+        }
+
+        if(fileHeader.signature != 0x02014B50) {
+            fprintf(stderr, "Invalid file header signature %d!", i);
+            return Z_ERRNO;
+        }
+
+        if(fileHeader.fileNameLength + 1 >= JZ_BUFFER_SIZE) {
+            fprintf(stderr, "Too long file name %d!", i);
+            return Z_ERRNO;
+        }
+
+        if(zip->read(zip, jzBuffer, fileHeader.fileNameLength) <
+                fileHeader.fileNameLength) {
+            fprintf(stderr, "Couldn't read filename %d!", i);
+            return Z_ERRNO;
+        }
+
+        jzBuffer[fileHeader.fileNameLength] = '\0'; // NULL terminate
+
+        if(zip->seek(zip, fileHeader.extraFieldLength, SEEK_CUR) ||
+                zip->seek(zip, fileHeader.fileCommentLength, SEEK_CUR)) {
+            fprintf(stderr, "Couldn't skip extra field or file comment %d", i);
+            return Z_ERRNO;
+        }
+
+        // Construct JZFileHeader from global file header
+        memcpy(&header, &fileHeader.compressionMethod, sizeof(header));
+        header.offset = fileHeader.relativeOffsetOflocalHeader;
+
+        if(!callback(zip, i, &header, (char *)jzBuffer, user_data))
+            break; // end if callback returns zero
+    }
+
+    return Z_OK;
+}
+
+// Read local ZIP file header. Silent on errors so optimistic reading possible.
+int jzReadLocalFileHeader(JZFile *zip, JZFileHeader *header,
+        char *filename, int len) {
+    JZLocalFileHeader localHeader;
+
+    if(zip->read(zip, &localHeader, sizeof(JZLocalFileHeader)) <
+            sizeof(JZLocalFileHeader))
+        return Z_ERRNO;
+
+    if(localHeader.signature != 0x04034B50)
+        return Z_ERRNO;
+
+    if(len) { // read filename
+        if(localHeader.fileNameLength >= len)
+            return Z_ERRNO; // filename cannot fit
+
+        if(zip->read(zip, filename, localHeader.fileNameLength) <
+                localHeader.fileNameLength)
+            return Z_ERRNO; // read fail
+
+        filename[localHeader.fileNameLength] = '\0'; // NULL terminate
+    } else { // skip filename
+        if(zip->seek(zip, localHeader.fileNameLength, SEEK_CUR))
+            return Z_ERRNO;
+    }
+
+    if(localHeader.extraFieldLength) {
+        if(zip->seek(zip, localHeader.extraFieldLength, SEEK_CUR))
+            return Z_ERRNO;
+    }
+
+    // For now, silently ignore bit flags and hope ZLIB can uncompress
+    // if(localHeader.generalPurposeBitFlag)
+    //     return Z_ERRNO; // Flags not supported
+
+    if(localHeader.compressionMethod == 0 &&
+            (localHeader.compressedSize != localHeader.uncompressedSize))
+        return Z_ERRNO; // Method is "store" but sizes indicate otherwise, abort
+
+    memcpy(header, &localHeader.compressionMethod, sizeof(JZFileHeader));
+    header->offset = 0; // not used in local context
+
+    return Z_OK;
+}
+
+// Read data from file stream, described by header, to preallocated buffer
+int jzReadData(JZFile *zip, JZFileHeader *header, void *buffer) {
+    unsigned char *bytes = (unsigned char *)buffer; // cast
+    long compressedLeft, uncompressedLeft;
+    z_stream strm;
+    int ret;
+
+    if(header->compressionMethod == 0) { // Store - just read it
+        if(zip->read(zip, buffer, header->uncompressedSize) <
+                header->uncompressedSize || zip->error(zip))
+            return Z_ERRNO;
+    } else if(header->compressionMethod == 8) { // Deflate - using zlib
+        strm.zalloc = Z_NULL;
+        strm.zfree = Z_NULL;
+        strm.opaque = Z_NULL;
+
+        strm.avail_in = 0;
+        strm.next_in = Z_NULL;
+
+        // Use inflateInit2 with negative window bits to indicate raw data
+        if((ret = inflateInit2(&strm, -MAX_WBITS)) != Z_OK)
+            return ret; // Zlib errors are negative
+
+        // Inflate compressed data
+        for(compressedLeft = header->compressedSize,
+                uncompressedLeft = header->uncompressedSize;
+                compressedLeft && uncompressedLeft && ret != Z_STREAM_END;
+                compressedLeft -= strm.avail_in) {
+            // Read next chunk
+            strm.avail_in = zip->read(zip, jzBuffer,
+                    (sizeof(jzBuffer) < compressedLeft) ?
+                    sizeof(jzBuffer) : compressedLeft);
+
+            if(strm.avail_in == 0 || zip->error(zip)) {
+                inflateEnd(&strm);
+                return Z_ERRNO;
+            }
+
+            strm.next_in = jzBuffer;
+            strm.avail_out = uncompressedLeft;
+            strm.next_out = bytes;
+
+            compressedLeft -= strm.avail_in; // inflate will change avail_in
+
+            ret = inflate(&strm, Z_NO_FLUSH);
+
+            if(ret == Z_STREAM_ERROR) return ret; // shouldn't happen
+
+            switch (ret) {
+                case Z_NEED_DICT:
+                    ret = Z_DATA_ERROR;     /* and fall through */
+                case Z_DATA_ERROR: case Z_MEM_ERROR:
+                    (void)inflateEnd(&strm);
+                    return ret;
+            }
+
+            bytes += uncompressedLeft - strm.avail_out; // bytes uncompressed
+            uncompressedLeft = strm.avail_out;
+        }
+
+        inflateEnd(&strm);
+    } else {
+        return Z_ERRNO;
+    }
+
+    return Z_OK;
+}
+
+
+typedef struct {
+    JZFile handle;
+    FILE *fp;
+} StdioJZFile;
+
+static size_t
+stdio_read_file_handle_read(JZFile *file, void *buf, size_t size)
+{
+    StdioJZFile *handle = (StdioJZFile *)file;
+    return fread(buf, 1, size, handle->fp);
+}
+
+static size_t
+stdio_read_file_handle_tell(JZFile *file)
+{
+    StdioJZFile *handle = (StdioJZFile *)file;
+    return ftell(handle->fp);
+}
+
+static int
+stdio_read_file_handle_seek(JZFile *file, size_t offset, int whence)
+{
+    StdioJZFile *handle = (StdioJZFile *)file;
+    return fseek(handle->fp, offset, whence);
+}
+
+static int
+stdio_read_file_handle_error(JZFile *file)
+{
+    StdioJZFile *handle = (StdioJZFile *)file;
+    return ferror(handle->fp);
+}
+
+static void
+stdio_read_file_handle_close(JZFile *file)
+{
+    StdioJZFile *handle = (StdioJZFile *)file;
+    fclose(handle->fp);
+    free(file);
+}
+
+JZFile *
+jzfile_from_stdio_file(FILE *fp)
+{
+    StdioJZFile *handle = (StdioJZFile *)malloc(sizeof(StdioJZFile));
+
+    handle->handle.read = stdio_read_file_handle_read;
+    handle->handle.tell = stdio_read_file_handle_tell;
+    handle->handle.seek = stdio_read_file_handle_seek;
+    handle->handle.error = stdio_read_file_handle_error;
+    handle->handle.close = stdio_read_file_handle_close;
+    handle->fp = fp;
+
+    return &(handle->handle);
+}
diff --git a/yabause/src/tools/junzip/junzip.h b/yabause/src/tools/junzip/junzip.h
new file mode 100644
index 0000000..013c393
--- /dev/null
+++ b/yabause/src/tools/junzip/junzip.h
@@ -0,0 +1,122 @@
+/**
+ * JUnzip library by Joonas Pihlajamaa (firstname.lastname@iki.fi).
+ * Released into public domain. https://github.com/jokkebk/JUnzip
+ */
+
+#ifndef __JUNZIP_H
+#define __JUNZIP_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif /* __cplusplus */
+
+#include <stdint.h>
+
+// If you don't have stdint.h, the following two lines should work for most 32/64 bit systems
+// typedef unsigned int uint32_t;
+// typedef unsigned short uint16_t;
+
+typedef struct JZFile JZFile;
+
+struct JZFile {
+    size_t (*read)(JZFile *file, void *buf, size_t size);
+    size_t (*tell)(JZFile *file);
+    int (*seek)(JZFile *file, size_t offset, int whence);
+    int (*error)(JZFile *file);
+    void (*close)(JZFile *file);
+};
+
+JZFile *
+jzfile_from_stdio_file(FILE *fp);
+
+#pragma pack(push, 1)
+typedef struct {
+    uint32_t signature;
+    uint16_t versionNeededToExtract; // unsupported
+    uint16_t generalPurposeBitFlag; // unsupported
+    uint16_t compressionMethod;
+    uint16_t lastModFileTime;
+    uint16_t lastModFileDate;
+    uint32_t crc32;
+    uint32_t compressedSize;
+    uint32_t uncompressedSize;
+    uint16_t fileNameLength;
+    uint16_t extraFieldLength; // unsupported
+ }JZLocalFileHeader;
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+typedef struct {
+    uint32_t signature;
+    uint16_t versionMadeBy; // unsupported
+    uint16_t versionNeededToExtract; // unsupported
+    uint16_t generalPurposeBitFlag; // unsupported
+    uint16_t compressionMethod;
+    uint16_t lastModFileTime;
+    uint16_t lastModFileDate;
+    uint32_t crc32;
+    uint32_t compressedSize;
+    uint32_t uncompressedSize;
+    uint16_t fileNameLength;
+    uint16_t extraFieldLength; // unsupported
+    uint16_t fileCommentLength; // unsupported
+    uint16_t diskNumberStart; // unsupported
+    uint16_t internalFileAttributes; // unsupported
+    uint32_t externalFileAttributes; // unsupported
+    uint32_t relativeOffsetOflocalHeader;
+}JZGlobalFileHeader;
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+typedef struct {
+    uint16_t compressionMethod;
+    uint16_t lastModFileTime;
+    uint16_t lastModFileDate;
+    uint32_t crc32;
+    uint32_t compressedSize;
+    uint32_t uncompressedSize;
+    uint32_t offset;
+}JZFileHeader;
+#pragma pack(pop)
+
+#pragma pack(push, 1)
+typedef struct {
+    uint32_t signature; // 0x06054b50
+    uint16_t diskNumber; // unsupported
+    uint16_t centralDirectoryDiskNumber; // unsupported
+    uint16_t numEntriesThisDisk; // unsupported
+    uint16_t numEntries;
+    uint32_t centralDirectorySize;
+    uint32_t centralDirectoryOffset;
+    uint16_t zipCommentLength;
+    // Followed by .ZIP file comment (variable size)
+}JZEndRecord;
+#pragma pack(pop)
+
+// Callback prototype for central and local file record reading functions
+typedef int (*JZRecordCallback)(JZFile *zip, int index, JZFileHeader *header,
+        char *filename, void *user_data);
+
+#define JZ_BUFFER_SIZE 65536
+
+// Read ZIP file end record. Will move within file.
+int jzReadEndRecord(JZFile *zip, JZEndRecord *endRecord);
+
+// Read ZIP file global directory. Will move within file.
+// Callback is called for each record, until callback returns zero
+int jzReadCentralDirectory(JZFile *zip, JZEndRecord *endRecord,
+        JZRecordCallback callback, void *user_data);
+
+// Read local ZIP file header. Silent on errors so optimistic reading possible.
+int jzReadLocalFileHeader(JZFile *zip, JZFileHeader *header,
+        char *filename, int len);
+
+// Read data from file stream, described by header, to preallocated buffer
+// Return value is zlib coded, e.g. Z_OK, or error code
+int jzReadData(JZFile *zip, JZFileHeader *header, void *buffer);
+
+#ifdef __cplusplus
+};
+#endif /* __cplusplus */
+
+#endif
-- 
2.26.2

