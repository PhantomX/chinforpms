2007-02-24  Jakub Jelinek  <jakub@redhat.com>

	* java/util/TimeZone.java (getDefaultDisplayName): Don't
	check if TimeZone is instanceof SimpleTimeZone.

2007-02-23  Jakub Jelinek  <jakub@redhat.com>

	PR libgcj/17002
	PR classpath/28550
	* java/lang/System.java: Add gnu.java.util.zoneinfo.dir to comments.
	* posix.cc (_Jv_platform_initProperties): Set
	gnu.java.util.zoneinfo.dir.
	* Makefile.am (ordinary_java_source_files): Add
	gnu/java/util/ZoneInfo.java.
	* Makefile.in: Regenerated.
	* java/util/Date.java (parse): Properly parse 09:01:02 as
	hours/minutes/seconds, not as hours/minutes/year.
	* java/util/SimpleTimeZone.java (getOffset): Handle properly
	millis + dstOffset overflowing into the next day.
	* java/util/TimeZone.java (zoneinfo_dir, availableIDs, aliases0): New
	static fields.
	(timezones): Remove synchronized keyword.  Set zoneinfo_dir.
	If non-null, set up aliases0 and don't put anything into
	timezones0.
	(defaultZone): Call getTZEnvVar to try TZ env var.
	Try to read /etc/localtime using ZoneInfo.readTZFile.
	Call getDefaultTimeZone instead of getTimeZone.
	(getDefaultTimeZone, getDateParams, parseTime): New private methods.
	(getTimeZoneInternal): New private method.
	(getTimeZone): Do the custom ID checking first, canonicalize
	ID for custom IDs as required by documentation.  Call
	getTimeZoneInternal to handle the rest.
	(getAvailableIDs(int)): Add locking.  Handle zoneinfo_dir != null.
	(getAvailableIDs(File,String,ArrayList)): New private method.
	(getAvailableIDs()): Add locking.  Handle zoneinfo_dir != null.
	(readSysconfigClockFile): New static method.
	(getTZEnvVar): New native method.
	* java/util/natSystem.cc: Include java/lang/Character.h and
	java/lang/Integer.h.
	(java::lang::System::getSystemTimeZone): Renamed to...
	(getSystemTimeZone): ... this.  Add static.
	(java::lang::System::init_properties): Don't set user.timezone
	property.
	(java::util::TimeZone::getDefaultTimeZoneId): New.
	(java::util::TimeZone::getTZEnvVar): New method.
	* gnu/java/util/ZoneInfo.java: New file.
	* java/util/GregorianCalendar.java
	(GregorianCalendar): Call clear before set in the constructors that
	don't initialize it to current time.

2007-02-09  Jakub Jelinek  <jakub@redhat.com>

	PR 23566
	* java/util/TimeZone.java (timezones): Regenerate from tzdata2007a.

2005-02-21  Jeroen Frijters  <jeroen@frijters.net>

	* java/util/GregorianCalendar.java
	(GregorianCalendar): Chained constructors to a (new)
	common constructor.

2004-01-03  Per Bothner  <per@bothner.com>

	* java/util/Date.java (parse):  Fix a number of problems.
	(skipParens):  Remove no-longer-needed method.

2003-11-27  Ito Kazumitsu  <kaz@maczuka.gcd.org>

	* java/util/GregorianCalendar.java (getLinearTime): Avoid counting
	the leap day of the leap year twice.

2003-09-18  Ingo Proetel  <proetel@aicas.com>

	* java/util/TimeZone.java: Initialize lazily.

2002-05-13  Tom Tromey  <tromey@redhat.com>

	* java/util/TimeZone.java (getDefaultTimeZoneId): New method.

--- libjava/Makefile.am.jj	2007-02-23 21:17:39.000000000 +0100
+++ libjava/Makefile.am	2007-02-23 21:28:22.000000000 +0100
@@ -1431,6 +1431,7 @@ gnu/java/text/LineBreakIterator.java \
 gnu/java/text/SentenceBreakIterator.java	\
 gnu/java/text/WordBreakIterator.java \
 gnu/java/util/DoubleEnumeration.java \
+gnu/java/util/ZoneInfo.java \
 java/lang/ref/PhantomReference.java \
 java/lang/ref/Reference.java \
 java/lang/ref/ReferenceQueue.java \
--- libjava/Makefile.in.jj	2007-02-23 21:17:39.000000000 +0100
+++ libjava/Makefile.in	2007-02-23 21:28:55.000000000 +0100
@@ -1183,6 +1183,7 @@ gnu/java/text/LineBreakIterator.java \
 gnu/java/text/SentenceBreakIterator.java	\
 gnu/java/text/WordBreakIterator.java \
 gnu/java/util/DoubleEnumeration.java \
+gnu/java/util/ZoneInfo.java \
 java/lang/ref/PhantomReference.java \
 java/lang/ref/Reference.java \
 java/lang/ref/ReferenceQueue.java \
@@ -2017,7 +2018,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_D
 .deps/gnu/java/text/LineBreakIterator.P \
 .deps/gnu/java/text/SentenceBreakIterator.P \
 .deps/gnu/java/text/WordBreakIterator.P \
-.deps/gnu/java/util/DoubleEnumeration.P .deps/interpret.P \
+.deps/gnu/java/util/DoubleEnumeration.P \
+.deps/gnu/java/util/ZoneInfo.P .deps/interpret.P \
 .deps/java/applet/Applet.P .deps/java/applet/AppletContext.P \
 .deps/java/applet/AppletStub.P .deps/java/applet/AudioClip.P \
 .deps/java/awt/AWTError.P .deps/java/awt/AWTEvent.P \
--- libjava/java/util/GregorianCalendar.java.jj	2007-02-23 21:17:36.000000000 +0100
+++ libjava/java/util/GregorianCalendar.java	2007-02-26 09:54:12.000000000 +0100
@@ -111,6 +111,13 @@ public class GregorianCalendar extends C
     this(TimeZone.getDefault(), locale);
   }
 
+  private GregorianCalendar(TimeZone zone, Locale locale, boolean unused)
+  {
+    super(zone, locale);
+    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale);
+    gregorianCutover = ((Date) rb.getObject("gregorianCutOver")).getTime();
+  }
+
   /**
    * Constructs a new GregorianCalender representing the current
    * time with the given time zone and the given locale.
@@ -119,9 +126,7 @@ public class GregorianCalendar extends C
    */
   public GregorianCalendar(TimeZone zone, Locale locale)
   {
-    super(zone, locale);
-    ResourceBundle rb = ResourceBundle.getBundle(bundleName, locale);
-    gregorianCutover = ((Date) rb.getObject("gregorianCutOver")).getTime();
+    this(zone, locale, false);
     setTimeInMillis(System.currentTimeMillis());
   }
 
@@ -134,7 +139,8 @@ public class GregorianCalendar extends C
    */
   public GregorianCalendar(int year, int month, int day)
   {
-    super();
+    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    clear();
     set(year, month, day);
   }
 
@@ -149,7 +155,8 @@ public class GregorianCalendar extends C
    */
   public GregorianCalendar(int year, int month, int day, int hour, int minute)
   {
-    super();
+    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    clear();
     set(year, month, day, hour, minute);
   }
 
@@ -166,7 +173,8 @@ public class GregorianCalendar extends C
   public GregorianCalendar(int year, int month, int day,
 			   int hour, int minute, int second)
   {
-    super();
+    this(TimeZone.getDefault(), Locale.getDefault(), false);
+    clear();
     set(year, month, day, hour, minute, second);
   }
 
@@ -254,8 +262,10 @@ public class GregorianCalendar extends C
 	//
 	// The additional leap year factor accounts for the fact that
 	// a leap day is not seen on Jan 1 of the leap year.
+	// And on and after the leap day, the leap day has already been
+	// included in dayOfYear.
 	int gregOffset = (year / 400) - (year / 100) + 2;
-	if (isLeapYear (year, true) && dayOfYear < 31 + 29)
+	if (isLeapYear (year, true))
 	  --gregOffset;
 	time += gregOffset * (24 * 60 * 60 * 1000L);
       }
--- libjava/java/util/SimpleTimeZone.java.jj	2007-02-23 21:17:36.000000000 +0100
+++ libjava/java/util/SimpleTimeZone.java	2007-02-23 21:27:21.000000000 +0100
@@ -458,16 +458,34 @@ public class SimpleTimeZone extends Time
     int daylightSavings = 0;
     if (useDaylight && era == GregorianCalendar.AD && year >= startYear)
       {
+	int orig_year = year;
 	// This does only work for Gregorian calendars :-(
 	// This is mainly because setStartYear doesn't take an era.
 
 	boolean afterStart = !isBefore(year, month, day, dayOfWeek, millis,
 				       startMode, startMonth,
 				       startDay, startDayOfWeek, startTime);
+	millis += dstSavings;
+	if (millis >= 24 * 60 * 60 * 1000)
+	  {
+	    millis -= 24 * 60 * 60 * 1000;
+	    dayOfWeek = (dayOfWeek % 7) + 1;
+	    if (++day > getDaysInMonth(month, year))
+	      {
+		day = 1;
+		if (month++ == Calendar.DECEMBER)
+		  {
+		    month = Calendar.JANUARY;
+		    year++;
+		  }
+	      }
+	  }
 	boolean beforeEnd = isBefore(year, month, day, dayOfWeek, millis,
 				     endMode, endMonth,
 				     endDay, endDayOfWeek, endTime);
 
+	if (orig_year != year)
+	  afterStart = false;
 	if (startMonth < endMonth)
 	  {
 	    // use daylight savings, if the date is after the start of
--- libjava/java/util/Date.java.jj	2007-02-23 21:17:36.000000000 +0100
+++ libjava/java/util/Date.java	2007-02-26 09:43:28.000000000 +0100
@@ -304,34 +304,6 @@ public class Date implements Cloneable, 
     return format.format(this);
   }
 
-  private static int skipParens(String string, int offset)
-  {
-    int len = string.length();
-    int p = 0;
-    int i;
-
-    for (i = offset; i < len; ++i)
-      {
-	if (string.charAt(i) == '(')
-	  ++p;
-	else if (string.charAt(i) == ')')
-	  {
-	    --p;
-	    if (p == 0)
-	      return i + 1;
-	    // If we've encounted unbalanced parens, just return the
-	    // leftover one as an ordinary character.  It will be
-	    // caught later in parsing and cause an
-	    // IllegalArgumentException.
-      	    if (p < 0)
-	      return i;
-	  }
-      }
-
-    // Not sure what to do if `p != 0' here.
-    return i;
-  }
-
   private static int parseTz(String tok, char sign)
     throws IllegalArgumentException
   {
@@ -408,20 +380,25 @@ public class Date implements Cloneable, 
 
     // Trim out any nested stuff in parentheses now to make parsing easier.
     StringBuffer buf = new StringBuffer();
-    int off = 0;
-    int openParenOffset, tmpMonth;
-    while ((openParenOffset = string.indexOf('(', off)) >= 0)
+    int parenNesting = 0;
+    int len = string.length();
+    for (int i = 0;  i < len;  i++)
       {
-	// Copy part of string leading up to open paren.
-	buf.append(string.substring(off, openParenOffset));
-	off = skipParens(string, openParenOffset);
+	char ch = string.charAt(i);
+	if (ch >= 'a' && ch <= 'z')
+	  ch -= 'a' - 'A';
+	if (ch == '(')
+	  parenNesting++;
+	else if (parenNesting == 0)
+	  buf.append(ch);
+	else if (ch == ')')
+	  parenNesting--;
       }
-    buf.append(string.substring(off));
+    int tmpMonth;
 
     // Make all chars upper case to simplify comparisons later.
     // Also ignore commas; treat them as delimiters.
-    StringTokenizer strtok =
-      new StringTokenizer(buf.toString().toUpperCase(), " \t\n\r,");
+    StringTokenizer strtok = new StringTokenizer(buf.toString(), " \t\n\r,");
 
     while (strtok.hasMoreTokens())
       {
@@ -434,58 +411,69 @@ public class Date implements Cloneable, 
 	  }
 	else if (firstch >= '0' && firstch <= '9')
 	  {
+	    int lastPunct = -1;
 	    while (tok != null && tok.length() > 0)
 	      {
-	        // A colon or slash may be valid in the number.
-	        // Find the first of these before calling parseInt.
-	        int colon = tok.indexOf(':');
-	        int slash = tok.indexOf('/');
-	        int hyphen = tok.indexOf('-');
-		// We choose tok.length initially because it makes
-		// processing simpler.
-	        int punctOffset = tok.length();
-		if (colon >= 0)
-		  punctOffset = Math.min(punctOffset, colon);
-	        if (slash >= 0)
-	          punctOffset = Math.min(punctOffset, slash);
-	        if (hyphen >= 0)
-	          punctOffset = Math.min(punctOffset, hyphen);
-		// Following code relies on -1 being the exceptional
-		// case.
-		if (punctOffset == tok.length())
-		  punctOffset = -1;
-
-	        int num;
-	        try
-	          {
-		    num = Integer.parseInt(punctOffset < 0 ? tok :
-					   tok.substring(0, punctOffset));
-	          }
-	        catch (NumberFormatException ex)
-	          {
-		    throw new IllegalArgumentException(tok);
-	          }
-
-		// TBD: Spec says year can be followed by a slash.  That might
-		// make sense if using YY/MM/DD formats, but it would fail in
-		// that format for years <= 70.  Also, what about 1900?  That
-		// is interpreted as the year 3800; seems that the comparison
-		// should be num >= 1900 rather than just > 1900.
-		// What about a year of 62 - 70?  (61 or less could be a (leap)
-		// second).  70/MM/DD cause an exception but 71/MM/DD is ok
-		// even though there's no ambiguity in either case.
-		// For the parse method, the spec as written seems too loose.
-		// Until shown otherwise, we'll follow the spec as written.
-	        if (num > 70 && (punctOffset < 0 || punctOffset == slash))
-		  year = num > 1900 ? num - 1900 : num;
-		else if (punctOffset > 0 && punctOffset == colon)
+		int punctOffset = tok.length();
+		int num = 0;
+		int punct;
+		for (int i = 0;  ;  i++)
+		  {
+		    if (i >= punctOffset)
+		      {
+			punct = -1;
+			break;
+		      }
+		    else
+		      {
+			punct = tok.charAt(i);
+			if (punct >= '0' && punct <= '9')
+			  {
+			    if (num > 999999999) // in case of overflow
+			      throw new IllegalArgumentException(tok);
+			    num = 10 * num + (punct - '0');
+			  }
+			else
+			  {
+			    punctOffset = i;
+			    break;
+			  }
+		      }
+		      
+		  }
+
+		if (punct == ':')
 		  {
 		    if (hour < 0)
 		      hour = num;
 		    else
 		      minute = num;
 		  }
-		else if (punctOffset > 0 && punctOffset == slash)
+		else if (lastPunct == ':' && hour >= 0 && (minute < 0 || second < 0))
+		  {
+		    if (minute < 0)
+		      minute = num;
+		    else
+		      second = num;
+		  }
+	        else if ((num >= 70
+			  && (punct == ' ' || punct == ','
+			      || punct == '/' || punct < 0))
+			 || (num < 70 && day >= 0 && month >= 0 && year < 0))
+		  {
+		    if (num >= 100)
+		      year = num;
+		    else
+		      {
+			int curYear = 1900 + new Date().getYear();
+			int firstYear = curYear - 80;
+			year = firstYear / 100 * 100 + num;
+			int yx = year;
+			if (year < firstYear)
+			  year += 100;
+		      }
+		  }
+		else if (punct == '/')
 		  {
 		    if (month < 0)
 		      month = num - 1;
@@ -502,10 +490,11 @@ public class Date implements Cloneable, 
 		  throw new IllegalArgumentException(tok);
 
 		// Advance string if there's more to process in this token.
-		if (punctOffset < 0 || punctOffset + 1 >= tok.length())
+		if (punct < 0 || punctOffset + 1 >= tok.length())
 		  tok = null;
 		else
 		  tok = tok.substring(punctOffset + 1);
+		lastPunct = punct;
 	      }
 	  }
 	else if (firstch >= 'A' && firstch <= 'Z')
@@ -573,22 +562,29 @@ public class Date implements Cloneable, 
 	  throw new IllegalArgumentException(tok);
       }
 
-    // Unspecified minutes and seconds should default to 0.
+    // Unspecified hours, minutes, or seconds should default to 0.
+    if (hour < 0)
+      hour = 0;
     if (minute < 0)
       minute = 0;
     if (second < 0)
       second = 0;
 
     // Throw exception if any other fields have not been recognized and set.
-    if (year < 0 || month < 0 || day < 0 || hour < 0)
+    if (year < 0 || month < 0 || day < 0)
       throw new IllegalArgumentException("Missing field");
 
     // Return the time in either local time or relative to GMT as parsed.
     // If no time-zone was specified, get the local one (in minutes) and
     // convert to milliseconds before adding to the UTC.
-    return UTC(year, month, day, hour, minute, second) + (localTimezone ?
-		new Date(year, month, day).getTimezoneOffset() * 60 * 1000:
-		-timezone * 60 * 1000);
+    GregorianCalendar cal
+      = new GregorianCalendar(year, month, day, hour, minute, second);
+    if (!localTimezone)
+      {
+	cal.set(Calendar.ZONE_OFFSET, timezone * 60 * 1000);
+	cal.set(Calendar.DST_OFFSET, 0);
+      }
+    return cal.getTimeInMillis();
   }
 
   /**
--- libjava/java/lang/natSystem.cc.jj	2007-02-23 21:17:31.000000000 +0100
+++ libjava/java/lang/natSystem.cc	2007-02-24 22:04:41.000000000 +0100
@@ -51,6 +51,8 @@ details.  */
 #include <java/lang/Class.h>
 #include <java/lang/ArrayStoreException.h>
 #include <java/lang/ArrayIndexOutOfBoundsException.h>
+#include <java/lang/Character.h>
+#include <java/lang/Integer.h>
 #include <java/lang/NullPointerException.h>
 #include <java/lang/StringBuffer.h>
 #include <java/util/Properties.h>
@@ -229,61 +231,6 @@ getpwuid_adaptor(T_passwd * (*getpwuid_r
 }
 #endif
 
-/*
- * This method returns a time zone string that is used by init_properties
- * to set the default timezone property 'user.timezone'.  That value is
- * used by default as a key into the timezone table used by the
- * java::util::TimeZone class.
- */
-jstring
-java::lang::System::getSystemTimeZone (void)
-{
-  struct tm *tim;
-  time_t current_time;
-  long tzoffset;
-  const char *tz1, *tz2;
-  char *tzid;
-
-  current_time = time(0);
-
-  mktime(tim = localtime(&current_time));
-#ifdef STRUCT_TM_HAS_GMTOFF
-  // tm_gmtoff is secs EAST of UTC.
-  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;
-#elif HAVE_TIMEZONE
-  // timezone is secs WEST of UTC.
-  tzoffset = timezone;	
-#else
-  // FIXME: there must be another global if neither tm_gmtoff nor timezone
-  // is available, esp. if tzname is valid.
-  // Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to
-  // calculate between gmtime and localtime (and accounting for possible
-  // daylight savings time) as an alternative.
-  tzoffset = 0L;
-#endif
-
-#ifdef HAVE_TM_ZONE
-  tz1 = tim->tm_zone;
-  tz2 = "";
-#elif defined (HAVE_TZNAME)
-  tz1 = tzname[0];
-  tz2 = strcmp (tzname[0], tzname[1]) ? tzname[1] : "";
-#else
-  // Some targets have no concept of timezones.
-  tz1 = "???";
-  tz2 = tz1;
-#endif
-
-  if ((tzoffset % 3600) == 0)
-    tzoffset = tzoffset / 3600;
-
-  tzid = (char*) _Jv_Malloc (strlen(tz1) + strlen(tz2) + 6);
-  sprintf(tzid, "%s%ld%s", tz1, tzoffset, tz2);
-  jstring retval = JvNewStringUTF (tzid);
-  _Jv_Free (tzid);
-
-  return retval;
-}
 
 extern void _Jv_SetDLLSearchPath (const char *);
 
@@ -441,11 +388,6 @@ java::lang::System::init_properties (voi
       SET ("user.region", "US");
     }  
 
-  // Set the "user.timezone" property.
-  jstring timezone = getDefaultTimeZoneId ();
-  if (timezone != NULL)
-    newprops->put (JvNewStringLatin1 ("user.timezone"), timezone);
-
   // Set some properties according to whatever was compiled in with
   // `-D'.
   for (int i = 0; _Jv_Compiler_Properties[i]; ++i)
@@ -529,3 +471,146 @@ java::lang::System::init_properties (voi
   // synchronized in the common case.
   properties = newprops;
 }
+
+/*
+ * This method returns a time zone string that is used by init_properties
+ * to set the default timezone property 'user.timezone'.  That value is
+ * used by default as a key into the timezone table used by the
+ * java::util::TimeZone class.
+ */
+static jstring
+getSystemTimeZone (void)
+{
+  struct tm *tim;
+  time_t current_time;
+  long tzoffset;
+  const char *tz1, *tz2;
+  char *tzid;
+
+  current_time = time(0);
+
+  mktime(tim = localtime(&current_time));
+#ifdef STRUCT_TM_HAS_GMTOFF
+  // tm_gmtoff is secs EAST of UTC.
+  tzoffset = -(tim->tm_gmtoff) + tim->tm_isdst * 3600L;
+#elif HAVE_TIMEZONE
+  // timezone is secs WEST of UTC.
+  tzoffset = timezone;	
+#else
+  // FIXME: there must be another global if neither tm_gmtoff nor timezone
+  // is available, esp. if tzname is valid.
+  // Richard Earnshaw <rearnsha@arm.com> has suggested using difftime to
+  // calculate between gmtime and localtime (and accounting for possible
+  // daylight savings time) as an alternative.
+  tzoffset = 0L;
+#endif
+
+#ifdef HAVE_TM_ZONE
+  tz1 = tim->tm_zone;
+  tz2 = "";
+#elif defined (HAVE_TZNAME)
+  tz1 = tzname[0];
+  tz2 = strcmp (tzname[0], tzname[1]) ? tzname[1] : "";
+#else
+  // Some targets have no concept of timezones.
+  tz1 = "???";
+  tz2 = tz1;
+#endif
+
+  if ((tzoffset % 3600) == 0)
+    tzoffset = tzoffset / 3600;
+
+  tzid = (char*) _Jv_Malloc (strlen(tz1) + strlen(tz2) + 6);
+  sprintf(tzid, "%s%ld%s", tz1, tzoffset, tz2);
+  jstring retval = JvNewStringUTF (tzid);
+  _Jv_Free (tzid);
+
+  return retval;
+}
+
+// Get the System Timezone as reported by the OS.  It should be in
+// the form PST8PDT so we'll need to parse it and check that it's valid.
+// FIXME: Using the code from Classpath for generating the System
+// Timezone IMO is suboptimal because it ignores whether the rules for
+// DST match up.
+jstring
+java::util::TimeZone::getDefaultTimeZoneId ()
+{
+  jstring sysTimeZoneId = getSystemTimeZone ();
+
+  using namespace java::lang;
+
+  // Check if this is a valid timezone.  Make sure the IDs match
+  // since getTimeZone returns GMT if no match is found.
+  TimeZone *tz = TimeZone::getTimeZone (sysTimeZoneId);
+  if (tz->getID ()->equals (sysTimeZoneId))
+    return sysTimeZoneId;
+
+  // Check if the base part of sysTimeZoneId is a valid timezone that
+  // matches with daylight usage and rawOffset.  Make sure the IDs match
+  // since getTimeZone returns GMT if no match is found.
+  // First find start of GMT offset info and any Daylight zone name.
+  int startGMToffset = 0;
+  int sysTimeZoneIdLength = sysTimeZoneId->length();
+  for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)
+    {
+      if (Character::isDigit (sysTimeZoneId->charAt (i)))
+	startGMToffset = i;
+    }
+
+  int startDaylightZoneName = 0;
+  jboolean usesDaylight = false;
+  for (int i = sysTimeZoneIdLength - 1;
+       i >= 0 && !Character::isDigit (sysTimeZoneId->charAt (i)); --i)
+    {
+      startDaylightZoneName = i;
+    }
+  if (startDaylightZoneName > 0)
+    usesDaylight = true;
+
+  int GMToffset
+    = Integer::parseInt (startDaylightZoneName == 0 ?
+			 sysTimeZoneId->substring (startGMToffset) :
+			 sysTimeZoneId->substring (startGMToffset,
+						   startDaylightZoneName));
+
+  // Offset could be in hours or seconds.  Convert to millis.
+  if (GMToffset < 24)
+    GMToffset *= 60 * 60;
+  GMToffset *= -1000;
+
+  jstring tzBasename = sysTimeZoneId->substring (0, startGMToffset);
+  tz = TimeZone::getTimeZone (tzBasename);
+  if (tz->getID ()->equals (tzBasename) && tz->getRawOffset () == GMToffset)
+    {
+      jboolean tzUsesDaylight = tz->useDaylightTime ();
+      if (usesDaylight && tzUsesDaylight || !usesDaylight && !tzUsesDaylight)
+	return tzBasename;
+    }
+
+  // If no match, see if a valid timezone has the same attributes as this
+  // and then use it instead.
+  jstringArray IDs = TimeZone::getAvailableIDs (GMToffset);
+  jstring *elts = elements (IDs);
+  for (int i = 0; i < IDs->length; ++i)
+    {
+      // FIXME: The daylight savings rules may not match the rules
+      // for the desired zone.
+      jboolean IDusesDaylight =
+	TimeZone::getTimeZone (elts[i])->useDaylightTime ();
+      if (usesDaylight && IDusesDaylight || !usesDaylight && !IDusesDaylight)
+	return elts[i];
+    }
+
+  // If all else fails, return null.
+  return NULL;
+}
+
+jstring
+java::util::TimeZone::getTZEnvVar ()
+{
+  const char *tzenv = ::getenv ("TZ");
+  if (tzenv == NULL)
+    return NULL;
+  return JvNewStringUTF (tzenv);
+}
--- libjava/java/util/TimeZone.java.jj	2007-02-23 21:17:36.000000000 +0100
+++ libjava/java/util/TimeZone.java	2007-02-24 21:54:41.000000000 +0100
@@ -1,5 +1,6 @@
 /* java.util.TimeZone
-   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
+   Copyright (C) 1998, 1999, 2000, 2001, 2002, 2003
+   Free Software Foundation, Inc.
 
 This file is part of GNU Classpath.
 
@@ -37,6 +38,13 @@ exception statement from your version. *
 
 
 package java.util;
+import gnu.java.util.ZoneInfo;
+import java.io.BufferedInputStream;
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.InputStreamReader;
+import java.io.IOException;
 import java.text.DateFormatSymbols;
 
 /**
@@ -79,690 +87,1215 @@ public abstract class TimeZone implement
   /**
    * The default time zone, as returned by getDefault.
    */
-  private static TimeZone defaultZone;
+  private static TimeZone defaultZone0;
+  /* initialize this static field lazily to overhead if
+   * it is not needed: 
+   */
+  private static synchronized TimeZone defaultZone() {
+    /* Look up default timezone */
+    if (defaultZone0 == null) 
+      {
+        // System.loadLibrary("javautil");
+	String tzid = System.getProperty("user.timezone");
+
+	if (tzid == null)
+	  {
+	    tzid = getTZEnvVar();
+	    if (tzid != null && tzid.equals(""))
+	      tzid = null;
+	  }
+
+	if (tzid == null)
+	  {
+	    TimeZone zone = ZoneInfo.readTZFile((String) null, "/etc/localtime");
+	    if (zone != null)
+	      {
+		// Try to find a more suitable ID for the /etc/localtime
+		// timezone.
+		// Sometimes /etc/localtime is a symlink to some
+		// /usr/share/zoneinfo/ file.
+		String id = null;
+		try
+		  {
+		    id = new File("/etc/localtime").getCanonicalPath();
+		    if (id != null)
+		      {
+			String zoneinfo_dir
+			  = System.getProperty("gnu.java.util.zoneinfo.dir");
+			if (zoneinfo_dir != null)
+			  zoneinfo_dir
+			    = new File(zoneinfo_dir
+				       + File.separatorChar).getCanonicalPath();
+			if (zoneinfo_dir != null && id.startsWith(zoneinfo_dir))
+			  {
+			    int pos = zoneinfo_dir.length();
+			    while (pos < id.length()
+				   && id.charAt(pos) == File.separatorChar)
+			      pos++;
+			    if (pos < id.length())
+			      id = id.substring(pos);
+			    else
+			      id = null;
+			  }
+			else
+			  id = null;
+		      }
+		  }
+		catch (IOException ioe)
+		  {
+		    id = null;
+		  }
+
+		if (id == null)
+		  id = readSysconfigClockFile("/etc/sysconfig/clock");
+
+		if (id != null)
+		  zone.setID(id);
+		defaultZone0 = zone;
+		return defaultZone0;
+	      }
+	  }
+
+	if (tzid == null)
+	  tzid = getDefaultTimeZoneId();
+
+	if (tzid == null)
+	  tzid = "GMT";
+
+	defaultZone0 = getDefaultTimeZone(tzid);
+      }
+    return defaultZone0; 
+  }
+
 
   private static final long serialVersionUID = 3581463369166924961L;
 
   /**
-   * Hashtable for timezones by ID.  
+   * Flag whether zoneinfo data should be used,
+   * otherwise builtin timezone data will be provided.
    */
-  private static final Hashtable timezones = new Hashtable();
+  private static String zoneinfo_dir;
 
-  static
-  {
-    TimeZone tz;
-    // Automatically generated by scripts/timezones.pl
-    // XXX - Should we read this data from a file?
-    tz = new SimpleTimeZone(-11000 * 3600, "MIT");
-    timezones.put("MIT", tz);
-    timezones.put("Pacific/Apia", tz);
-    timezones.put("Pacific/Midway", tz);
-    timezones.put("Pacific/Niue", tz);
-    timezones.put("Pacific/Pago_Pago", tz);
-    tz = new SimpleTimeZone
-      (-10000 * 3600, "America/Adak",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("America/Adak", tz);
-    tz = new SimpleTimeZone(-10000 * 3600, "HST");
-    timezones.put("HST", tz);
-    timezones.put("Pacific/Fakaofo", tz);
-    timezones.put("Pacific/Honolulu", tz);
-    timezones.put("Pacific/Johnston", tz);
-    timezones.put("Pacific/Rarotonga", tz);
-    timezones.put("Pacific/Tahiti", tz);
-    tz = new SimpleTimeZone(-9500 * 3600, "Pacific/Marquesas");
-    timezones.put("Pacific/Marquesas", tz);
-    tz = new SimpleTimeZone
-      (-9000 * 3600, "AST",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("AST", tz);
-    timezones.put("America/Anchorage", tz);
-    timezones.put("America/Juneau", tz);
-    timezones.put("America/Nome", tz);
-    timezones.put("America/Yakutat", tz);
-    tz = new SimpleTimeZone(-9000 * 3600, "Pacific/Gambier");
-    timezones.put("Pacific/Gambier", tz);
-    tz = new SimpleTimeZone
-      (-8000 * 3600, "PST",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("PST", tz);
-    timezones.put("PST8PDT", tz);
-    timezones.put("America/Dawson", tz);
-    timezones.put("America/Los_Angeles", tz);
-    timezones.put("America/Tijuana", tz);
-    timezones.put("America/Vancouver", tz);
-    timezones.put("America/Whitehorse", tz);
-    timezones.put("US/Pacific-New", tz);
-    tz = new SimpleTimeZone(-8000 * 3600, "Pacific/Pitcairn");
-    timezones.put("Pacific/Pitcairn", tz);
-    tz = new SimpleTimeZone
-      (-7000 * 3600, "MST",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("MST", tz);
-    timezones.put("MST7MDT", tz);
-    timezones.put("America/Boise", tz);
-    timezones.put("America/Chihuahua", tz);
-    timezones.put("America/Denver", tz);
-    timezones.put("America/Edmonton", tz);
-    timezones.put("America/Inuvik", tz);
-    timezones.put("America/Mazatlan", tz);
-    timezones.put("America/Shiprock", tz);
-    timezones.put("America/Yellowknife", tz);
-    tz = new SimpleTimeZone(-7000 * 3600, "MST7");
-    timezones.put("MST7", tz);
-    timezones.put("PNT", tz);
-    timezones.put("America/Dawson_Creek", tz);
-    timezones.put("America/Hermosillo", tz);
-    timezones.put("America/Phoenix", tz);
-    tz = new SimpleTimeZone
-      (-6000 * 3600, "CST",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("CST", tz);
-    timezones.put("CST6CDT", tz);
-    timezones.put("America/Cambridge_Bay", tz);
-    timezones.put("America/Cancun", tz);
-    timezones.put("America/Chicago", tz);
-    timezones.put("America/Menominee", tz);
-    timezones.put("America/Merida", tz);
-    timezones.put("America/Mexico_City", tz);
-    timezones.put("America/Monterrey", tz);
-    timezones.put("America/Rainy_River", tz);
-    timezones.put("America/Winnipeg", tz);
-    tz = new SimpleTimeZone(-6000 * 3600, "America/Belize");
-    timezones.put("America/Belize", tz);
-    timezones.put("America/Costa_Rica", tz);
-    timezones.put("America/El_Salvador", tz);
-    timezones.put("America/Guatemala", tz);
-    timezones.put("America/Managua", tz);
-    timezones.put("America/Regina", tz);
-    timezones.put("America/Swift_Current", tz);
-    timezones.put("America/Tegucigalpa", tz);
-    timezones.put("Pacific/Galapagos", tz);
-    tz = new SimpleTimeZone
-      (-6000 * 3600, "Pacific/Easter",
-       Calendar.OCTOBER, 9, -Calendar.SUNDAY, 0 * 3600,
-       Calendar.MARCH, 9, -Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Pacific/Easter", tz);
-    tz = new SimpleTimeZone
-      (-5000 * 3600, "America/Grand_Turk",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Grand_Turk", tz);
-    timezones.put("America/Havana", tz);
-    tz = new SimpleTimeZone(-5000 * 3600, "EST5");
-    timezones.put("EST5", tz);
-    timezones.put("IET", tz);
-    timezones.put("America/Bogota", tz);
-    timezones.put("America/Cayman", tz);
-    timezones.put("America/Eirunepe", tz);
-    timezones.put("America/Guayaquil", tz);
-    timezones.put("America/Indiana/Indianapolis", tz);
-    timezones.put("America/Indiana/Knox", tz);
-    timezones.put("America/Indiana/Marengo", tz);
-    timezones.put("America/Indiana/Vevay", tz);
-    timezones.put("America/Indianapolis", tz);
-    timezones.put("America/Iqaluit", tz);
-    timezones.put("America/Jamaica", tz);
-    timezones.put("America/Lima", tz);
-    timezones.put("America/Panama", tz);
-    timezones.put("America/Pangnirtung", tz);
-    timezones.put("America/Port-au-Prince", tz);
-    timezones.put("America/Porto_Acre", tz);
-    timezones.put("America/Rankin_Inlet", tz);
-    tz = new SimpleTimeZone
-      (-5000 * 3600, "EST",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("EST", tz);
-    timezones.put("EST5EDT", tz);
-    timezones.put("America/Detroit", tz);
-    timezones.put("America/Kentucky/Louisville", tz);
-    timezones.put("America/Kentucky/Monticello", tz);
-    timezones.put("America/Louisville", tz);
-    timezones.put("America/Montreal", tz);
-    timezones.put("America/Nassau", tz);
-    timezones.put("America/New_York", tz);
-    timezones.put("America/Nipigon", tz);
-    timezones.put("America/Thunder_Bay", tz);
-    tz = new SimpleTimeZone(-4000 * 3600, "PRT");
-    timezones.put("PRT", tz);
-    timezones.put("America/Anguilla", tz);
-    timezones.put("America/Antigua", tz);
-    timezones.put("America/Aruba", tz);
-    timezones.put("America/Barbados", tz);
-    timezones.put("America/Boa_Vista", tz);
-    timezones.put("America/Caracas", tz);
-    timezones.put("America/Curacao", tz);
-    timezones.put("America/Dominica", tz);
-    timezones.put("America/Grenada", tz);
-    timezones.put("America/Guadeloupe", tz);
-    timezones.put("America/Guyana", tz);
-    timezones.put("America/La_Paz", tz);
-    timezones.put("America/Manaus", tz);
-    timezones.put("America/Martinique", tz);
-    timezones.put("America/Montserrat", tz);
-    timezones.put("America/Port_of_Spain", tz);
-    timezones.put("America/Porto_Velho", tz);
-    timezones.put("America/Puerto_Rico", tz);
-    timezones.put("America/Santo_Domingo", tz);
-    timezones.put("America/St_Kitts", tz);
-    timezones.put("America/St_Lucia", tz);
-    timezones.put("America/St_Thomas", tz);
-    timezones.put("America/St_Vincent", tz);
-    timezones.put("America/Tortola", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "America/Asuncion",
-       Calendar.OCTOBER, 1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Asuncion", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "America/Cuiaba",
-       Calendar.OCTOBER, 2, Calendar.SUNDAY, 0 * 3600,
-       Calendar.FEBRUARY, 3, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Cuiaba", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "America/Goose_Bay",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 60000,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 60000);
-    timezones.put("America/Goose_Bay", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "America/Glace_Bay",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("America/Glace_Bay", tz);
-    timezones.put("America/Halifax", tz);
-    timezones.put("America/Thule", tz);
-    timezones.put("Atlantic/Bermuda", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "America/Santiago",
-       Calendar.OCTOBER, 9, -Calendar.SUNDAY, 0 * 3600,
-       Calendar.MARCH, 9, -Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Santiago", tz);
-    timezones.put("Antarctica/Palmer", tz);
-    tz = new SimpleTimeZone
-      (-4000 * 3600, "Atlantic/Stanley",
-       Calendar.SEPTEMBER, 2, Calendar.SUNDAY, 0 * 3600,
-       Calendar.APRIL, 16, -Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Atlantic/Stanley", tz);
-    tz = new SimpleTimeZone
-      (-3500 * 3600, "CNT",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 60000,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 60000);
-    timezones.put("CNT", tz);
-    timezones.put("America/St_Johns", tz);
-    tz = new SimpleTimeZone
-      (-3000 * 3600, "America/Araguaina",
-       Calendar.OCTOBER, 2, Calendar.SUNDAY, 0 * 3600,
-       Calendar.FEBRUARY, 3, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Araguaina", tz);
-    timezones.put("America/Sao_Paulo", tz);
-    tz = new SimpleTimeZone(-3000 * 3600, "AGT");
-    timezones.put("AGT", tz);
-    timezones.put("America/Belem", tz);
-    timezones.put("America/Buenos_Aires", tz);
-    timezones.put("America/Catamarca", tz);
-    timezones.put("America/Cayenne", tz);
-    timezones.put("America/Cordoba", tz);
-    timezones.put("America/Fortaleza", tz);
-    timezones.put("America/Jujuy", tz);
-    timezones.put("America/Maceio", tz);
-    timezones.put("America/Mendoza", tz);
-    timezones.put("America/Montevideo", tz);
-    timezones.put("America/Paramaribo", tz);
-    timezones.put("America/Recife", tz);
-    timezones.put("America/Rosario", tz);
-    tz = new SimpleTimeZone
-      (-3000 * 3600, "America/Godthab",
-       Calendar.MARCH, 30, -Calendar.SATURDAY, 22000 * 3600,
-       Calendar.OCTOBER, 30, -Calendar.SATURDAY, 22000 * 3600);
-    timezones.put("America/Godthab", tz);
-    tz = new SimpleTimeZone
-      (-3000 * 3600, "America/Miquelon",
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("America/Miquelon", tz);
-    tz = new SimpleTimeZone(-2000 * 3600, "America/Noronha");
-    timezones.put("America/Noronha", tz);
-    timezones.put("Atlantic/South_Georgia", tz);
-    tz = new SimpleTimeZone
-      (-1000 * 3600, "America/Scoresbysund",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("America/Scoresbysund", tz);
-    timezones.put("Atlantic/Azores", tz);
-    tz = new SimpleTimeZone(-1000 * 3600, "Atlantic/Cape_Verde");
-    timezones.put("Atlantic/Cape_Verde", tz);
-    timezones.put("Atlantic/Jan_Mayen", tz);
-    tz = new SimpleTimeZone(0 * 3600, "GMT");
-    timezones.put("GMT", tz);
-    timezones.put("UTC", tz);
-    timezones.put("Africa/Abidjan", tz);
-    timezones.put("Africa/Accra", tz);
-    timezones.put("Africa/Bamako", tz);
-    timezones.put("Africa/Banjul", tz);
-    timezones.put("Africa/Bissau", tz);
-    timezones.put("Africa/Casablanca", tz);
-    timezones.put("Africa/Conakry", tz);
-    timezones.put("Africa/Dakar", tz);
-    timezones.put("Africa/El_Aaiun", tz);
-    timezones.put("Africa/Freetown", tz);
-    timezones.put("Africa/Lome", tz);
-    timezones.put("Africa/Monrovia", tz);
-    timezones.put("Africa/Nouakchott", tz);
-    timezones.put("Africa/Ouagadougou", tz);
-    timezones.put("Africa/Sao_Tome", tz);
-    timezones.put("Africa/Timbuktu", tz);
-    timezones.put("Atlantic/Reykjavik", tz);
-    timezones.put("Atlantic/St_Helena", tz);
-    timezones.put("Europe/Belfast", tz);
-    timezones.put("Europe/Dublin", tz);
-    timezones.put("Europe/London", tz);
-    tz = new SimpleTimeZone
-      (0 * 3600, "WET",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 1000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);
-    timezones.put("WET", tz);
-    timezones.put("Atlantic/Canary", tz);
-    timezones.put("Atlantic/Faeroe", tz);
-    timezones.put("Atlantic/Madeira", tz);
-    timezones.put("Europe/Lisbon", tz);
-    tz = new SimpleTimeZone(1000 * 3600, "Africa/Algiers");
-    timezones.put("Africa/Algiers", tz);
-    timezones.put("Africa/Bangui", tz);
-    timezones.put("Africa/Brazzaville", tz);
-    timezones.put("Africa/Douala", tz);
-    timezones.put("Africa/Kinshasa", tz);
-    timezones.put("Africa/Lagos", tz);
-    timezones.put("Africa/Libreville", tz);
-    timezones.put("Africa/Luanda", tz);
-    timezones.put("Africa/Malabo", tz);
-    timezones.put("Africa/Ndjamena", tz);
-    timezones.put("Africa/Niamey", tz);
-    timezones.put("Africa/Porto-Novo", tz);
-    timezones.put("Africa/Tunis", tz);
-    tz = new SimpleTimeZone
-      (1000 * 3600, "Africa/Windhoek",
-       Calendar.SEPTEMBER, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Africa/Windhoek", tz);
-    tz = new SimpleTimeZone
-      (1000 * 3600, "CET",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("CET", tz);
-    timezones.put("ECT", tz);
-    timezones.put("MET", tz);
-    timezones.put("Africa/Ceuta", tz);
-    timezones.put("Arctic/Longyearbyen", tz);
-    timezones.put("Europe/Amsterdam", tz);
-    timezones.put("Europe/Andorra", tz);
-    timezones.put("Europe/Belgrade", tz);
-    timezones.put("Europe/Berlin", tz);
-    timezones.put("Europe/Bratislava", tz);
-    timezones.put("Europe/Brussels", tz);
-    timezones.put("Europe/Budapest", tz);
-    timezones.put("Europe/Copenhagen", tz);
-    timezones.put("Europe/Gibraltar", tz);
-    timezones.put("Europe/Ljubljana", tz);
-    timezones.put("Europe/Luxembourg", tz);
-    timezones.put("Europe/Madrid", tz);
-    timezones.put("Europe/Malta", tz);
-    timezones.put("Europe/Monaco", tz);
-    timezones.put("Europe/Oslo", tz);
-    timezones.put("Europe/Paris", tz);
-    timezones.put("Europe/Prague", tz);
-    timezones.put("Europe/Rome", tz);
-    timezones.put("Europe/San_Marino", tz);
-    timezones.put("Europe/Sarajevo", tz);
-    timezones.put("Europe/Skopje", tz);
-    timezones.put("Europe/Stockholm", tz);
-    timezones.put("Europe/Tirane", tz);
-    timezones.put("Europe/Vaduz", tz);
-    timezones.put("Europe/Vatican", tz);
-    timezones.put("Europe/Vienna", tz);
-    timezones.put("Europe/Warsaw", tz);
-    timezones.put("Europe/Zagreb", tz);
-    timezones.put("Europe/Zurich", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "ART",
-       Calendar.APRIL, -1, Calendar.FRIDAY, 0 * 3600,
-       Calendar.SEPTEMBER, -1, Calendar.THURSDAY, 23000 * 3600);
-    timezones.put("ART", tz);
-    timezones.put("Africa/Cairo", tz);
-    tz = new SimpleTimeZone(2000 * 3600, "CAT");
-    timezones.put("CAT", tz);
-    timezones.put("Africa/Blantyre", tz);
-    timezones.put("Africa/Bujumbura", tz);
-    timezones.put("Africa/Gaborone", tz);
-    timezones.put("Africa/Harare", tz);
-    timezones.put("Africa/Johannesburg", tz);
-    timezones.put("Africa/Kigali", tz);
-    timezones.put("Africa/Lubumbashi", tz);
-    timezones.put("Africa/Lusaka", tz);
-    timezones.put("Africa/Maputo", tz);
-    timezones.put("Africa/Maseru", tz);
-    timezones.put("Africa/Mbabane", tz);
-    timezones.put("Africa/Tripoli", tz);
-    timezones.put("Europe/Riga", tz);
-    timezones.put("Europe/Tallinn", tz);
-    timezones.put("Europe/Vilnius", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Asia/Amman",
-       Calendar.MARCH, -1, Calendar.THURSDAY, 0 * 3600,
-       Calendar.SEPTEMBER, -1, Calendar.THURSDAY, 0 * 3600);
-    timezones.put("Asia/Amman", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Asia/Beirut",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Asia/Beirut", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Asia/Damascus",
-       Calendar.APRIL, 1, 0, 0 * 3600,
-       Calendar.OCTOBER, 1, 0, 0 * 3600);
-    timezones.put("Asia/Damascus", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Asia/Gaza",
-       Calendar.APRIL, 3, Calendar.FRIDAY, 0 * 3600,
-       Calendar.OCTOBER, 3, Calendar.FRIDAY, 0 * 3600);
-    timezones.put("Asia/Gaza", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Asia/Jerusalem",
-       Calendar.APRIL, 1, 0, 1000 * 3600,
-       Calendar.OCTOBER, 1, 0, 1000 * 3600);
-    timezones.put("Asia/Jerusalem", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "EET",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
-    timezones.put("EET", tz);
-    timezones.put("Asia/Istanbul", tz);
-    timezones.put("Asia/Nicosia", tz);
-    timezones.put("Europe/Athens", tz);
-    timezones.put("Europe/Bucharest", tz);
-    timezones.put("Europe/Chisinau", tz);
-    timezones.put("Europe/Helsinki", tz);
-    timezones.put("Europe/Istanbul", tz);
-    timezones.put("Europe/Kiev", tz);
-    timezones.put("Europe/Nicosia", tz);
-    timezones.put("Europe/Simferopol", tz);
-    timezones.put("Europe/Sofia", tz);
-    timezones.put("Europe/Uzhgorod", tz);
-    timezones.put("Europe/Zaporozhye", tz);
-    tz = new SimpleTimeZone
-      (2000 * 3600, "Europe/Kaliningrad",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Europe/Kaliningrad", tz);
-    timezones.put("Europe/Minsk", tz);
-    tz = new SimpleTimeZone
-      (3000 * 3600, "Asia/Baghdad",
-       Calendar.APRIL, 1, 0, 3000 * 3600,
-       Calendar.OCTOBER, 1, 0, 3000 * 3600);
-    timezones.put("Asia/Baghdad", tz);
-    tz = new SimpleTimeZone
-      (3000 * 3600, "Europe/Moscow",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Europe/Moscow", tz);
-    timezones.put("Europe/Tiraspol", tz);
-    tz = new SimpleTimeZone(3000 * 3600, "EAT");
-    timezones.put("EAT", tz);
-    timezones.put("Africa/Addis_Ababa", tz);
-    timezones.put("Africa/Asmera", tz);
-    timezones.put("Africa/Dar_es_Salaam", tz);
-    timezones.put("Africa/Djibouti", tz);
-    timezones.put("Africa/Kampala", tz);
-    timezones.put("Africa/Khartoum", tz);
-    timezones.put("Africa/Mogadishu", tz);
-    timezones.put("Africa/Nairobi", tz);
-    timezones.put("Antarctica/Syowa", tz);
-    timezones.put("Asia/Aden", tz);
-    timezones.put("Asia/Bahrain", tz);
-    timezones.put("Asia/Kuwait", tz);
-    timezones.put("Asia/Qatar", tz);
-    timezones.put("Asia/Riyadh", tz);
-    timezones.put("Indian/Antananarivo", tz);
-    timezones.put("Indian/Comoro", tz);
-    timezones.put("Indian/Mayotte", tz);
-    tz = new SimpleTimeZone(3500 * 3600, "Asia/Tehran");
-    timezones.put("Asia/Tehran", tz);
-    tz = new SimpleTimeZone
-      (4000 * 3600, "Asia/Baku",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 1000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);
-    timezones.put("Asia/Baku", tz);
-    tz = new SimpleTimeZone
-      (4000 * 3600, "Asia/Aqtau",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Asia/Aqtau", tz);
-    timezones.put("Asia/Tbilisi", tz);
-    tz = new SimpleTimeZone
-      (4000 * 3600, "Asia/Yerevan",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Yerevan", tz);
-    timezones.put("Europe/Samara", tz);
-    tz = new SimpleTimeZone(4000 * 3600, "NET");
-    timezones.put("NET", tz);
-    timezones.put("Asia/Dubai", tz);
-    timezones.put("Asia/Muscat", tz);
-    timezones.put("Indian/Mahe", tz);
-    timezones.put("Indian/Mauritius", tz);
-    timezones.put("Indian/Reunion", tz);
-    tz = new SimpleTimeZone(4500 * 3600, "Asia/Kabul");
-    timezones.put("Asia/Kabul", tz);
-    tz = new SimpleTimeZone
-      (5000 * 3600, "Asia/Aqtobe",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Asia/Aqtobe", tz);
-    tz = new SimpleTimeZone
-      (5000 * 3600, "Asia/Bishkek",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2500 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2500 * 3600);
-    timezones.put("Asia/Bishkek", tz);
-    tz = new SimpleTimeZone
-      (5000 * 3600, "Asia/Yekaterinburg",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Yekaterinburg", tz);
-    tz = new SimpleTimeZone(5000 * 3600, "PLT");
-    timezones.put("PLT", tz);
-    timezones.put("Asia/Ashgabat", tz);
-    timezones.put("Asia/Dushanbe", tz);
-    timezones.put("Asia/Karachi", tz);
-    timezones.put("Asia/Samarkand", tz);
-    timezones.put("Asia/Tashkent", tz);
-    timezones.put("Indian/Chagos", tz);
-    timezones.put("Indian/Kerguelen", tz);
-    timezones.put("Indian/Maldives", tz);
-    tz = new SimpleTimeZone(5500 * 3600, "IST");
-    timezones.put("IST", tz);
-    timezones.put("Asia/Calcutta", tz);
-    tz = new SimpleTimeZone(5750 * 3600, "Asia/Katmandu");
-    timezones.put("Asia/Katmandu", tz);
-    tz = new SimpleTimeZone(6000 * 3600, "BST");
-    timezones.put("BST", tz);
-    timezones.put("Antarctica/Mawson", tz);
-    timezones.put("Asia/Colombo", tz);
-    timezones.put("Asia/Dhaka", tz);
-    timezones.put("Asia/Thimphu", tz);
-    tz = new SimpleTimeZone
-      (6000 * 3600, "Asia/Almaty",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
-    timezones.put("Asia/Almaty", tz);
-    tz = new SimpleTimeZone
-      (6000 * 3600, "Asia/Novosibirsk",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Novosibirsk", tz);
-    timezones.put("Asia/Omsk", tz);
-    tz = new SimpleTimeZone(6500 * 3600, "Asia/Rangoon");
-    timezones.put("Asia/Rangoon", tz);
-    timezones.put("Indian/Cocos", tz);
-    tz = new SimpleTimeZone(7000 * 3600, "VST");
-    timezones.put("VST", tz);
-    timezones.put("Antarctica/Davis", tz);
-    timezones.put("Asia/Bangkok", tz);
-    timezones.put("Asia/Hovd", tz);
-    timezones.put("Asia/Jakarta", tz);
-    timezones.put("Asia/Phnom_Penh", tz);
-    timezones.put("Asia/Saigon", tz);
-    timezones.put("Asia/Vientiane", tz);
-    timezones.put("Indian/Christmas", tz);
-    tz = new SimpleTimeZone
-      (7000 * 3600, "Asia/Krasnoyarsk",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Krasnoyarsk", tz);
-    tz = new SimpleTimeZone(8000 * 3600, "CTT");
-    timezones.put("CTT", tz);
-    timezones.put("Antarctica/Casey", tz);
-    timezones.put("Asia/Brunei", tz);
-    timezones.put("Asia/Chungking", tz);
-    timezones.put("Asia/Harbin", tz);
-    timezones.put("Asia/Hong_Kong", tz);
-    timezones.put("Asia/Kashgar", tz);
-    timezones.put("Asia/Kuala_Lumpur", tz);
-    timezones.put("Asia/Kuching", tz);
-    timezones.put("Asia/Macao", tz);
-    timezones.put("Asia/Manila", tz);
-    timezones.put("Asia/Shanghai", tz);
-    timezones.put("Asia/Singapore", tz);
-    timezones.put("Asia/Taipei", tz);
-    timezones.put("Asia/Ujung_Pandang", tz);
-    timezones.put("Asia/Ulaanbaatar", tz);
-    timezones.put("Asia/Urumqi", tz);
-    timezones.put("Australia/Perth", tz);
-    tz = new SimpleTimeZone
-      (8000 * 3600, "Asia/Irkutsk",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Irkutsk", tz);
-    tz = new SimpleTimeZone(9000 * 3600, "JST");
-    timezones.put("JST", tz);
-    timezones.put("Asia/Dili", tz);
-    timezones.put("Asia/Jayapura", tz);
-    timezones.put("Asia/Pyongyang", tz);
-    timezones.put("Asia/Seoul", tz);
-    timezones.put("Asia/Tokyo", tz);
-    timezones.put("Pacific/Palau", tz);
-    tz = new SimpleTimeZone
-      (9000 * 3600, "Asia/Yakutsk",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Yakutsk", tz);
-    tz = new SimpleTimeZone
-      (9500 * 3600, "Australia/Adelaide",
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Australia/Adelaide", tz);
-    timezones.put("Australia/Broken_Hill", tz);
-    tz = new SimpleTimeZone(9500 * 3600, "ACT");
-    timezones.put("ACT", tz);
-    timezones.put("Australia/Darwin", tz);
-    tz = new SimpleTimeZone(10000 * 3600, "Antarctica/DumontDUrville");
-    timezones.put("Antarctica/DumontDUrville", tz);
-    timezones.put("Australia/Brisbane", tz);
-    timezones.put("Australia/Lindeman", tz);
-    timezones.put("Pacific/Guam", tz);
-    timezones.put("Pacific/Port_Moresby", tz);
-    timezones.put("Pacific/Saipan", tz);
-    timezones.put("Pacific/Truk", tz);
-    timezones.put("Pacific/Yap", tz);
-    tz = new SimpleTimeZone
-      (10000 * 3600, "Asia/Vladivostok",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Vladivostok", tz);
-    tz = new SimpleTimeZone
-      (10000 * 3600, "Australia/Hobart",
-       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Australia/Hobart", tz);
-    tz = new SimpleTimeZone
-      (10000 * 3600, "AET",
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("AET", tz);
-    timezones.put("Australia/Melbourne", tz);
-    timezones.put("Australia/Sydney", tz);
-    tz = new SimpleTimeZone
-      (10500 * 3600, "Australia/Lord_Howe",
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600, 500 * 3600);
-    timezones.put("Australia/Lord_Howe", tz);
-    tz = new SimpleTimeZone
-      (11000 * 3600, "Asia/Magadan",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Magadan", tz);
-    tz = new SimpleTimeZone(11000 * 3600, "SST");
-    timezones.put("SST", tz);
-    timezones.put("Pacific/Efate", tz);
-    timezones.put("Pacific/Guadalcanal", tz);
-    timezones.put("Pacific/Kosrae", tz);
-    timezones.put("Pacific/Noumea", tz);
-    timezones.put("Pacific/Ponape", tz);
-    tz = new SimpleTimeZone(11500 * 3600, "Pacific/Norfolk");
-    timezones.put("Pacific/Norfolk", tz);
-    tz = new SimpleTimeZone
-      (12000 * 3600, "NST",
-       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.MARCH, 3, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("NST", tz);
-    timezones.put("Antarctica/McMurdo", tz);
-    timezones.put("Antarctica/South_Pole", tz);
-    timezones.put("Pacific/Auckland", tz);
-    tz = new SimpleTimeZone
-      (12000 * 3600, "Asia/Anadyr",
-       Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
-       Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
-    timezones.put("Asia/Anadyr", tz);
-    timezones.put("Asia/Kamchatka", tz);
-    tz = new SimpleTimeZone(12000 * 3600, "Pacific/Fiji");
-    timezones.put("Pacific/Fiji", tz);
-    timezones.put("Pacific/Funafuti", tz);
-    timezones.put("Pacific/Kwajalein", tz);
-    timezones.put("Pacific/Majuro", tz);
-    timezones.put("Pacific/Nauru", tz);
-    timezones.put("Pacific/Tarawa", tz);
-    timezones.put("Pacific/Wake", tz);
-    timezones.put("Pacific/Wallis", tz);
-    tz = new SimpleTimeZone
-      (12750 * 3600, "Pacific/Chatham",
-       Calendar.OCTOBER, 1, Calendar.SUNDAY, 2750 * 3600,
-       Calendar.MARCH, 3, Calendar.SUNDAY, 2750 * 3600);
-    timezones.put("Pacific/Chatham", tz);
-    tz = new SimpleTimeZone(13000 * 3600, "Pacific/Enderbury");
-    timezones.put("Pacific/Enderbury", tz);
-    timezones.put("Pacific/Tongatapu", tz);
-    tz = new SimpleTimeZone(14000 * 3600, "Pacific/Kiritimati");
-    timezones.put("Pacific/Kiritimati", tz);
+  /**
+   * Cached copy of getAvailableIDs().
+   */
+  private static String[] availableIDs = null;
+
+  /**
+   * JDK 1.1.x compatibility aliases.
+   */
+  private static Hashtable aliases0;
+
+  /**
+   * Hashtable for timezones by ID.
+   */
+  private static Hashtable timezones0;
+  /* initialize this static field lazily to overhead if
+   * it is not needed: 
+   */
+  private static Hashtable timezones() {
+    if (timezones0==null) 
+      {
+	Hashtable timezones = new Hashtable();
+	timezones0 = timezones;
+
+	zoneinfo_dir = System.getProperty("gnu.java.util.zoneinfo.dir");
+	if (zoneinfo_dir != null && !new File(zoneinfo_dir).isDirectory())
+	  zoneinfo_dir = null;
+
+	if (zoneinfo_dir != null)
+	  {
+	    aliases0 = new Hashtable();
+
+	    // These deprecated aliases for JDK 1.1.x compatibility
+	    // should take precedence over data files read from
+	    // /usr/share/zoneinfo.
+	    aliases0.put("ACT", "Australia/Darwin");
+	    aliases0.put("AET", "Australia/Sydney");
+	    aliases0.put("AGT", "America/Argentina/Buenos_Aires");
+	    aliases0.put("ART", "Africa/Cairo");
+	    aliases0.put("AST", "America/Juneau");
+	    aliases0.put("BST", "Asia/Colombo");
+	    aliases0.put("CAT", "Africa/Gaborone");
+	    aliases0.put("CNT", "America/St_Johns");
+	    aliases0.put("CST", "CST6CDT");
+	    aliases0.put("CTT", "Asia/Brunei");
+	    aliases0.put("EAT", "Indian/Comoro");
+	    aliases0.put("ECT", "CET");
+	    aliases0.put("EST", "EST5EDT");
+	    aliases0.put("EST5", "EST5EDT");
+	    aliases0.put("IET", "EST5EDT");
+	    aliases0.put("IST", "Asia/Calcutta");
+	    aliases0.put("JST", "Asia/Seoul");
+	    aliases0.put("MIT", "Pacific/Niue");
+	    aliases0.put("MST", "MST7MDT");
+	    aliases0.put("MST7", "MST7MDT");
+	    aliases0.put("NET", "Indian/Mauritius");
+	    aliases0.put("NST", "Pacific/Auckland");
+	    aliases0.put("PLT", "Indian/Kerguelen");
+	    aliases0.put("PNT", "MST7MDT");
+	    aliases0.put("PRT", "America/Anguilla");
+	    aliases0.put("PST", "PST8PDT");
+	    aliases0.put("SST", "Pacific/Ponape");
+	    aliases0.put("VST", "Asia/Bangkok");
+	    return timezones;
+	  }
+
+	TimeZone tz;
+	// Automatically generated by scripts/timezones.pl
+	// XXX - Should we read this data from a file?
+	tz = new SimpleTimeZone(-11000 * 3600, "MIT");
+	timezones0.put("MIT", tz);
+	timezones0.put("Pacific/Apia", tz);
+	timezones0.put("Pacific/Midway", tz);
+	timezones0.put("Pacific/Niue", tz);
+	timezones0.put("Pacific/Pago_Pago", tz);
+	tz = new SimpleTimeZone
+	  (-10000 * 3600, "America/Adak",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Adak", tz);
+	tz = new SimpleTimeZone(-10000 * 3600, "HST");
+	timezones0.put("HST", tz);
+	timezones0.put("Pacific/Fakaofo", tz);
+	timezones0.put("Pacific/Honolulu", tz);
+	timezones0.put("Pacific/Johnston", tz);
+	timezones0.put("Pacific/Rarotonga", tz);
+	timezones0.put("Pacific/Tahiti", tz);
+	tz = new SimpleTimeZone(-9500 * 3600, "Pacific/Marquesas");
+	timezones0.put("Pacific/Marquesas", tz);
+	tz = new SimpleTimeZone
+	  (-9000 * 3600, "AST",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("AST", tz);
+	timezones0.put("America/Anchorage", tz);
+	timezones0.put("America/Juneau", tz);
+	timezones0.put("America/Nome", tz);
+	timezones0.put("America/Yakutat", tz);
+	tz = new SimpleTimeZone(-9000 * 3600, "Pacific/Gambier");
+	timezones0.put("Pacific/Gambier", tz);
+	tz = new SimpleTimeZone
+	  (-8000 * 3600, "America/Tijuana",
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Tijuana", tz);
+	tz = new SimpleTimeZone
+	  (-8000 * 3600, "PST",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("PST", tz);
+	timezones0.put("PST8PDT", tz);
+	timezones0.put("America/Dawson", tz);
+	timezones0.put("America/Los_Angeles", tz);
+	timezones0.put("America/Vancouver", tz);
+	timezones0.put("America/Whitehorse", tz);
+	timezones0.put("US/Pacific-New", tz);
+	tz = new SimpleTimeZone(-8000 * 3600, "Pacific/Pitcairn");
+	timezones0.put("Pacific/Pitcairn", tz);
+	tz = new SimpleTimeZone
+	  (-7000 * 3600, "America/Chihuahua",
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Chihuahua", tz);
+	timezones0.put("America/Mazatlan", tz);
+	tz = new SimpleTimeZone(-7000 * 3600, "MST7");
+	timezones0.put("MST7", tz);
+	timezones0.put("PNT", tz);
+	timezones0.put("America/Dawson_Creek", tz);
+	timezones0.put("America/Hermosillo", tz);
+	timezones0.put("America/Phoenix", tz);
+	tz = new SimpleTimeZone
+	  (-7000 * 3600, "MST",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("MST", tz);
+	timezones0.put("MST7MDT", tz);
+	timezones0.put("America/Boise", tz);
+	timezones0.put("America/Cambridge_Bay", tz);
+	timezones0.put("America/Denver", tz);
+	timezones0.put("America/Edmonton", tz);
+	timezones0.put("America/Inuvik", tz);
+	timezones0.put("America/Shiprock", tz);
+	timezones0.put("America/Yellowknife", tz);
+	tz = new SimpleTimeZone
+	  (-6000 * 3600, "America/Cancun",
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Cancun", tz);
+	timezones0.put("America/Merida", tz);
+	timezones0.put("America/Mexico_City", tz);
+	timezones0.put("America/Monterrey", tz);
+	tz = new SimpleTimeZone(-6000 * 3600, "America/Belize");
+	timezones0.put("America/Belize", tz);
+	timezones0.put("America/Costa_Rica", tz);
+	timezones0.put("America/El_Salvador", tz);
+	timezones0.put("America/Guatemala", tz);
+	timezones0.put("America/Managua", tz);
+	timezones0.put("America/Regina", tz);
+	timezones0.put("America/Swift_Current", tz);
+	timezones0.put("America/Tegucigalpa", tz);
+	timezones0.put("Pacific/Galapagos", tz);
+	tz = new SimpleTimeZone
+	  (-6000 * 3600, "CST",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("CST", tz);
+	timezones0.put("CST6CDT", tz);
+	timezones0.put("America/Chicago", tz);
+	timezones0.put("America/Indiana/Knox", tz);
+	timezones0.put("America/Indiana/Petersburg", tz);
+	timezones0.put("America/Indiana/Vincennes", tz);
+	timezones0.put("America/Menominee", tz);
+	timezones0.put("America/North_Dakota/Center", tz);
+	timezones0.put("America/North_Dakota/New_Salem", tz);
+	timezones0.put("America/Rainy_River", tz);
+	timezones0.put("America/Rankin_Inlet", tz);
+	timezones0.put("America/Winnipeg", tz);
+	tz = new SimpleTimeZone
+	  (-6000 * 3600, "Pacific/Easter",
+	   Calendar.OCTOBER, 2, Calendar.SATURDAY, 22000 * 3600,
+	   Calendar.MARCH, 2, Calendar.SATURDAY, 22000 * 3600);
+	timezones0.put("Pacific/Easter", tz);
+	tz = new SimpleTimeZone(-5000 * 3600, "EST5");
+	timezones0.put("EST5", tz);
+	timezones0.put("IET", tz);
+	timezones0.put("America/Atikokan", tz);
+	timezones0.put("America/Bogota", tz);
+	timezones0.put("America/Cayman", tz);
+	timezones0.put("America/Eirunepe", tz);
+	timezones0.put("America/Guayaquil", tz);
+	timezones0.put("America/Jamaica", tz);
+	timezones0.put("America/Lima", tz);
+	timezones0.put("America/Panama", tz);
+	timezones0.put("America/Rio_Branco", tz);
+	tz = new SimpleTimeZone
+	  (-5000 * 3600, "America/Havana",
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);
+	timezones0.put("America/Havana", tz);
+	tz = new SimpleTimeZone
+	  (-5000 * 3600, "America/Grand_Turk",
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("America/Grand_Turk", tz);
+	timezones0.put("America/Port-au-Prince", tz);
+	tz = new SimpleTimeZone
+	  (-5000 * 3600, "EST",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("EST", tz);
+	timezones0.put("EST5EDT", tz);
+	timezones0.put("America/Detroit", tz);
+	timezones0.put("America/Indiana/Indianapolis", tz);
+	timezones0.put("America/Indiana/Marengo", tz);
+	timezones0.put("America/Indiana/Vevay", tz);
+	timezones0.put("America/Iqaluit", tz);
+	timezones0.put("America/Kentucky/Louisville", tz);
+	timezones0.put("America/Kentucky/Monticello", tz);
+	timezones0.put("America/Montreal", tz);
+	timezones0.put("America/Nassau", tz);
+	timezones0.put("America/New_York", tz);
+	timezones0.put("America/Nipigon", tz);
+	timezones0.put("America/Pangnirtung", tz);
+	timezones0.put("America/Thunder_Bay", tz);
+	timezones0.put("America/Toronto", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "America/Asuncion",
+	   Calendar.OCTOBER, 3, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("America/Asuncion", tz);
+	tz = new SimpleTimeZone(-4000 * 3600, "PRT");
+	timezones0.put("PRT", tz);
+	timezones0.put("America/Anguilla", tz);
+	timezones0.put("America/Antigua", tz);
+	timezones0.put("America/Aruba", tz);
+	timezones0.put("America/Barbados", tz);
+	timezones0.put("America/Blanc-Sablon", tz);
+	timezones0.put("America/Boa_Vista", tz);
+	timezones0.put("America/Caracas", tz);
+	timezones0.put("America/Curacao", tz);
+	timezones0.put("America/Dominica", tz);
+	timezones0.put("America/Grenada", tz);
+	timezones0.put("America/Guadeloupe", tz);
+	timezones0.put("America/Guyana", tz);
+	timezones0.put("America/La_Paz", tz);
+	timezones0.put("America/Manaus", tz);
+	timezones0.put("America/Martinique", tz);
+	timezones0.put("America/Montserrat", tz);
+	timezones0.put("America/Port_of_Spain", tz);
+	timezones0.put("America/Porto_Velho", tz);
+	timezones0.put("America/Puerto_Rico", tz);
+	timezones0.put("America/Santo_Domingo", tz);
+	timezones0.put("America/St_Kitts", tz);
+	timezones0.put("America/St_Lucia", tz);
+	timezones0.put("America/St_Thomas", tz);
+	timezones0.put("America/St_Vincent", tz);
+	timezones0.put("America/Tortola", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "America/Campo_Grande",
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("America/Campo_Grande", tz);
+	timezones0.put("America/Cuiaba", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "America/Goose_Bay",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 60000,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 60000);
+	timezones0.put("America/Goose_Bay", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "America/Glace_Bay",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Glace_Bay", tz);
+	timezones0.put("America/Halifax", tz);
+	timezones0.put("America/Moncton", tz);
+	timezones0.put("America/Thule", tz);
+	timezones0.put("Atlantic/Bermuda", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "America/Santiago",
+	   Calendar.OCTOBER, 9, -Calendar.SUNDAY, 0 * 3600,
+	   Calendar.MARCH, 9, -Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("America/Santiago", tz);
+	timezones0.put("Antarctica/Palmer", tz);
+	tz = new SimpleTimeZone
+	  (-4000 * 3600, "Atlantic/Stanley",
+	   Calendar.SEPTEMBER, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.APRIL, 3, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("Atlantic/Stanley", tz);
+	tz = new SimpleTimeZone
+	  (-3500 * 3600, "CNT",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 60000,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 60000);
+	timezones0.put("CNT", tz);
+	timezones0.put("America/St_Johns", tz);
+	tz = new SimpleTimeZone
+	  (-3000 * 3600, "America/Godthab",
+	   Calendar.MARCH, 30, -Calendar.SATURDAY, 22000 * 3600,
+	   Calendar.OCTOBER, 30, -Calendar.SATURDAY, 23000 * 3600);
+	timezones0.put("America/Godthab", tz);
+	tz = new SimpleTimeZone
+	  (-3000 * 3600, "America/Miquelon",
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Miquelon", tz);
+	tz = new SimpleTimeZone
+	  (-3000 * 3600, "America/Montevideo",
+	   Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.MARCH, 2, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("America/Montevideo", tz);
+	tz = new SimpleTimeZone
+	  (-3000 * 3600, "America/Sao_Paulo",
+	   Calendar.NOVEMBER, 1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.FEBRUARY, -1, Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("America/Sao_Paulo", tz);
+	tz = new SimpleTimeZone(-3000 * 3600, "AGT");
+	timezones0.put("AGT", tz);
+	timezones0.put("America/Araguaina", tz);
+	timezones0.put("America/Argentina/Buenos_Aires", tz);
+	timezones0.put("America/Argentina/Catamarca", tz);
+	timezones0.put("America/Argentina/Cordoba", tz);
+	timezones0.put("America/Argentina/Jujuy", tz);
+	timezones0.put("America/Argentina/La_Rioja", tz);
+	timezones0.put("America/Argentina/Mendoza", tz);
+	timezones0.put("America/Argentina/Rio_Gallegos", tz);
+	timezones0.put("America/Argentina/San_Juan", tz);
+	timezones0.put("America/Argentina/Tucuman", tz);
+	timezones0.put("America/Argentina/Ushuaia", tz);
+	timezones0.put("America/Bahia", tz);
+	timezones0.put("America/Belem", tz);
+	timezones0.put("America/Cayenne", tz);
+	timezones0.put("America/Fortaleza", tz);
+	timezones0.put("America/Maceio", tz);
+	timezones0.put("America/Paramaribo", tz);
+	timezones0.put("America/Recife", tz);
+	timezones0.put("Antarctica/Rothera", tz);
+	tz = new SimpleTimeZone(-2000 * 3600, "America/Noronha");
+	timezones0.put("America/Noronha", tz);
+	timezones0.put("Atlantic/South_Georgia", tz);
+	tz = new SimpleTimeZone
+	  (-1000 * 3600, "America/Scoresbysund",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 1000 * 3600);
+	timezones0.put("America/Scoresbysund", tz);
+	timezones0.put("Atlantic/Azores", tz);
+	tz = new SimpleTimeZone(-1000 * 3600, "Atlantic/Cape_Verde");
+	timezones0.put("Atlantic/Cape_Verde", tz);
+	tz = new SimpleTimeZone(0 * 3600, "GMT");
+	timezones0.put("GMT", tz);
+	timezones0.put("UTC", tz);
+	timezones0.put("Africa/Abidjan", tz);
+	timezones0.put("Africa/Accra", tz);
+	timezones0.put("Africa/Bamako", tz);
+	timezones0.put("Africa/Banjul", tz);
+	timezones0.put("Africa/Bissau", tz);
+	timezones0.put("Africa/Casablanca", tz);
+	timezones0.put("Africa/Conakry", tz);
+	timezones0.put("Africa/Dakar", tz);
+	timezones0.put("Africa/El_Aaiun", tz);
+	timezones0.put("Africa/Freetown", tz);
+	timezones0.put("Africa/Lome", tz);
+	timezones0.put("Africa/Monrovia", tz);
+	timezones0.put("Africa/Nouakchott", tz);
+	timezones0.put("Africa/Ouagadougou", tz);
+	timezones0.put("Africa/Sao_Tome", tz);
+	timezones0.put("America/Danmarkshavn", tz);
+	timezones0.put("Atlantic/Reykjavik", tz);
+	timezones0.put("Atlantic/St_Helena", tz);
+	tz = new SimpleTimeZone
+	  (0 * 3600, "WET",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 1000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("WET", tz);
+	timezones0.put("Atlantic/Canary", tz);
+	timezones0.put("Atlantic/Faroe", tz);
+	timezones0.put("Atlantic/Madeira", tz);
+	timezones0.put("Europe/Dublin", tz);
+	timezones0.put("Europe/Guernsey", tz);
+	timezones0.put("Europe/Isle_of_Man", tz);
+	timezones0.put("Europe/Jersey", tz);
+	timezones0.put("Europe/Lisbon", tz);
+	timezones0.put("Europe/London", tz);
+	tz = new SimpleTimeZone(1000 * 3600, "Africa/Algiers");
+	timezones0.put("Africa/Algiers", tz);
+	timezones0.put("Africa/Bangui", tz);
+	timezones0.put("Africa/Brazzaville", tz);
+	timezones0.put("Africa/Douala", tz);
+	timezones0.put("Africa/Kinshasa", tz);
+	timezones0.put("Africa/Lagos", tz);
+	timezones0.put("Africa/Libreville", tz);
+	timezones0.put("Africa/Luanda", tz);
+	timezones0.put("Africa/Malabo", tz);
+	timezones0.put("Africa/Ndjamena", tz);
+	timezones0.put("Africa/Niamey", tz);
+	timezones0.put("Africa/Porto-Novo", tz);
+	tz = new SimpleTimeZone
+	  (1000 * 3600, "Africa/Windhoek",
+	   Calendar.SEPTEMBER, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.APRIL, 1, Calendar.SUNDAY, 2000 * 3600);
+	timezones0.put("Africa/Windhoek", tz);
+	tz = new SimpleTimeZone
+	  (1000 * 3600, "CET",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("CET", tz);
+	timezones0.put("ECT", tz);
+	timezones0.put("MET", tz);
+	timezones0.put("Africa/Ceuta", tz);
+	timezones0.put("Africa/Tunis", tz);
+	timezones0.put("Arctic/Longyearbyen", tz);
+	timezones0.put("Atlantic/Jan_Mayen", tz);
+	timezones0.put("Europe/Amsterdam", tz);
+	timezones0.put("Europe/Andorra", tz);
+	timezones0.put("Europe/Belgrade", tz);
+	timezones0.put("Europe/Berlin", tz);
+	timezones0.put("Europe/Bratislava", tz);
+	timezones0.put("Europe/Brussels", tz);
+	timezones0.put("Europe/Budapest", tz);
+	timezones0.put("Europe/Copenhagen", tz);
+	timezones0.put("Europe/Gibraltar", tz);
+	timezones0.put("Europe/Ljubljana", tz);
+	timezones0.put("Europe/Luxembourg", tz);
+	timezones0.put("Europe/Madrid", tz);
+	timezones0.put("Europe/Malta", tz);
+	timezones0.put("Europe/Monaco", tz);
+	timezones0.put("Europe/Oslo", tz);
+	timezones0.put("Europe/Paris", tz);
+	timezones0.put("Europe/Podgorica", tz);
+	timezones0.put("Europe/Prague", tz);
+	timezones0.put("Europe/Rome", tz);
+	timezones0.put("Europe/San_Marino", tz);
+	timezones0.put("Europe/Sarajevo", tz);
+	timezones0.put("Europe/Skopje", tz);
+	timezones0.put("Europe/Stockholm", tz);
+	timezones0.put("Europe/Tirane", tz);
+	timezones0.put("Europe/Vaduz", tz);
+	timezones0.put("Europe/Vatican", tz);
+	timezones0.put("Europe/Vienna", tz);
+	timezones0.put("Europe/Warsaw", tz);
+	timezones0.put("Europe/Zagreb", tz);
+	timezones0.put("Europe/Zurich", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "ART",
+	   Calendar.APRIL, -1, Calendar.FRIDAY, 0 * 3600,
+	   Calendar.SEPTEMBER, -1, Calendar.THURSDAY, 24000 * 3600);
+	timezones0.put("ART", tz);
+	timezones0.put("Africa/Cairo", tz);
+	tz = new SimpleTimeZone(2000 * 3600, "CAT");
+	timezones0.put("CAT", tz);
+	timezones0.put("Africa/Blantyre", tz);
+	timezones0.put("Africa/Bujumbura", tz);
+	timezones0.put("Africa/Gaborone", tz);
+	timezones0.put("Africa/Harare", tz);
+	timezones0.put("Africa/Johannesburg", tz);
+	timezones0.put("Africa/Kigali", tz);
+	timezones0.put("Africa/Lubumbashi", tz);
+	timezones0.put("Africa/Lusaka", tz);
+	timezones0.put("Africa/Maputo", tz);
+	timezones0.put("Africa/Maseru", tz);
+	timezones0.put("Africa/Mbabane", tz);
+	timezones0.put("Africa/Tripoli", tz);
+	timezones0.put("Asia/Jerusalem", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "Asia/Amman",
+	   Calendar.MARCH, -1, Calendar.THURSDAY, 0 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.FRIDAY, 1000 * 3600);
+	timezones0.put("Asia/Amman", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "Asia/Beirut",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 0 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 0 * 3600);
+	timezones0.put("Asia/Beirut", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "Asia/Damascus",
+	   Calendar.APRIL, 1, 0, 0 * 3600,
+	   Calendar.OCTOBER, 1, 0, 0 * 3600);
+	timezones0.put("Asia/Damascus", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "Asia/Gaza",
+	   Calendar.APRIL, 1, 0, 0 * 3600,
+	   Calendar.OCTOBER, 3, Calendar.FRIDAY, 0 * 3600);
+	timezones0.put("Asia/Gaza", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "EET",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 4000 * 3600);
+	timezones0.put("EET", tz);
+	timezones0.put("Asia/Istanbul", tz);
+	timezones0.put("Asia/Nicosia", tz);
+	timezones0.put("Europe/Athens", tz);
+	timezones0.put("Europe/Bucharest", tz);
+	timezones0.put("Europe/Chisinau", tz);
+	timezones0.put("Europe/Helsinki", tz);
+	timezones0.put("Europe/Istanbul", tz);
+	timezones0.put("Europe/Kiev", tz);
+	timezones0.put("Europe/Mariehamn", tz);
+	timezones0.put("Europe/Nicosia", tz);
+	timezones0.put("Europe/Riga", tz);
+	timezones0.put("Europe/Simferopol", tz);
+	timezones0.put("Europe/Sofia", tz);
+	timezones0.put("Europe/Tallinn", tz);
+	timezones0.put("Europe/Uzhgorod", tz);
+	timezones0.put("Europe/Vilnius", tz);
+	timezones0.put("Europe/Zaporozhye", tz);
+	tz = new SimpleTimeZone
+	  (2000 * 3600, "Europe/Kaliningrad",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Europe/Kaliningrad", tz);
+	timezones0.put("Europe/Minsk", tz);
+	tz = new SimpleTimeZone
+	  (3000 * 3600, "Asia/Baghdad",
+	   Calendar.APRIL, 1, 0, 3000 * 3600,
+	   Calendar.OCTOBER, 1, 0, 4000 * 3600);
+	timezones0.put("Asia/Baghdad", tz);
+	tz = new SimpleTimeZone
+	  (3000 * 3600, "Europe/Moscow",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Europe/Moscow", tz);
+	timezones0.put("Europe/Volgograd", tz);
+	tz = new SimpleTimeZone(3000 * 3600, "EAT");
+	timezones0.put("EAT", tz);
+	timezones0.put("Africa/Addis_Ababa", tz);
+	timezones0.put("Africa/Asmara", tz);
+	timezones0.put("Africa/Dar_es_Salaam", tz);
+	timezones0.put("Africa/Djibouti", tz);
+	timezones0.put("Africa/Kampala", tz);
+	timezones0.put("Africa/Khartoum", tz);
+	timezones0.put("Africa/Mogadishu", tz);
+	timezones0.put("Africa/Nairobi", tz);
+	timezones0.put("Antarctica/Syowa", tz);
+	timezones0.put("Asia/Aden", tz);
+	timezones0.put("Asia/Bahrain", tz);
+	timezones0.put("Asia/Kuwait", tz);
+	timezones0.put("Asia/Qatar", tz);
+	timezones0.put("Asia/Riyadh", tz);
+	timezones0.put("Indian/Antananarivo", tz);
+	timezones0.put("Indian/Comoro", tz);
+	timezones0.put("Indian/Mayotte", tz);
+	tz = new SimpleTimeZone(3500 * 3600, "Asia/Tehran");
+	timezones0.put("Asia/Tehran", tz);
+	tz = new SimpleTimeZone
+	  (4000 * 3600, "Asia/Baku",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 4000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 5000 * 3600);
+	timezones0.put("Asia/Baku", tz);
+	tz = new SimpleTimeZone
+	  (4000 * 3600, "Asia/Yerevan",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Yerevan", tz);
+	timezones0.put("Europe/Samara", tz);
+	tz = new SimpleTimeZone(4000 * 3600, "NET");
+	timezones0.put("NET", tz);
+	timezones0.put("Asia/Dubai", tz);
+	timezones0.put("Asia/Muscat", tz);
+	timezones0.put("Asia/Tbilisi", tz);
+	timezones0.put("Indian/Mahe", tz);
+	timezones0.put("Indian/Mauritius", tz);
+	timezones0.put("Indian/Reunion", tz);
+	tz = new SimpleTimeZone(4500 * 3600, "Asia/Kabul");
+	timezones0.put("Asia/Kabul", tz);
+	tz = new SimpleTimeZone
+	  (5000 * 3600, "Asia/Yekaterinburg",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Yekaterinburg", tz);
+	tz = new SimpleTimeZone(5000 * 3600, "PLT");
+	timezones0.put("PLT", tz);
+	timezones0.put("Asia/Aqtau", tz);
+	timezones0.put("Asia/Aqtobe", tz);
+	timezones0.put("Asia/Ashgabat", tz);
+	timezones0.put("Asia/Dushanbe", tz);
+	timezones0.put("Asia/Karachi", tz);
+	timezones0.put("Asia/Oral", tz);
+	timezones0.put("Asia/Samarkand", tz);
+	timezones0.put("Asia/Tashkent", tz);
+	timezones0.put("Indian/Kerguelen", tz);
+	timezones0.put("Indian/Maldives", tz);
+	tz = new SimpleTimeZone(5500 * 3600, "BST");
+	timezones0.put("BST", tz);
+	timezones0.put("IST", tz);
+	timezones0.put("Asia/Calcutta", tz);
+	timezones0.put("Asia/Colombo", tz);
+	tz = new SimpleTimeZone(5750 * 3600, "Asia/Katmandu");
+	timezones0.put("Asia/Katmandu", tz);
+	tz = new SimpleTimeZone(6000 * 3600, "Antarctica/Mawson");
+	timezones0.put("Antarctica/Mawson", tz);
+	timezones0.put("Antarctica/Vostok", tz);
+	timezones0.put("Asia/Almaty", tz);
+	timezones0.put("Asia/Bishkek", tz);
+	timezones0.put("Asia/Dhaka", tz);
+	timezones0.put("Asia/Qyzylorda", tz);
+	timezones0.put("Asia/Thimphu", tz);
+	timezones0.put("Indian/Chagos", tz);
+	tz = new SimpleTimeZone
+	  (6000 * 3600, "Asia/Novosibirsk",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Novosibirsk", tz);
+	timezones0.put("Asia/Omsk", tz);
+	tz = new SimpleTimeZone(6500 * 3600, "Asia/Rangoon");
+	timezones0.put("Asia/Rangoon", tz);
+	timezones0.put("Indian/Cocos", tz);
+	tz = new SimpleTimeZone(7000 * 3600, "VST");
+	timezones0.put("VST", tz);
+	timezones0.put("Antarctica/Davis", tz);
+	timezones0.put("Asia/Bangkok", tz);
+	timezones0.put("Asia/Jakarta", tz);
+	timezones0.put("Asia/Phnom_Penh", tz);
+	timezones0.put("Asia/Pontianak", tz);
+	timezones0.put("Asia/Saigon", tz);
+	timezones0.put("Asia/Vientiane", tz);
+	timezones0.put("Indian/Christmas", tz);
+	tz = new SimpleTimeZone
+	  (7000 * 3600, "Asia/Hovd",
+	   Calendar.MARCH, -1, Calendar.SATURDAY, 2000 * 3600,
+	   Calendar.SEPTEMBER, -1, Calendar.SATURDAY, 2000 * 3600);
+	timezones0.put("Asia/Hovd", tz);
+	tz = new SimpleTimeZone
+	  (7000 * 3600, "Asia/Krasnoyarsk",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Krasnoyarsk", tz);
+	tz = new SimpleTimeZone(8000 * 3600, "CTT");
+	timezones0.put("CTT", tz);
+	timezones0.put("Antarctica/Casey", tz);
+	timezones0.put("Asia/Brunei", tz);
+	timezones0.put("Asia/Chongqing", tz);
+	timezones0.put("Asia/Harbin", tz);
+	timezones0.put("Asia/Hong_Kong", tz);
+	timezones0.put("Asia/Kashgar", tz);
+	timezones0.put("Asia/Kuala_Lumpur", tz);
+	timezones0.put("Asia/Kuching", tz);
+	timezones0.put("Asia/Macau", tz);
+	timezones0.put("Asia/Makassar", tz);
+	timezones0.put("Asia/Manila", tz);
+	timezones0.put("Asia/Shanghai", tz);
+	timezones0.put("Asia/Singapore", tz);
+	timezones0.put("Asia/Taipei", tz);
+	timezones0.put("Asia/Urumqi", tz);
+	timezones0.put("Australia/Perth", tz);
+	tz = new SimpleTimeZone
+	  (8000 * 3600, "Asia/Irkutsk",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Irkutsk", tz);
+	tz = new SimpleTimeZone
+	  (8000 * 3600, "Asia/Ulaanbaatar",
+	   Calendar.MARCH, -1, Calendar.SATURDAY, 2000 * 3600,
+	   Calendar.SEPTEMBER, -1, Calendar.SATURDAY, 2000 * 3600);
+	timezones0.put("Asia/Ulaanbaatar", tz);
+	tz = new SimpleTimeZone(8750 * 3600, "Australia/Eucla");
+	timezones0.put("Australia/Eucla", tz);
+	tz = new SimpleTimeZone
+	  (9000 * 3600, "Asia/Choibalsan",
+	   Calendar.MARCH, -1, Calendar.SATURDAY, 2000 * 3600,
+	   Calendar.SEPTEMBER, -1, Calendar.SATURDAY, 2000 * 3600);
+	timezones0.put("Asia/Choibalsan", tz);
+	tz = new SimpleTimeZone(9000 * 3600, "JST");
+	timezones0.put("JST", tz);
+	timezones0.put("Asia/Dili", tz);
+	timezones0.put("Asia/Jayapura", tz);
+	timezones0.put("Asia/Pyongyang", tz);
+	timezones0.put("Asia/Seoul", tz);
+	timezones0.put("Asia/Tokyo", tz);
+	timezones0.put("Pacific/Palau", tz);
+	tz = new SimpleTimeZone
+	  (9000 * 3600, "Asia/Yakutsk",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Yakutsk", tz);
+	tz = new SimpleTimeZone
+	  (9500 * 3600, "Australia/Adelaide",
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Australia/Adelaide", tz);
+	timezones0.put("Australia/Broken_Hill", tz);
+	tz = new SimpleTimeZone(9500 * 3600, "ACT");
+	timezones0.put("ACT", tz);
+	timezones0.put("Australia/Darwin", tz);
+	tz = new SimpleTimeZone(10000 * 3600, "Antarctica/DumontDUrville");
+	timezones0.put("Antarctica/DumontDUrville", tz);
+	timezones0.put("Australia/Brisbane", tz);
+	timezones0.put("Australia/Lindeman", tz);
+	timezones0.put("Pacific/Guam", tz);
+	timezones0.put("Pacific/Port_Moresby", tz);
+	timezones0.put("Pacific/Saipan", tz);
+	timezones0.put("Pacific/Truk", tz);
+	tz = new SimpleTimeZone
+	  (10000 * 3600, "Asia/Sakhalin",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Sakhalin", tz);
+	timezones0.put("Asia/Vladivostok", tz);
+	tz = new SimpleTimeZone
+	  (10000 * 3600, "Australia/Currie",
+	   Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Australia/Currie", tz);
+	timezones0.put("Australia/Hobart", tz);
+	tz = new SimpleTimeZone
+	  (10000 * 3600, "AET",
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("AET", tz);
+	timezones0.put("Australia/Melbourne", tz);
+	timezones0.put("Australia/Sydney", tz);
+	tz = new SimpleTimeZone
+	  (10500 * 3600, "Australia/Lord_Howe",
+	  Calendar.OCTOBER, -1, Calendar.SUNDAY, 2000 * 3600,
+	  Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600, 500 * 3600);
+	timezones0.put("Australia/Lord_Howe", tz);
+	tz = new SimpleTimeZone
+	  (11000 * 3600, "Asia/Magadan",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Magadan", tz);
+	tz = new SimpleTimeZone(11000 * 3600, "SST");
+	timezones0.put("SST", tz);
+	timezones0.put("Pacific/Efate", tz);
+	timezones0.put("Pacific/Guadalcanal", tz);
+	timezones0.put("Pacific/Kosrae", tz);
+	timezones0.put("Pacific/Noumea", tz);
+	timezones0.put("Pacific/Ponape", tz);
+	tz = new SimpleTimeZone(11500 * 3600, "Pacific/Norfolk");
+	timezones0.put("Pacific/Norfolk", tz);
+	tz = new SimpleTimeZone
+	  (12000 * 3600, "NST",
+	   Calendar.OCTOBER, 1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.MARCH, 3, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("NST", tz);
+	timezones0.put("Antarctica/McMurdo", tz);
+	timezones0.put("Antarctica/South_Pole", tz);
+	timezones0.put("Pacific/Auckland", tz);
+	tz = new SimpleTimeZone
+	  (12000 * 3600, "Asia/Anadyr",
+	   Calendar.MARCH, -1, Calendar.SUNDAY, 2000 * 3600,
+	   Calendar.OCTOBER, -1, Calendar.SUNDAY, 3000 * 3600);
+	timezones0.put("Asia/Anadyr", tz);
+	timezones0.put("Asia/Kamchatka", tz);
+	tz = new SimpleTimeZone(12000 * 3600, "Pacific/Fiji");
+	timezones0.put("Pacific/Fiji", tz);
+	timezones0.put("Pacific/Funafuti", tz);
+	timezones0.put("Pacific/Kwajalein", tz);
+	timezones0.put("Pacific/Majuro", tz);
+	timezones0.put("Pacific/Nauru", tz);
+	timezones0.put("Pacific/Tarawa", tz);
+	timezones0.put("Pacific/Wake", tz);
+	timezones0.put("Pacific/Wallis", tz);
+	tz = new SimpleTimeZone
+	  (12750 * 3600, "Pacific/Chatham",
+	   Calendar.OCTOBER, 1, Calendar.SUNDAY, 2750 * 3600,
+	   Calendar.MARCH, 3, Calendar.SUNDAY, 3750 * 3600);
+	timezones0.put("Pacific/Chatham", tz);
+	tz = new SimpleTimeZone(13000 * 3600, "Pacific/Enderbury");
+	timezones0.put("Pacific/Enderbury", tz);
+	timezones0.put("Pacific/Tongatapu", tz);
+	tz = new SimpleTimeZone(14000 * 3600, "Pacific/Kiritimati");
+	timezones0.put("Pacific/Kiritimati", tz);
+      }
+    return timezones0;
   }
 
+  /**
+   * Maps a time zone name (with optional GMT offset and daylight time
+   * zone name) to one of the known time zones.  This method called
+   * with the result of <code>System.getProperty("user.timezone")</code>
+   * or <code>getDefaultTimeZoneId()</code>.  Note that giving one of
+   * the standard tz data names from ftp://elsie.nci.nih.gov/pub/ is
+   * preferred.  
+   * The time zone name can be given as follows:
+   * <code>(standard zone name)[(GMT offset)[(DST zone name)[DST offset]]]
+   * </code>
+   * <p>
+   * If only a (standard zone name) is given (no numbers in the
+   * String) then it gets mapped directly to the TimeZone with that
+   * name, if that fails null is returned.
+   * <p>
+   * Alternately, a POSIX-style TZ string can be given, defining the time zone:
+   * <code>std offset dst offset,date/time,date/time</code>
+   * See the glibc manual, or the man page for <code>tzset</code> for details
+   * of this format.
+   * <p>
+   * A GMT offset is the offset to add to the local time to get GMT.
+   * If a (GMT offset) is included (either in seconds or hours) then
+   * an attempt is made to find a TimeZone name matching both the name
+   * and the offset (that doesn't observe daylight time, if the
+   * timezone observes daylight time then you must include a daylight
+   * time zone name after the offset), if that fails then a TimeZone
+   * with the given GMT offset is returned (whether or not the
+   * TimeZone observes daylight time is ignored), if that also fails
+   * the GMT TimeZone is returned.
+   * <p>
+   * If the String ends with (GMT offset)(daylight time zone name)
+   * then an attempt is made to find a TimeZone with the given name and
+   * GMT offset that also observes (the daylight time zone name is not
+   * currently used in any other way), if that fails a TimeZone with
+   * the given GMT offset that observes daylight time is returned, if
+   * that also fails the GMT TimeZone is returned.
+   * <p>
+   * Examples: In Chicago, the time zone id could be "CST6CDT", but
+   * the preferred name would be "America/Chicago".  In Indianapolis
+   * (which does not have Daylight Savings Time) the string could be
+   * "EST5", but the preferred name would be "America/Indianapolis".
+   * The standard time zone name for The Netherlands is "Europe/Amsterdam",
+   * but can also be given as "CET-1CEST".
+   */
+  private static TimeZone getDefaultTimeZone(String sysTimeZoneId)
+  {
+    String stdName = null;
+    int stdOffs;
+    int dstOffs;
+    try
+      {
+	int idLength = sysTimeZoneId.length();
+
+	int index = 0;
+	int prevIndex;
+	char c;
+
+	// get std
+	do
+	  c = sysTimeZoneId.charAt(index);
+	while (c != '+' && c != '-' && c != ',' && c != ':'
+	       && ! Character.isDigit(c) && c != '\0' && ++index < idLength);
+
+	if (index >= idLength)
+	  return getTimeZoneInternal(sysTimeZoneId);
+
+	stdName = sysTimeZoneId.substring(0, index);
+	prevIndex = index;
+
+	// get the std offset
+	do
+	  c = sysTimeZoneId.charAt(index++);
+	while ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))
+	       && index < idLength);
+	if (index < idLength)
+	  index--;
+
+	{ // convert the dst string to a millis number
+	    String offset = sysTimeZoneId.substring(prevIndex, index);
+	    prevIndex = index;
+
+	    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')
+	      stdOffs = parseTime(offset.substring(1));
+	    else
+	      stdOffs = parseTime(offset);
+
+	    if (offset.charAt(0) == '-')
+	      stdOffs = -stdOffs;
 
-  /* Look up default timezone */
-  static
+	    // TZ timezone offsets are positive when WEST of the meridian.
+	    stdOffs = -stdOffs;
+	}
+
+	// Done yet? (Format: std offset)
+	if (index >= idLength)
+	  {
+	    // Do we have an existing timezone with that name and offset?
+	    TimeZone tz = getTimeZoneInternal(stdName);
+	    if (tz != null)
+	      if (tz.getRawOffset() == stdOffs)
+		return tz;
+
+	    // Custom then.
+	    return new SimpleTimeZone(stdOffs, stdName);
+	  }
+
+	// get dst
+	do
+	  c = sysTimeZoneId.charAt(index);
+	while (c != '+' && c != '-' && c != ',' && c != ':'
+	       && ! Character.isDigit(c) && c != '\0' && ++index < idLength);
+
+	// Done yet? (Format: std offset dst)
+	if (index >= idLength)
+	  {
+	    // Do we have an existing timezone with that name and offset
+	    // which has DST?
+	    TimeZone tz = getTimeZoneInternal(stdName);
+	    if (tz != null)
+	      if (tz.getRawOffset() == stdOffs && tz.useDaylightTime())
+		return tz;
+
+	    // Custom then.
+	    return new SimpleTimeZone(stdOffs, stdName);
+	  }
+
+	// get the dst offset
+	prevIndex = index;
+	do
+	  c = sysTimeZoneId.charAt(index++);
+	while ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))
+	       && index < idLength);
+	if (index < idLength)
+	  index--;
+
+	if (index == prevIndex && (c == ',' || c == ';'))
+	  {
+	    // Missing dst offset defaults to one hour ahead of standard
+	    // time.
+	    dstOffs = stdOffs + 60 * 60 * 1000;
+	  }
+	else
+	  { // convert the dst string to a millis number
+	    String offset = sysTimeZoneId.substring(prevIndex, index);
+	    prevIndex = index;
+
+	    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')
+	      dstOffs = parseTime(offset.substring(1));
+	    else
+	      dstOffs = parseTime(offset);
+
+	    if (offset.charAt(0) == '-')
+	      dstOffs = -dstOffs;
+
+	    // TZ timezone offsets are positive when WEST of the meridian.
+	    dstOffs = -dstOffs;
+	  }
+
+	// Done yet? (Format: std offset dst offset)
+	// FIXME: We don't support DST without a rule given. Should we?
+	if (index >= idLength)
+	  {
+	    // Time Zone existing with same name, dst and offsets?
+	    TimeZone tz = getTimeZoneInternal(stdName);
+	    if (tz != null)
+	      if (tz.getRawOffset() == stdOffs && tz.useDaylightTime())
+		{
+		  if ((tz instanceof SimpleTimeZone)
+		      && ((SimpleTimeZone) tz).getDSTSavings()
+			 == (dstOffs - stdOffs))
+		    return tz;
+		  if ((tz instanceof ZoneInfo)
+		      && ((ZoneInfo) tz).getDSTSavings()
+			 == (dstOffs - stdOffs))
+		    return tz;
+		}
+
+	    return new SimpleTimeZone(stdOffs, stdName);
+	  }
+
+	// get the DST rule
+	if (sysTimeZoneId.charAt(index) == ','
+	    || sysTimeZoneId.charAt(index) == ';')
+	  {
+	    index++;
+	    int offs = index;
+	    while (sysTimeZoneId.charAt(index) != ','
+	           && sysTimeZoneId.charAt(index) != ';')
+	      index++;
+	    String startTime = sysTimeZoneId.substring(offs, index);
+	    index++;
+	    String endTime = sysTimeZoneId.substring(index);
+
+	    index = startTime.indexOf('/');
+	    int startMillis;
+	    int endMillis;
+	    String startDate;
+	    String endDate;
+	    if (index != -1)
+	      {
+		startDate = startTime.substring(0, index);
+		startMillis = parseTime(startTime.substring(index + 1));
+	      }
+	    else
+	      {
+		startDate = startTime;
+		// if time isn't given, default to 2:00:00 AM.
+		startMillis = 2 * 60 * 60 * 1000;
+	      }
+	    index = endTime.indexOf('/');
+	    if (index != -1)
+	      {
+		endDate = endTime.substring(0, index);
+		endMillis = parseTime(endTime.substring(index + 1));
+	      }
+	    else
+	      {
+		endDate = endTime;
+		// if time isn't given, default to 2:00:00 AM.
+		endMillis = 2 * 60 * 60 * 1000;
+	      }
+
+	    int[] start = getDateParams(startDate);
+	    int[] end = getDateParams(endDate);
+	    return new SimpleTimeZone(stdOffs, stdName, start[0], start[1],
+	                              start[2], startMillis, end[0], end[1],
+	                              end[2], endMillis, (dstOffs - stdOffs));
+	  }
+      }
+
+    // FIXME: Produce a warning here?
+    catch (IndexOutOfBoundsException _)
+      {
+      }
+    catch (NumberFormatException _)
+      {
+      }
+
+    return null;
+  }
+
+  /**
+   * Parses and returns the params for a POSIX TZ date field,
+   * in the format int[]{ month, day, dayOfWeek }, following the
+   * SimpleTimeZone constructor rules.
+   */
+  private static int[] getDateParams(String date)
   {
-    // System.loadLibrary("javautil");
+    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
+    int month;
 
-    String tzid = System.getProperty("user.timezone");
+    if (date.charAt(0) == 'M' || date.charAt(0) == 'm')
+      {
+	int day;
+
+	// Month, week of month, day of week
+
+	// "Mm.w.d".  d is between 0 (Sunday) and 6.  Week w is
+	// between 1 and 5; Week 1 is the first week in which day d
+	// occurs and Week 5 specifies the last d day in the month.
+	// Month m is between 1 and 12.
+
+	month = Integer.parseInt(date.substring(1, date.indexOf('.')));
+	int week = Integer.parseInt(date.substring(date.indexOf('.') + 1,
+	                                           date.lastIndexOf('.')));
+	int dayOfWeek = Integer.parseInt(date.substring(date.lastIndexOf('.')
+	                                                + 1));
+	dayOfWeek++; // Java day of week is one-based, Sunday is first day.
+
+ 	if (week == 5)
+ 	  day = -1; // last day of month is -1 in java, 5 in TZ
+ 	else
+	  {
+	    // First day of week starting on or after.  For example,
+	    // to specify the second Sunday of April, set month to
+	    // APRIL, day-of-month to 8, and day-of-week to -SUNDAY.
+	    day = (week - 1) * 7 + 1;
+	    dayOfWeek = -dayOfWeek;
+	  }
+
+	month--; // Java month is zero-based.
+	return new int[] { month, day, dayOfWeek };
+      }
+
+    // julian day, either zero-based 0<=n<=365 (incl feb 29)
+    // or one-based 1<=n<=365 (no feb 29)
+    int julianDay; // Julian day,
+
+    if (date.charAt(0) != 'J' || date.charAt(0) != 'j')
+      {
+	julianDay = Integer.parseInt(date.substring(1));
+	julianDay++; // make 1-based
+	// Adjust day count to include feb 29.
+	dayCount = new int[]
+	           {
+	             0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335
+	           };
+      }
+    else
+      // 1-based julian day
+      julianDay = Integer.parseInt(date);
+
+    int i = 11;
+    while (i > 0)
+      if (dayCount[i] < julianDay)
+	break;
+      else
+	i--;
+    julianDay -= dayCount[i];
+    month = i;
+    return new int[] { month, julianDay, 0 };
+  }
 
-    if (tzid == null)
-      tzid = "GMT";
+  /**
+   * Parses a time field hh[:mm[:ss]], returning the result
+   * in milliseconds. No leading sign.
+   */
+  private static int parseTime(String time)
+  {
+    int millis = 0;
+    int i = 0;
 
-    defaultZone = getTimeZone(tzid);
+    while (i < time.length())
+      if (time.charAt(i) == ':')
+	break;
+      else
+	i++;
+    millis = 60 * 60 * 1000 * Integer.parseInt(time.substring(0, i));
+    if (i >= time.length())
+      return millis;
+
+    int iprev = ++i;
+    while (i < time.length())
+      if (time.charAt(i) == ':')
+	break;
+      else
+	i++;
+    millis += 60 * 1000 * Integer.parseInt(time.substring(iprev, i));
+    if (i >= time.length())
+      return millis;
+
+    millis += 1000 * Integer.parseInt(time.substring(++i));
+    return millis;
   }
 
+  /* This method returns us a time zone id string which is in the
+     form <standard zone name><GMT offset><daylight time zone name>.
+     The GMT offset is in seconds, except where it is evenly divisible
+     by 3600, then it is in hours.  If the zone does not observe
+     daylight time, then the daylight zone name is omitted.  Examples:
+     in Chicago, the timezone would be CST6CDT.  In Indianapolis
+     (which does not have Daylight Savings Time) the string would
+     be EST5
+   */
+  private static native String getDefaultTimeZoneId();
+  private static native String getTZEnvVar();
+
   /**
    * Gets the time zone offset, for current date, modified in case of 
    * daylight savings.  This is the offset to add to UTC to get the local
@@ -916,6 +1449,8 @@ public abstract class TimeZone implement
 	// TimeZone knows nothing about daylight saving offsets.
 	offset += ((SimpleTimeZone) this).getDSTSavings();
       }
+    if (dst && this instanceof ZoneInfo)
+      offset += ((ZoneInfo) this).getDSTSavings();
 
     StringBuffer sb = new StringBuffer(9);
     sb.append("GMT");
@@ -949,30 +1484,67 @@ public abstract class TimeZone implement
    * @return The time zone for the identifier or GMT, if no such time
    * zone exists.
    */
-  // FIXME: XXX: JCL indicates this and other methods are synchronized.
-  public static TimeZone getTimeZone(String ID)
+  private static TimeZone getTimeZoneInternal(String ID)
   {
     // First check timezones hash
-    TimeZone tz = (TimeZone) timezones.get(ID);
-    if (tz != null)
+    TimeZone tz = null;
+    TimeZone tznew = null;
+    for (int pass = 0; pass < 2; pass++)
       {
-	if (tz.getID().equals(ID))
-	  return tz;
+	synchronized (TimeZone.class)
+	  {
+	    tz = (TimeZone) timezones().get(ID);
+	    if (tz != null)
+	      {
+		if (!tz.getID().equals(ID))
+		  {
+		    // We always return a timezone with the requested ID.
+		    // This is the same behaviour as with JDK1.2.
+		    tz = (TimeZone) tz.clone();
+		    tz.setID(ID);
+		    // We also save the alias, so that we return the same
+		    // object again if getTimeZone is called with the same
+		    // alias.
+		    timezones().put(ID, tz);
+		  }
+		return tz;
+	      }
+	    else if (tznew != null)
+	      {
+		timezones().put(ID, tznew);
+		return tznew;
+	      }
+	  }
+
+	if (pass == 1 || zoneinfo_dir == null)
+	  return null;
 
-	// We always return a timezone with the requested ID.
-	// This is the same behaviour as with JDK1.2.
-	tz = (TimeZone) tz.clone();
-	tz.setID(ID);
-	// We also save the alias, so that we return the same
-	// object again if getTimeZone is called with the same
-	// alias.
-	timezones.put(ID, tz);
-	return tz;
+	// aliases0 is never changing after first timezones(), so should
+	// be safe without synchronization.
+	String zonename = (String) aliases0.get(ID);
+	if (zonename == null)
+	  zonename = ID;
+
+	// Read the file outside of the critical section, it is expensive.
+	tznew = ZoneInfo.readTZFile (ID, zoneinfo_dir
+				     + File.separatorChar + zonename);
+	if (tznew == null)
+	  return null;
       }
 
-    // See if the ID is really a GMT offset form.
-    // Note that GMT is in the table so we know it is different.
-    if (ID.startsWith("GMT"))
+    return null;
+  }
+
+  /**
+   * Gets the TimeZone for the given ID.
+   * @param ID the time zone identifier.
+   * @return The time zone for the identifier or GMT, if no such time
+   * zone exists.
+   */
+  public static TimeZone getTimeZone(String ID)
+  {
+    // Check for custom IDs first
+    if (ID.startsWith("GMT") && ID.length() > 3)
       {
 	int pos = 3;
 	int offset_direction = 1;
@@ -1017,8 +1589,20 @@ public abstract class TimeZone implement
 		  }
 	      }
 
-	    return new SimpleTimeZone((hour * (60 * 60 * 1000) +
-				       minute * (60 * 1000))
+	    // Custom IDs have to be normalized
+	    StringBuffer sb = new StringBuffer(9);
+	    sb.append("GMT");
+
+	    sb.append(offset_direction >= 0 ? '+' : '-');
+	    sb.append((char) ('0' + hour / 10));
+	    sb.append((char) ('0' + hour % 10));
+	    sb.append(':');
+	    sb.append((char) ('0' + minute / 10));
+	    sb.append((char) ('0' + minute % 10));
+	    ID = sb.toString();
+
+	    return new SimpleTimeZone((hour * (60 * 60 * 1000)
+				       + minute * (60 * 1000))
 				      * offset_direction, ID);
 	  }
 	catch (NumberFormatException e)
@@ -1026,8 +1610,11 @@ public abstract class TimeZone implement
 	  }
       }
 
-    // Finally, return GMT per spec
-    return getTimeZone("GMT");
+    TimeZone tz = getTimeZoneInternal(ID);
+    if (tz != null)
+      return tz;
+
+    return new SimpleTimeZone(0, "GMT");
   }
 
   /**
@@ -1040,37 +1627,134 @@ public abstract class TimeZone implement
    */
   public static String[] getAvailableIDs(int rawOffset)
   {
+    synchronized (TimeZone.class)
+      {
+	Hashtable h = timezones();
+	int count = 0;
+	if (zoneinfo_dir == null)
+	  {
+	    Iterator iter = h.entrySet().iterator();
+	    while (iter.hasNext())
+	      {
+		// Don't iterate the values, since we want to count
+		// doubled values (aliases)
+		Map.Entry entry = (Map.Entry) iter.next();
+		if (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)
+		  count++;
+	      }
+
+	    String[] ids = new String[count];
+	    count = 0;
+	    iter = h.entrySet().iterator();
+	    while (iter.hasNext())
+	      {
+		Map.Entry entry = (Map.Entry) iter.next();
+		if (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)
+		  ids[count++] = (String) entry.getKey();
+	      }
+	    return ids;
+	  }
+      }
+
+    String[] s = getAvailableIDs();
     int count = 0;
-    Iterator iter = timezones.entrySet().iterator();
-    while (iter.hasNext())
+    for (int i = 0; i < s.length; i++)
       {
-	// Don't iterate the values, since we want to count 
-	// doubled values (aliases)
-	Map.Entry entry = (Map.Entry) iter.next();
-	if (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)
+	TimeZone t = getTimeZoneInternal(s[i]);
+	if (t == null || t.getRawOffset() != rawOffset)
+	  s[i] = null;
+	else
 	  count++;
       }
-
     String[] ids = new String[count];
     count = 0;
-    iter = timezones.entrySet().iterator();
-    while (iter.hasNext())
-      {
-	Map.Entry entry = (Map.Entry) iter.next();
-	if (((TimeZone) entry.getValue()).getRawOffset() == rawOffset)
-	  ids[count++] = (String) entry.getKey();
-      }
+    for (int i = 0; i < s.length; i++)
+    if (s[i] != null)
+      ids[count++] = s[i];
+
     return ids;
   }
 
+  private static int getAvailableIDs(File d, String prefix, ArrayList list)
+    {
+      String[] files = d.list();
+      int count = files.length;
+      boolean top = prefix.length() == 0;
+      list.add (files);
+      for (int i = 0; i < files.length; i++)
+	{
+	  if (top
+	      && (files[i].equals("posix")
+		  || files[i].equals("right")
+		  || files[i].endsWith(".tab")
+		  || aliases0.get(files[i]) != null))
+	    {
+	      files[i] = null;
+	      count--;
+	      continue;
+	    }
+
+	  File f = new File(d, files[i]);
+	  if (f.isDirectory())
+	    {
+	      count += getAvailableIDs(f, prefix + files[i]
+				       + File.separatorChar, list) - 1;
+	      files[i] = null;
+	    }
+	  else
+	    files[i] = prefix + files[i];
+	}
+      return count;
+    }
+
   /**
    * Gets all available IDs.
    * @return An array of all supported IDs.
    */
   public static String[] getAvailableIDs()
   {
-    return (String[])
-      timezones.keySet().toArray(new String[timezones.size()]);
+    synchronized (TimeZone.class)
+      {
+	Hashtable h = timezones();
+	if (zoneinfo_dir == null)
+	  return (String[]) h.keySet().toArray(new String[h.size()]);
+
+	if (availableIDs != null)
+	  {
+	    String[] ids = new String[availableIDs.length];
+	    for (int i = 0; i < availableIDs.length; i++)
+	      ids[i] = availableIDs[i];
+	    return ids;
+	  }
+
+	File d = new File(zoneinfo_dir);
+	ArrayList list = new ArrayList(30);
+	int count = getAvailableIDs(d, "", list) + aliases0.size();
+	availableIDs = new String[count];
+	String[] ids = new String[count];
+
+	count = 0;
+	for (int i = 0; i < list.size(); i++)
+	  {
+	    String[] s = (String[]) list.get(i);
+	    for (int j = 0; j < s.length; j++)
+	      if (s[j] != null)
+		{
+		  availableIDs[count] = s[j];
+		  ids[count++] = s[j];
+		}
+	  }
+
+	Iterator iter = aliases0.entrySet().iterator();
+	while (iter.hasNext())
+	  {
+	    Map.Entry entry = (Map.Entry) iter.next();
+	    availableIDs[count] = (String) entry.getKey();
+	    ids[count++] = (String) entry.getKey();
+	  }
+
+	return ids;
+      }
   }
 
   /**
@@ -1081,12 +1765,12 @@ public abstract class TimeZone implement
    */
   public static TimeZone getDefault()
   {
-    return defaultZone;
+    return defaultZone();
   }
 
   public static void setDefault(TimeZone zone)
   {
-    defaultZone = zone;
+    defaultZone0 = zone;
   }
 
   /**
@@ -1116,4 +1800,66 @@ public abstract class TimeZone implement
 	return null;
       }
   }
+
+  /**
+   * Tries to read the time zone name from a file.
+   * If the file cannot be read or an IOException occurs null is returned.
+   * <p>
+   * The /etc/sysconfig/clock file is not standard, but a lot of systems
+   * have it. The file is included by shell scripts and the timezone
+   * name is defined in ZONE variable.
+   * This routine should grok it with or without quotes:
+   * ZONE=America/New_York
+   * or
+   * ZONE="Europe/London"
+   */
+  private static String readSysconfigClockFile(String file)
+  {
+    BufferedReader br = null;
+    try
+      {
+	FileInputStream fis = new FileInputStream(file);
+	BufferedInputStream bis = new BufferedInputStream(fis);
+	br = new BufferedReader(new InputStreamReader(bis));
+
+	for (String line = br.readLine(); line != null; line = br.readLine())
+	  {
+	    line = line.trim();
+	    if (line.length() < 8 || !line.startsWith("ZONE="))
+	      continue;
+	    int posstart = 6;
+	    int posend;
+	    if (line.charAt(5) == '"')
+	      posend = line.indexOf('"', 6);
+	    else if (line.charAt(5) == '\'')
+	      posend = line.indexOf('\'', 6);
+	    else
+	      {
+		posstart = 5;
+		posend = line.length();
+	      }
+	    if (posend < 0)
+	      return null;
+	    return line.substring(posstart, posend);
+	  }
+	return null;
+      }
+    catch (IOException ioe)
+      {
+	// Parse error, not a proper tzfile.
+	return null;
+      }
+    finally
+      {
+	try
+	  {
+	    if (br != null)
+	      br.close();
+	  }
+	catch (IOException ioe)
+	  {
+	    // Error while close, nothing we can do.
+	  }
+      }
+  }
 }
--- libjava/java/lang/System.java.jj	2007-02-23 21:27:25.000000000 +0100
+++ libjava/java/lang/System.java	2007-02-24 21:47:38.000000000 +0100
@@ -42,83 +42,6 @@ public final class System
 
   public static native long currentTimeMillis ();
 
-  // FIXME: When merging with Classpath, remember to remove the call to
-  // getDefaultTimeZoneId from java.util.Timezone.
-  private static native String getSystemTimeZone ();
-
-  // Get the System Timezone as reported by the OS.  It should be in
-  // the form PST8PDT so we'll need to parse it and check that it's valid.
-  // The result is used to set the user.timezone property in init_properties.
-  // FIXME: Using the code from Classpath for generating the System
-  // Timezone IMO is suboptimal because it ignores whether the rules for
-  // DST match up.
-  private static String getDefaultTimeZoneId ()
-  {
-    String sysTimeZoneId = getSystemTimeZone ();
-
-    // Check if this is a valid timezone.  Make sure the IDs match
-    // since getTimeZone returns GMT if no match is found.
-    TimeZone tz = TimeZone.getTimeZone (sysTimeZoneId);
-    if (tz.getID ().equals (sysTimeZoneId))
-      return sysTimeZoneId;
-
-    // Check if the base part of sysTimeZoneId is a valid timezone that
-    // matches with daylight usage and rawOffset.  Make sure the IDs match
-    // since getTimeZone returns GMT if no match is found.
-    // First find start of GMT offset info and any Daylight zone name.
-    int startGMToffset = 0;
-    int sysTimeZoneIdLength = sysTimeZoneId.length();
-    for (int i = 0; i < sysTimeZoneIdLength && startGMToffset == 0; i++)
-      {
-        if (Character.isDigit (sysTimeZoneId.charAt (i)))
-	  startGMToffset = i;
-      }
-
-    int startDaylightZoneName = 0;
-    boolean usesDaylight = false;
-    for (int i = sysTimeZoneIdLength - 1;
-         i >= 0 && !Character.isDigit (sysTimeZoneId.charAt (i)); --i)
-      {
-        startDaylightZoneName = i;
-      }
-    if (startDaylightZoneName > 0)
-      usesDaylight = true;
-
-    int GMToffset = Integer.parseInt (startDaylightZoneName == 0 ?
-      sysTimeZoneId.substring (startGMToffset) :
-      sysTimeZoneId.substring (startGMToffset, startDaylightZoneName));
-
-    // Offset could be in hours or seconds.  Convert to millis.
-    if (GMToffset < 24)
-      GMToffset *= 60 * 60;
-    GMToffset *= -1000;
-
-    String tzBasename = sysTimeZoneId.substring (0, startGMToffset);
-    tz = TimeZone.getTimeZone (tzBasename);
-    if (tz.getID ().equals (tzBasename) && tz.getRawOffset () == GMToffset)
-      {
-        boolean tzUsesDaylight = tz.useDaylightTime ();
-        if (usesDaylight && tzUsesDaylight || !usesDaylight && !tzUsesDaylight)
-          return tzBasename;
-      }
-  
-    // If no match, see if a valid timezone has the same attributes as this
-    // and then use it instead.
-    String[] IDs = TimeZone.getAvailableIDs (GMToffset);
-    for (int i = 0; i < IDs.length; ++i)
-      {
-	// FIXME: The daylight savings rules may not match the rules
-	// for the desired zone.
-        boolean IDusesDaylight =
-	  TimeZone.getTimeZone (IDs[i]).useDaylightTime ();
-        if (usesDaylight && IDusesDaylight || !usesDaylight && !IDusesDaylight)
-	  return IDs[i];
-      }
-
-    // If all else fails, return null.
-    return null;
-  }
-
   public static void exit (int status)
   {
     Runtime.getRuntime().exit(status);
--- libjava/posix.cc.jj	2007-02-23 21:17:39.000000000 +0100
+++ libjava/posix.cc	2007-02-23 21:27:25.000000000 +0100
@@ -79,6 +79,10 @@ _Jv_platform_initProperties (java::util:
   if (! tmpdir)
     tmpdir = "/tmp";
   SET ("java.io.tmpdir", tmpdir);
+  const char *zoneinfodir = ::getenv("TZDATA");
+  if (! zoneinfodir)
+    zoneinfodir = "/usr/share/zoneinfo";
+  SET ("gnu.java.util.zoneinfo.dir", zoneinfodir);
 }
 
 static inline void
--- libjava/gnu/java/util/ZoneInfo.java.jj	2007-02-23 21:27:25.000000000 +0100
+++ libjava/gnu/java/util/ZoneInfo.java	2007-02-24 19:14:27.000000000 +0100
@@ -0,0 +1,1149 @@
+/* gnu.java.util.ZoneInfo
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+This file is part of GNU Classpath.
+
+GNU Classpath is free software; you can redistribute it and/or modify
+it under the terms of the GNU General Public License as published by
+the Free Software Foundation; either version 2, or (at your option)
+any later version.
+
+GNU Classpath is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with GNU Classpath; see the file COPYING.  If not, write to the
+Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
+02110-1301 USA.
+
+Linking this library statically or dynamically with other modules is
+making a combined work based on this library.  Thus, the terms and
+conditions of the GNU General Public License cover the whole
+combination.
+
+As a special exception, the copyright holders of this library give you
+permission to link this library with independent modules to produce an
+executable, regardless of the license terms of these independent
+modules, and to copy and distribute the resulting executable under
+terms of your choice, provided that you also meet, for each linked
+independent module, the terms and conditions of the license of that
+module.  An independent module is a module which is not derived from
+or based on this library.  If you modify this library, you may extend
+this exception to your version of the library, but you are not
+obligated to do so.  If you do not wish to do so, delete this
+exception statement from your version. */
+
+
+package gnu.java.util;
+
+import java.io.BufferedInputStream;
+import java.io.DataInputStream;
+import java.io.EOFException;
+import java.io.FileInputStream;
+import java.io.InputStream;
+import java.io.IOException;
+import java.util.Calendar;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.SimpleTimeZone;
+import java.util.TimeZone;
+
+/**
+ * This class represents more advanced variant of java.util.SimpleTimeZone.
+ * It can handle zic(8) compiled transition dates plus uses a SimpleTimeZone
+ * for years beyond last precomputed transition.  Before first precomputed
+ * transition it assumes no daylight saving was in effect.
+ * Timezones that never used daylight saving time should use just
+ * SimpleTimeZone instead of this class.
+ *
+ * This object is tightly bound to the Gregorian calendar.  It assumes
+ * a regular seven days week, and the month lengths are that of the
+ * Gregorian Calendar.
+ *
+ * @see Calendar
+ * @see GregorianCalendar
+ * @see SimpleTimeZone
+ * @author Jakub Jelinek
+ */
+public class ZoneInfo extends TimeZone
+{
+  private static final int SECS_SHIFT = 22;
+  private static final long OFFSET_MASK = (1 << 21) - 1;
+  private static final int OFFSET_SHIFT = 64 - 21;
+  private static final long IS_DST = 1 << 21;
+
+  /**
+   * The raw time zone offset in milliseconds to GMT, ignoring
+   * daylight savings.
+   * @serial
+   */
+  private int rawOffset;
+
+  /**
+   * Cached DST savings for the last transition rule.
+   */
+  private int dstSavings;
+
+  /**
+   * Cached flag whether last transition rule uses DST saving.
+   */
+  private boolean useDaylight;
+
+  /**
+   * Array of encoded transitions.
+   * Transition time in UTC seconds since epoch is in the most
+   * significant 64 - SECS_SHIFT bits, then one bit flag
+   * whether DST is active and the least significant bits
+   * containing offset relative to rawOffset.  Both the DST
+   * flag and relative offset apply to time before the transition
+   * and after or equal to previous transition if any.
+   * The array must be sorted.
+   */
+  private long[] transitions;
+
+  /**
+   * SimpleTimeZone rule which applies on or after the latest
+   * transition.  If the DST changes are not expresible as a
+   * SimpleTimeZone rule, then the rule should just contain
+   * the standard time and no DST time.
+   */
+  private SimpleTimeZone lastRule;
+
+  /**
+   * Cached GMT SimpleTimeZone object for internal use in
+   * getOffset method.
+   */
+  private static SimpleTimeZone gmtZone = null;
+
+  static final long serialVersionUID = -3740626706860383657L;
+
+  /**
+   * Create a <code>ZoneInfo</code> with the given time offset
+   * from GMT and with daylight savings.
+   *
+   * @param rawOffset The time offset from GMT in milliseconds.
+   * @param id  The identifier of this time zone.
+   * @param transitions  Array of transition times in UTC seconds since
+   * Epoch in topmost 42 bits, below that 1 boolean bit whether the time
+   * before that transition used daylight saving and in bottommost 21
+   * bits relative daylight saving offset against rawOffset in seconds
+   * that applies before this transition.
+   * @param endRule SimpleTimeZone class describing the daylight saving
+   * rules after the last transition.
+   */
+  public ZoneInfo(int rawOffset, String id, long[] transitions,
+		  SimpleTimeZone lastRule)
+  {
+    if (transitions == null || transitions.length < 1)
+      throw new IllegalArgumentException("transitions must not be null");
+    if (lastRule == null)
+      throw new IllegalArgumentException("lastRule must not be null");
+    this.rawOffset = rawOffset;
+    this.transitions = transitions;
+    this.lastRule = lastRule;
+    setID(id);
+    computeDSTSavings();
+  }
+
+  /**
+   * Gets the time zone offset, for current date, modified in case of
+   * daylight savings.  This is the offset to add to UTC to get the local
+   * time.
+   *
+   * The day must be a positive number and dayOfWeek must be a positive value
+   * from Calendar.  dayOfWeek is redundant, but must match the other values
+   * or an inaccurate result may be returned.
+   *
+   * @param era the era of the given date
+   * @param year the year of the given date
+   * @param month the month of the given date, 0 for January.
+   * @param day the day of month
+   * @param dayOfWeek the day of week; this must match the other fields.
+   * @param millis the millis in the day (in local standard time)
+   * @return the time zone offset in milliseconds.
+   * @throws IllegalArgumentException if arguments are incorrect.
+   */
+  public int getOffset(int era, int year, int month, int day, int dayOfWeek,
+		       int millis)
+  {
+    if (gmtZone == null)
+      gmtZone = new SimpleTimeZone(0, "GMT");
+
+    if (dayOfWeek < Calendar.SUNDAY || dayOfWeek > Calendar.SATURDAY)
+      throw new IllegalArgumentException("dayOfWeek out of range");
+    if (month < Calendar.JANUARY || month > Calendar.DECEMBER)
+      throw new IllegalArgumentException("month out of range:" + month);
+
+    if (era != GregorianCalendar.AD)
+      return (int) (((transitions[0] << OFFSET_SHIFT) >> OFFSET_SHIFT) * 1000);
+
+    GregorianCalendar cal = new GregorianCalendar((TimeZone) gmtZone);
+    cal.set(year, month, day, 0, 0, 0);
+    if (cal.get(Calendar.DAY_OF_MONTH) != day)
+      throw new IllegalArgumentException("day out of range");
+
+    long date = cal.getTime().getTime() - rawOffset + millis;
+    long d = (date >= 0 ? date / 1000 : (date + 1) / 1000 - 1);
+    long transition = findTransition(d);
+
+    // For times on or after last transition use lastRule.
+    if (transition == Long.MAX_VALUE)
+      return lastRule.getOffset(era, year, month, day, dayOfWeek, millis);
+
+    return (int) (((transition << OFFSET_SHIFT) >> OFFSET_SHIFT) * 1000);
+  }
+
+  private long findTransition(long secs)
+  {
+    if (secs < (transitions[0] >> SECS_SHIFT))
+      return transitions[0];
+
+    if (secs >= (transitions[transitions.length-1] >> SECS_SHIFT))
+      return Long.MAX_VALUE;
+
+    long val = (secs + 1) << SECS_SHIFT;
+    int lo = 1;
+    int hi = transitions.length;
+    int mid = 1;
+    while (lo < hi)
+      {
+	mid = (lo + hi) / 2;
+	// secs < (transitions[mid-1] >> SECS_SHIFT)
+	if (val <= transitions[mid-1])
+	  hi = mid;
+	// secs >= (transitions[mid] >> SECS_SHIFT)
+	else if (val > transitions[mid])
+	  lo = mid + 1;
+	else
+	  break;
+      }
+    return transitions[mid];
+  }
+
+  /**
+   * Returns the time zone offset to GMT in milliseconds, ignoring
+   * day light savings.
+   * @return the time zone offset.
+   */
+  public int getRawOffset()
+  {
+    return rawOffset;
+  }
+
+  /**
+   * Sets the standard time zone offset to GMT.
+   * @param rawOffset The time offset from GMT in milliseconds.
+   */
+  public void setRawOffset(int rawOffset)
+  {
+    this.rawOffset = rawOffset;
+    lastRule.setRawOffset(rawOffset);
+  }
+
+  private void computeDSTSavings()
+  {
+    if (lastRule.useDaylightTime())
+      {
+	dstSavings = lastRule.getDSTSavings();
+	useDaylight = true;
+      }
+    else
+      {
+	dstSavings = 0;
+	useDaylight = false;
+	// lastRule might say no DST is in effect simply because
+	// the DST rules are too complex for SimpleTimeZone, say
+	// for Asia/Jerusalem.
+	// Look at the last DST offset if it is newer than current time.
+	long currentSecs = System.currentTimeMillis() / 1000;
+	int i;
+	for (i = transitions.length - 1;
+	     i >= 0 && currentSecs < (transitions[i] >> SECS_SHIFT);
+	     i--)
+	  if ((transitions[i] & IS_DST) != 0)
+	    {
+	      dstSavings = (int) (((transitions[i] << OFFSET_SHIFT)
+				   >> OFFSET_SHIFT) * 1000)
+			   - rawOffset;
+	      useDaylight = true;
+	      break;
+	    }
+      }
+  }
+
+  /**
+   * Gets the daylight savings offset.  This is a positive offset in
+   * milliseconds with respect to standard time.  Typically this
+   * is one hour, but for some time zones this may be half an our.
+   * @return the daylight savings offset in milliseconds.
+   */
+  public int getDSTSavings()
+  {
+    return dstSavings;
+  }
+
+  /**
+   * Returns if this time zone uses daylight savings time.
+   * @return true, if we use daylight savings time, false otherwise.
+   */
+  public boolean useDaylightTime()
+  {
+    return useDaylight;
+  }
+
+  /**
+   * Determines if the given date is in daylight savings time.
+   * @return true, if it is in daylight savings time, false otherwise.
+   */
+  public boolean inDaylightTime(Date date)
+  {
+    long d = date.getTime();
+    d = (d >= 0 ? d / 1000 : (d + 1) / 1000 - 1);
+    long transition = findTransition(d);
+
+    // For times on or after last transition use lastRule.
+    if (transition == Long.MAX_VALUE)
+      return lastRule.inDaylightTime(date);
+
+    return (transition & IS_DST) != 0;
+  }
+
+  /**
+   * Generates the hashCode for the SimpleDateFormat object.  It is
+   * the rawOffset, possibly, if useDaylightSavings is true, xored
+   * with startYear, startMonth, startDayOfWeekInMonth, ..., endTime.
+   */
+  public synchronized int hashCode()
+  {
+    int hash = lastRule.hashCode();
+    // FIXME - hash transitions?
+    return hash;
+  }
+
+  public synchronized boolean equals(Object o)
+  {
+    if (! hasSameRules((TimeZone) o))
+      return false;
+
+    ZoneInfo zone = (ZoneInfo) o;
+    return getID().equals(zone.getID());
+  }
+
+  /**
+   * Test if the other time zone uses the same rule and only
+   * possibly differs in ID.  This implementation for this particular
+   * class will return true if the other object is a ZoneInfo,
+   * the raw offsets and useDaylight are identical and if useDaylight
+   * is true, also the start and end datas are identical.
+   * @return true if this zone uses the same rule.
+   */
+  public boolean hasSameRules(TimeZone o)
+  {
+    if (this == o)
+      return true;
+    if (! (o instanceof ZoneInfo))
+      return false;
+    ZoneInfo zone = (ZoneInfo) o;
+    if (zone.hashCode() != hashCode() || rawOffset != zone.rawOffset)
+      return false;
+    if (! lastRule.equals(zone.lastRule))
+      return false;
+    // FIXME - compare transitions?
+    return true;
+  }
+
+  /**
+   * Returns a string representation of this ZoneInfo object.
+   * @return a string representation of this ZoneInfo object.
+   */
+  public String toString()
+  {
+    return getClass().getName() + "[" + "id=" + getID() + ",offset="
+	   + rawOffset + ",transitions=" + transitions.length
+	   + ",useDaylight=" + useDaylight
+	   + (useDaylight ? (",dstSavings=" + dstSavings) : "")
+	   + ",lastRule=" + lastRule.toString() + "]";
+  }
+
+  /**
+   * Reads zic(8) compiled timezone data file from file
+   * and returns a TimeZone class describing it, either
+   * SimpleTimeZone or ZoneInfo depending on whether
+   * it can be described by SimpleTimeZone rule or not.
+   */
+  public static TimeZone readTZFile(String id, String file)
+  {
+    DataInputStream dis = null;
+    try
+      {
+	FileInputStream fis = new FileInputStream(file);
+	BufferedInputStream bis = new BufferedInputStream(fis);
+	dis = new DataInputStream(bis);
+
+	// Make sure we are reading a tzfile.
+	byte[] tzif = new byte[5];
+	dis.readFully(tzif);
+	int tzif2 = 4;
+	if (tzif[0] == 'T' && tzif[1] == 'Z'
+	    && tzif[2] == 'i' && tzif[3] == 'f')
+	  {
+	    if (tzif[4] >= '2')
+	      tzif2 = 8;
+	    // Reserved bytes
+	    skipFully(dis, 16 - 1);
+	  }
+	else
+	  // Darwin has tzdata files that don't start with the TZif marker
+	  skipFully(dis, 16 - 5);
+
+	int ttisgmtcnt = dis.readInt();
+	int ttisstdcnt = dis.readInt();
+	int leapcnt = dis.readInt();
+	int timecnt = dis.readInt();
+	int typecnt = dis.readInt();
+	int charcnt = dis.readInt();
+	if (tzif2 == 8)
+	  {
+	    skipFully(dis, timecnt * (4 + 1) + typecnt * (4 + 1 + 1) + charcnt
+			   + leapcnt * (4 + 4) + ttisgmtcnt + ttisstdcnt);
+
+	    dis.readFully(tzif);
+	    if (tzif[0] != 'T' || tzif[1] != 'Z' || tzif[2] != 'i'
+		|| tzif[3] != 'f' || tzif[4] < '2')
+	      return null;
+
+	    // Reserved bytes
+	    skipFully(dis, 16 - 1);
+	    ttisgmtcnt = dis.readInt();
+	    ttisstdcnt = dis.readInt();
+	    leapcnt = dis.readInt();
+	    timecnt = dis.readInt();
+	    typecnt = dis.readInt();
+	    charcnt = dis.readInt();
+	  }
+
+	// Sanity checks
+	if (typecnt <= 0 || timecnt < 0 || charcnt < 0
+	    || leapcnt < 0 || ttisgmtcnt < 0 || ttisstdcnt < 0
+	    || ttisgmtcnt > typecnt || ttisstdcnt > typecnt)
+	  return null;
+
+	// Transition times
+	long[] times = new long[timecnt];
+	for (int i = 0; i < timecnt; i++)
+	  if (tzif2 == 8)
+	    times[i] = dis.readLong();
+	  else
+	    times[i] = (long) dis.readInt();
+
+	// Transition types
+	int[] types = new int[timecnt];
+	for (int i = 0; i < timecnt; i++)
+	  {
+	    types[i] = dis.readByte();
+	    if (types[i] < 0)
+	      types[i] += 256;
+	    if (types[i] >= typecnt)
+	      return null;
+	  }
+
+	// Types
+	int[] offsets = new int[typecnt];
+	int[] typeflags = new int[typecnt];
+	for (int i = 0; i < typecnt; i++)
+	  {
+	    offsets[i] = dis.readInt();
+	    if (offsets[i] >= IS_DST / 2 || offsets[i] <= -IS_DST / 2)
+	      return null;
+	    int dst = dis.readByte();
+	    int abbrind = dis.readByte();
+	    if (abbrind < 0)
+	      abbrind += 256;
+	    if (abbrind >= charcnt)
+	      return null;
+	    typeflags[i] = (dst != 0 ? (1 << 8) : 0) + abbrind;
+	  }
+
+	// Abbrev names
+	byte[] names = new byte[charcnt];
+	dis.readFully(names);
+
+	// Leap transitions, for now ignore
+	skipFully(dis, leapcnt * (tzif2 + 4) + ttisstdcnt + ttisgmtcnt);
+
+	// tzIf2 format has optional POSIX TZ env string
+	String tzstr = null;
+	if (tzif2 == 8 && dis.readByte() == '\n')
+	  {
+	    tzstr = dis.readLine();
+	    if (tzstr.length() <= 0)
+	      tzstr = null;
+	  }
+
+	// Get std/dst_offset and dst/non-dst time zone names.
+	int std_ind = -1;
+	int dst_ind = -1;
+	if (timecnt == 0)
+	  std_ind = 0;
+	else
+	  for (int i = timecnt - 1; i >= 0; i--)
+	    {
+	      if (std_ind == -1 && (typeflags[types[i]] & (1 << 8)) == 0)
+		std_ind = types[i];
+	      else if (dst_ind == -1 && (typeflags[types[i]] & (1 << 8)) != 0)
+		dst_ind = types[i];
+	      if (dst_ind != -1 && std_ind != -1)
+		break;
+	    }
+
+	if (std_ind == -1)
+	  return null;
+
+	int j = typeflags[std_ind] & 255;
+	while (j < charcnt && names[j] != 0)
+	  j++;
+	String std_zonename = new String(names, typeflags[std_ind] & 255,
+					 j - (typeflags[std_ind] & 255),
+					 "ASCII");
+
+	String dst_zonename = "";
+	if (dst_ind != -1)
+	  {
+	    j = typeflags[dst_ind] & 255;
+	    while (j < charcnt && names[j] != 0)
+	      j++;
+	    dst_zonename = new String(names, typeflags[dst_ind] & 255,
+				      j - (typeflags[dst_ind] & 255), "ASCII");
+	  }
+
+	// Only use gmt offset when necessary.
+	// Also special case GMT+/- timezones.
+	String std_offset_string = "";
+	String dst_offset_string = "";
+	if (tzstr == null
+	    && (dst_ind != -1
+		|| (offsets[std_ind] != 0
+		    && !std_zonename.startsWith("GMT+")
+		    && !std_zonename.startsWith("GMT-"))))
+	  {
+	    std_offset_string = Integer.toString(-offsets[std_ind] / 3600);
+	    int seconds = -offsets[std_ind] % 3600;
+	    if (seconds != 0)
+	      {
+		if (seconds < 0)
+		  seconds *= -1;
+		if (seconds < 600)
+		  std_offset_string += ":0" + Integer.toString(seconds / 60);
+		else
+		  std_offset_string += ":" + Integer.toString(seconds / 60);
+		seconds = seconds % 60;
+		if (seconds >= 10)
+		  std_offset_string += ":" + Integer.toString(seconds);
+		else if (seconds > 0)
+		  std_offset_string += ":0" + Integer.toString(seconds);
+	      }
+
+	    if (dst_ind != -1 && offsets[dst_ind] != offsets[std_ind] + 3600)
+	      {
+		dst_offset_string = Integer.toString(-offsets[dst_ind] / 3600);
+		seconds = -offsets[dst_ind] % 3600;
+		if (seconds != 0)
+		  {
+		    if (seconds < 0)
+		      seconds *= -1;
+		    if (seconds < 600)
+		      dst_offset_string
+			+= ":0" + Integer.toString(seconds / 60);
+		    else
+		      dst_offset_string
+			+= ":" + Integer.toString(seconds / 60);
+		    seconds = seconds % 60;
+		    if (seconds >= 10)
+		      dst_offset_string += ":" + Integer.toString(seconds);
+		    else if (seconds > 0)
+		      dst_offset_string += ":0" + Integer.toString(seconds);
+		  }
+	      }
+	  }
+
+	/*
+	 * If no tzIf2 POSIX TZ string is available and the timezone
+	 * uses DST, try to guess the last rule by trying to make
+	 * sense from transitions at 5 years in the future and onwards.
+	 * tzdata actually uses only 3 forms of rules:
+	 * fixed date within a month, e.g. change on April, 5th
+	 * 1st weekday on or after Nth: change on Sun>=15 in April
+	 * last weekday in a month: change on lastSun in April
+	 */
+	String[] change_spec = { null, null };
+	if (tzstr == null && dst_ind != -1 && timecnt > 10)
+	  {
+	    long nowPlus5y = System.currentTimeMillis() / 1000
+			     + 5 * 365 * 86400;
+	    int first;
+
+	    for (first = timecnt - 1; first >= 0; first--)
+	      if (times[first] < nowPlus5y
+		  || (types[first] != std_ind && types[first] != dst_ind)
+		  || types[first] != types[timecnt - 2 + ((first ^ timecnt) & 1)])
+		break;
+	    first++;
+
+	    if (timecnt - first >= 10 && types[timecnt - 1] != types[timecnt - 2])
+	      {
+		GregorianCalendar cal
+		  = new GregorianCalendar(new SimpleTimeZone(0, "GMT"));
+
+		int[] values = new int[2 * 11];
+		int i;
+		for (i = timecnt - 1; i >= first; i--)
+		  {
+		    int base = (i % 2) * 11;
+		    int offset = offsets[types[i > first ? i - 1 : i + 1]];
+		    cal.setTime(new Date((times[i] + offset) * 1000));
+		    if (i >= timecnt - 2)
+		      {
+			values[base + 0] = cal.get(Calendar.YEAR);
+			values[base + 1] = cal.get(Calendar.MONTH);
+			values[base + 2] = cal.get(Calendar.DAY_OF_MONTH);
+			values[base + 3]
+			  = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
+			values[base + 4] = cal.get(Calendar.DAY_OF_WEEK);
+			values[base + 5] = cal.get(Calendar.HOUR_OF_DAY);
+			values[base + 6] = cal.get(Calendar.MINUTE);
+			values[base + 7] = cal.get(Calendar.SECOND);
+			values[base + 8] = values[base + 2]; // Range start
+			values[base + 9] = values[base + 2]; // Range end
+			values[base + 10] = 0; // Determined type
+		      }
+		    else
+		      {
+			int year = cal.get(Calendar.YEAR);
+			int month = cal.get(Calendar.MONTH);
+			int day_of_month = cal.get(Calendar.DAY_OF_MONTH);
+			int month_days
+			  = cal.getActualMaximum(Calendar.DAY_OF_MONTH);
+			int day_of_week = cal.get(Calendar.DAY_OF_WEEK);
+			int hour = cal.get(Calendar.HOUR_OF_DAY);
+			int minute = cal.get(Calendar.MINUTE);
+			int second = cal.get(Calendar.SECOND);
+			if (year != values[base + 0] - 1
+			    || month != values[base + 1]
+			    || hour != values[base + 5]
+			    || minute != values[base + 6]
+			    || second != values[base + 7])
+			  break;
+			if (day_of_week == values[base + 4])
+			  {
+			    // Either a Sun>=8 or lastSun rule.
+			    if (day_of_month < values[base + 8])
+			      values[base + 8] = day_of_month;
+			    if (day_of_month > values[base + 9])
+			      values[base + 9] = day_of_month;
+			    if (values[base + 10] < 0)
+			      break;
+			    if (values[base + 10] == 0)
+			      {
+				values[base + 10] = 1;
+				// If day of month > 28, this is
+				// certainly lastSun rule.
+				if (values[base + 2] > 28)
+				  values[base + 2] = 3;
+				// If day of month isn't in the last
+				// week, it can't be lastSun rule.
+				else if (values[base + 2]
+					 <= values[base + 3] - 7)
+				  values[base + 3] = 2;
+			      }
+			    if (values[base + 10] == 1)
+			      {
+				// If day of month is > 28, this is
+				// certainly lastSun rule.
+				if (day_of_month > 28)
+				  values[base + 10] = 3;
+				// If day of month isn't in the last
+				// week, it can't be lastSun rule.
+				else if (day_of_month <= month_days - 7)
+				  values[base + 10] = 2;
+			      }
+			    else if ((values[base + 10] == 2
+				      && day_of_month > 28)
+				     || (values[base + 10] == 3
+					 && day_of_month <= month_days - 7))
+			      break;
+			  }
+			else
+			  {
+			    // Must be fixed day in month rule.
+			    if (day_of_month != values[base + 2]
+				|| values[base + 10] > 0)
+			      break;
+			    values[base + 4] = day_of_week;
+			    values[base + 10] = -1;
+			  }
+			values[base + 0] -= 1;
+		      }
+		  }
+
+		if (i < first)
+		  {
+		    for (i = 0; i < 2; i++)
+		      {
+			int base = 11 * i;
+			if (values[base + 10] == 0)
+			  continue;
+			if (values[base + 10] == -1)
+			  {
+			    int[] dayCount
+			      = { 0, 31, 59, 90, 120, 151,
+				  181, 212, 243, 273, 304, 334 };
+			    int d = dayCount[values[base + 1]
+					     - Calendar.JANUARY];
+			    d += values[base + 2];
+			    change_spec[i] = ",J" + Integer.toString(d);
+			  }
+			else if (values[base + 10] == 2)
+			  {
+			    // If we haven't seen all days of the week,
+			    // we can't be sure what the rule really is.
+			    if (values[base + 8] + 6 != values[base + 9])
+			      continue;
+
+			    int d;
+			    d = values[base + 1] - Calendar.JANUARY + 1;
+			    // E.g. Sun >= 5 is not representable in POSIX
+			    // TZ env string, use ",Am.n.d" extension
+			    // where m is month 1 .. 12, n is the date on
+			    // or after which it happens and d is day
+			    // of the week, 0 .. 6.  So Sun >= 5 in April
+			    // is ",A4.5.0".
+			    if ((values[base + 8] % 7) == 1)
+			      {
+				change_spec[i] = ",M" + Integer.toString(d);
+				d = (values[base + 8] + 6) / 7;
+			      }
+			    else
+			      {
+				change_spec[i] = ",A" + Integer.toString(d);
+				d = values[base + 8];
+			      }
+			    change_spec[i] += "." + Integer.toString(d);
+			    d = values[base + 4] - Calendar.SUNDAY;
+			    change_spec[i] += "." + Integer.toString(d);
+			  }
+			else
+			  {
+			    // If we don't know whether this is lastSun or
+			    // Sun >= 22 rule.  That can be either because
+			    // there was insufficient number of
+			    // transitions, or February, where it is quite
+			    // probable we haven't seen any 29th dates.
+			    // For February, assume lastSun rule, otherwise
+			    // punt.
+			    if (values[base + 10] == 1
+				&& values[base + 1] != Calendar.FEBRUARY)
+			      continue;
+
+			    int d;
+			    d = values[base + 1] - Calendar.JANUARY + 1;
+			    change_spec[i] = ",M" + Integer.toString(d);
+			    d = values[base + 4] - Calendar.SUNDAY;
+			    change_spec[i] += ".5." + Integer.toString(d);
+			  }
+
+			// Don't add time specification if time is
+			// 02:00:00.
+			if (values[base + 5] != 2
+			    || values[base + 6] != 0
+			    || values[base + 7] != 0)
+			  {
+			    int d = values[base + 5];
+			    change_spec[i] += "/" + Integer.toString(d);
+			    if (values[base + 6] != 0 || values[base + 7] != 0)
+			      {
+				d = values[base + 6];
+				if (d < 10)
+				  change_spec[i]
+				    += ":0" + Integer.toString(d);
+				else
+				  change_spec[i] += ":" + Integer.toString(d);
+				d = values[base + 7];
+				if (d >= 10)
+				   change_spec[i]
+				     += ":" + Integer.toString(d);
+				else if (d > 0)
+				  change_spec[i]
+				    += ":0" + Integer.toString(d);
+			      }
+			  }
+		      }
+		    if (types[(timecnt - 1) & -2] == std_ind)
+		      {
+			String tmp = change_spec[0];
+			change_spec[0] = change_spec[1];
+			change_spec[1] = tmp;
+		      }
+		  }
+	      }
+	  }
+
+	if (tzstr == null)
+	  {
+	    tzstr = std_zonename + std_offset_string;
+	    if (change_spec[0] != null && change_spec[1] != null)
+	      tzstr += dst_zonename + dst_offset_string
+		       + change_spec[0] + change_spec[1];
+	  }
+
+	if (timecnt == 0)
+	  return new SimpleTimeZone(offsets[std_ind] * 1000,
+				    id != null ? id : tzstr);
+
+	SimpleTimeZone endRule = createLastRule(tzstr);
+	if (endRule == null)
+	  return null;
+
+	/* Finally adjust the times array into the form the constructor
+	 * expects.  times[0] is special, the offset and DST flag there
+	 * are for all times before that transition.  Use the first non-DST
+	 * type.  For all other transitions, the data file has the type
+	 * (<offset, isdst, zonename>) for the time interval starting
+	 */
+	for (int i = 0; i < typecnt; i++)
+	  if ((typeflags[i] & (1 << 8)) == 0)
+	    {
+	      times[0] = (times[0] << SECS_SHIFT) | (offsets[i] & OFFSET_MASK);
+	      break;
+	    }
+
+	for (int i = 1; i < timecnt; i++)
+	  times[i] = (times[i] << SECS_SHIFT)
+		     | (offsets[types[i - 1]] & OFFSET_MASK)
+		     | ((typeflags[types[i - 1]] & (1 << 8)) != 0 ? IS_DST : 0);
+
+	return new ZoneInfo(offsets[std_ind] * 1000, id != null ? id : tzstr,
+			    times, endRule);
+      }
+    catch (IOException ioe)
+      {
+	// Parse error, not a proper tzfile.
+	return null;
+      }
+    finally
+      {
+	try
+	  {
+	    if (dis != null)
+	      dis.close();
+	  }
+	catch(IOException ioe)
+	  {
+	    // Error while close, nothing we can do.
+	  }
+      }
+  }
+
+  /**
+   * Skips the requested number of bytes in the given InputStream.
+   * Throws EOFException if not enough bytes could be skipped.
+   * Negative numbers of bytes to skip are ignored.
+   */
+  private static void skipFully(InputStream is, long l) throws IOException
+  {
+    while (l > 0)
+      {
+	long k = is.skip(l);
+	if (k <= 0)
+	  throw new EOFException();
+	l -= k;
+      }
+  }
+
+  /**
+   * Create a SimpleTimeZone from a POSIX TZ environment string,
+   * see http://www.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap08.html
+   * for details.
+   * It supports also an extension, where Am.n.d rule (m 1 .. 12, n 1 .. 25, d
+   * 0 .. 6) describes day of week d on or after nth day of month m.
+   * Say A4.5.0 is Sun>=5 in April.
+   */
+  private static SimpleTimeZone createLastRule(String tzstr)
+  {
+    String stdName = null;
+    int stdOffs;
+    int dstOffs;
+    try
+      {
+	int idLength = tzstr.length();
+
+	int index = 0;
+	int prevIndex;
+	char c;
+
+	// get std
+	do
+	  c = tzstr.charAt(index);
+	while (c != '+' && c != '-' && c != ',' && c != ':'
+	       && ! Character.isDigit(c) && c != '\0' && ++index < idLength);
+
+	if (index >= idLength)
+	  return new SimpleTimeZone(0, tzstr);
+
+	stdName = tzstr.substring(0, index);
+	prevIndex = index;
+
+	// get the std offset
+	do
+	  c = tzstr.charAt(index++);
+	while ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))
+	       && index < idLength);
+	if (index < idLength)
+	  index--;
+
+	{ // convert the dst string to a millis number
+	    String offset = tzstr.substring(prevIndex, index);
+	    prevIndex = index;
+
+	    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')
+	      stdOffs = parseTime(offset.substring(1));
+	    else
+	      stdOffs = parseTime(offset);
+
+	    if (offset.charAt(0) == '-')
+	      stdOffs = -stdOffs;
+
+	    // TZ timezone offsets are positive when WEST of the meridian.
+	    stdOffs = -stdOffs;
+	}
+
+	// Done yet? (Format: std offset)
+	if (index >= idLength)
+	  return new SimpleTimeZone(stdOffs, stdName);
+
+	// get dst
+	do
+	  c = tzstr.charAt(index);
+	while (c != '+' && c != '-' && c != ',' && c != ':'
+	       && ! Character.isDigit(c) && c != '\0' && ++index < idLength);
+
+	// Done yet? (Format: std offset dst)
+	if (index >= idLength)
+	  return new SimpleTimeZone(stdOffs, stdName);
+
+	// get the dst offset
+	prevIndex = index;
+	do
+	  c = tzstr.charAt(index++);
+	while ((c == '-' || c == '+' || c == ':' || Character.isDigit(c))
+	       && index < idLength);
+	if (index < idLength)
+	  index--;
+
+	if (index == prevIndex && (c == ',' || c == ';'))
+	  {
+	    // Missing dst offset defaults to one hour ahead of standard
+	    // time.
+	    dstOffs = stdOffs + 60 * 60 * 1000;
+	  }
+	else
+	  { // convert the dst string to a millis number
+	    String offset = tzstr.substring(prevIndex, index);
+	    prevIndex = index;
+
+	    if (offset.charAt(0) == '+' || offset.charAt(0) == '-')
+	      dstOffs = parseTime(offset.substring(1));
+	    else
+	      dstOffs = parseTime(offset);
+
+	    if (offset.charAt(0) == '-')
+	      dstOffs = -dstOffs;
+
+	    // TZ timezone offsets are positive when WEST of the meridian.
+	    dstOffs = -dstOffs;
+	  }
+
+	// Done yet? (Format: std offset dst offset)
+	if (index >= idLength)
+	  return new SimpleTimeZone(stdOffs, stdName);
+
+	// get the DST rule
+	if (tzstr.charAt(index) == ','
+	    || tzstr.charAt(index) == ';')
+	  {
+	    index++;
+	    int offs = index;
+	    while (tzstr.charAt(index) != ','
+		   && tzstr.charAt(index) != ';')
+	      index++;
+	    String startTime = tzstr.substring(offs, index);
+	    index++;
+	    String endTime = tzstr.substring(index);
+
+	    index = startTime.indexOf('/');
+	    int startMillis;
+	    int endMillis;
+	    String startDate;
+	    String endDate;
+	    if (index != -1)
+	      {
+		startDate = startTime.substring(0, index);
+		startMillis = parseTime(startTime.substring(index + 1));
+	      }
+	    else
+	      {
+		startDate = startTime;
+		// if time isn't given, default to 2:00:00 AM.
+		startMillis = 2 * 60 * 60 * 1000;
+	      }
+	    index = endTime.indexOf('/');
+	    if (index != -1)
+	      {
+		endDate = endTime.substring(0, index);
+		endMillis = parseTime(endTime.substring(index + 1));
+	      }
+	    else
+	      {
+		endDate = endTime;
+		// if time isn't given, default to 2:00:00 AM.
+		endMillis = 2 * 60 * 60 * 1000;
+	      }
+
+	    int[] start = getDateParams(startDate);
+	    int[] end = getDateParams(endDate);
+	    return new SimpleTimeZone(stdOffs, tzstr, start[0], start[1],
+				      start[2], startMillis, end[0], end[1],
+				      end[2], endMillis, (dstOffs - stdOffs));
+	  }
+      }
+
+    catch (IndexOutOfBoundsException _)
+      {
+      }
+    catch (NumberFormatException _)
+      {
+      }
+
+    return null;
+  }
+
+  /**
+   * Parses and returns the params for a POSIX TZ date field,
+   * in the format int[]{ month, day, dayOfWeek }, following the
+   * SimpleTimeZone constructor rules.
+   */
+  private static int[] getDateParams(String date)
+  {
+    int[] dayCount = { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
+    int month;
+    int type = 0;
+
+    if (date.charAt(0) == 'M' || date.charAt(0) == 'm')
+      type = 1;
+    else if (date.charAt(0) == 'A' || date.charAt(0) == 'a')
+      type = 2;
+
+    if (type > 0)
+      {
+	int day;
+
+	// Month, week of month, day of week
+	// "Mm.w.d".  d is between 0 (Sunday) and 6.  Week w is
+	// between 1 and 5; Week 1 is the first week in which day d
+	// occurs and Week 5 specifies the last d day in the month.
+	// Month m is between 1 and 12.
+
+	// Month, day of month, day of week
+	// ZoneInfo extension, not in POSIX
+	// "Am.n.d".  d is between 0 (Sunday) and 6.  Day of month n is
+	// between 1 and 25.  Month m is between 1 and 12.
+
+	month = Integer.parseInt(date.substring(1, date.indexOf('.')));
+	int week = Integer.parseInt(date.substring(date.indexOf('.') + 1,
+						   date.lastIndexOf('.')));
+	int dayOfWeek = Integer.parseInt(date.substring(date.lastIndexOf('.')
+							+ 1));
+	dayOfWeek++; // Java day of week is one-based, Sunday is first day.
+
+	if (type == 2)
+	  {
+	    day = week;
+	    dayOfWeek = -dayOfWeek;
+	  }
+ 	else if (week == 5)
+ 	  day = -1; // last day of month is -1 in java, 5 in TZ
+ 	else
+	  {
+	    // First day of week starting on or after.  For example,
+	    // to specify the second Sunday of April, set month to
+	    // APRIL, day-of-month to 8, and day-of-week to -SUNDAY.
+	    day = (week - 1) * 7 + 1;
+	    dayOfWeek = -dayOfWeek;
+	  }
+
+	month--; // Java month is zero-based.
+	return new int[] { month, day, dayOfWeek };
+      }
+
+    // julian day, either zero-based 0<=n<=365 (incl feb 29)
+    // or one-based 1<=n<=365 (no feb 29)
+    int julianDay; // Julian day
+
+    if (date.charAt(0) != 'J' || date.charAt(0) != 'j')
+      {
+	julianDay = Integer.parseInt(date.substring(1));
+	julianDay++; // make 1-based
+	// Adjust day count to include feb 29.
+	dayCount = new int[]
+		   {
+		     0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335
+		   };
+      }
+    else
+      // 1-based julian day
+      julianDay = Integer.parseInt(date);
+
+    int i = 11;
+    while (i > 0)
+      if (dayCount[i] < julianDay)
+	break;
+      else
+	i--;
+    julianDay -= dayCount[i];
+    month = i;
+    return new int[] { month, julianDay, 0 };
+  }
+
+  /**
+   * Parses a time field hh[:mm[:ss]], returning the result
+   * in milliseconds. No leading sign.
+   */
+  private static int parseTime(String time)
+  {
+    int millis = 0;
+    int i = 0;
+
+    while (i < time.length())
+      if (time.charAt(i) == ':')
+	break;
+      else
+	i++;
+    millis = 60 * 60 * 1000 * Integer.parseInt(time.substring(0, i));
+    if (i >= time.length())
+      return millis;
+
+    int iprev = ++i;
+    while (i < time.length())
+      if (time.charAt(i) == ':')
+	break;
+      else
+	i++;
+    millis += 60 * 1000 * Integer.parseInt(time.substring(iprev, i));
+    if (i >= time.length())
+      return millis;
+
+    millis += 1000 * Integer.parseInt(time.substring(++i));
+    return millis;
+  }
+}
