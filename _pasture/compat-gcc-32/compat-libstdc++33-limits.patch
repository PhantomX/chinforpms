2004-10-14  Jakub Jelinek  <jakub@redhat.com>

	* include/std/std_limits.h: For GCC 3.2.x and earlier include
	GCC 3.2.3 std_limits.h.

	Revert:
	2002-09-25  Benjamin Kosnik  <bkoz@redhat.com>

        * include/Makefile.am (target_headers): Remove cpu_limits.h.
        * include/Makefile.in: Regenerate.
        * configure.in (CPU_LIMITS_INC_SRCDIR): Remove
        * configure: Regenerate.
        * configure.target (CPULIMITS): Remove.

        * config/os/solaris/solaris2.7/os_defines.h (__glibcpp_long_bits):
        Remove.
        * config/os/irix/irix6.5/os_defines.h
        (__glibcpp_long_double_bits): Remove.
        (__glibcpp_wchar_t_bits): Remove.
        (__glibcpp_long_bits): Remove.
        * config/os/irix/irix5.2/os_defines.h
        (__glibcpp_long_double_bits): Remove.
        (__glibcpp_long_bits): Remove.
        * config/os/hpux/os_defines.h (__glibcpp_wchar_t_is_signed): Remove.
        * config/os/bsd/freebsd/os_defines.h:
        (__glibcpp_long_double_bits): Remove.
        * config/os/aix/os_defines.h (__glibcpp_wchar_t_bits): Remove.
        (__glibcpp_wchar_t_is_signed): Remove.
        (__glibcpp_long_bits): Remove.
        * config/os/gnu-linux/os_defines.h (__glibcpp_long_bits): Remove.
        (__glibcpp_long_double_bits): Remove.

        * config/os/osf/osf5.0/cpu_limits.h: Remove.
        * config/cpu/alpha/cpu_limits.h: Remove.
        * config/cpu/arm/cpu_limits.h: Remove.
        * config/cpu/cris/cpu_limits.h: Remove.
        * config/cpu/generic/cpu_limits.h: Remove.
        * config/cpu/generic/limits.h: Remove.
        * config/cpu/ia64/cpu_limits.h: Remove.
        * config/cpu/m68k/cpu_limits.h: Remove.
        * config/cpu/mmix/cpu_limits.h: Remove.
        * config/cpu/powerpc/cpu_limits.h: Remove.
        * config/cpu/S390/cpu_limits.h: Remove.

--- libstdc++33-v3/libmath/Makefile.in.jj	2003-03-17 14:07:39.000000000 -0500
+++ libstdc++33-v3/libmath/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/libsupc++/Makefile.in.jj	2004-06-28 18:29:56.000000000 -0400
+++ libstdc++33-v3/libsupc++/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -82,6 +82,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/src/Makefile.in.jj	2004-01-20 06:36:07.000000000 -0500
+++ libstdc++33-v3/src/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -82,6 +82,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/config/os/bsd/freebsd/os_defines.h.jj	2003-05-15 18:08:04.000000000 -0400
+++ libstdc++33-v3/config/os/bsd/freebsd/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -41,4 +41,6 @@
 #define _GLIBCPP_USE_C99_FLOAT_TRANSCENDENTALS_CHECK 1
 #define _GLIBCPP_USE_C99_FLOAT_TRANSCENDENTALS_DYNAMIC defined _XOPEN_SOURCE
 
+#define __glibcpp_long_double_bits __glibcpp_double_bits
+
 #endif
--- libstdc++33-v3/config/os/aix/os_defines.h.jj	2002-09-26 01:25:10.000000000 -0400
+++ libstdc++33-v3/config/os/aix/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -55,4 +55,13 @@
 #undef _G_USING_THUNKS
 #define _G_USING_THUNKS 0
 
+#if !defined(_AIX51) || !defined(__64BIT__)
+#define __glibcpp_wchar_t_bits 16
+#define __glibcpp_wchar_t_is_signed false
+#endif
+
+#ifdef __64BIT__
+#define __glibcpp_long_bits 64
+#endif
+
 #endif
--- libstdc++33-v3/config/os/gnu-linux/os_defines.h.jj	2002-09-26 01:25:10.000000000 -0400
+++ libstdc++33-v3/config/os/gnu-linux/os_defines.h	2004-10-14 12:52:11.000000000 -0400
@@ -65,4 +65,95 @@ typedef __loff_t __off64_t;
 #define __NO_STRING_INLINES
 #endif
 
+#if (defined(__hppa__) && defined(__LP64__)) || defined(__powerpc64__) || defined(__s390x__) || (defined(__sparc__) && defined(__arch64__))
+#define __glibcpp_long_bits 64
+#endif
+
+#if defined(__hppa__) || (defined(__sparc__) && !defined(__arch64__))
+#define __glibcpp_long_double_bits 64
+#endif
+
+/* RHEL3 hack.  */
+#if defined(__GNUC__) && !defined(__INTEL_COMPILER) && !defined(__IBMCPP__) \
+    && (defined(__i386__) || defined(__x86_64__) || defined(__ia64__) \
+	|| defined(__s390__) || defined(__s390x__) || defined(__powerpc__) \
+	|| defined(__powerpc64__))
+#define __glibcpp_float_has_quiet_NaN true
+#define __glibcpp_float_has_signaling_NaN true
+#define __glibcpp_float_has_denorm denorm_present
+#define __glibcpp_float_has_infinity true
+#define __glibcpp_float_round_style round_to_nearest
+#define __glibcpp_float_is_iec559 true
+#define __glibcpp_double_has_quiet_NaN true
+#define __glibcpp_double_has_signaling_NaN true
+#define __glibcpp_double_has_denorm denorm_present
+#define __glibcpp_double_has_infinity true
+#define __glibcpp_double_round_style round_to_nearest
+#define __glibcpp_double_is_iec559 true
+#define __glibcpp_long_double_has_quiet_NaN true
+#define __glibcpp_long_double_has_signaling_NaN true
+#define __glibcpp_long_double_has_denorm denorm_present
+#define __glibcpp_long_double_has_infinity true
+#define __glibcpp_long_double_round_style round_to_nearest
+#define __glibcpp_long_double_is_iec559 true
+
+#define __glibcpp_f32_round_error 0.5F
+#define __glibcpp_f64_round_error 0.5
+#define __glibcpp_f80_round_error 0.5L
+#define __glibcpp_f96_round_error 0.5L
+#define __glibcpp_f128_round_error 0.5L
+
+#define __glibcpp_float_infinity 1.0e+40F
+#define __glibcpp_double_infinity 1.0e+320
+#define __glibcpp_long_double_infinity 1.0e+5000L
+
+#define __glibcpp_float_denorm_min 1.40129846e-45F
+#define __glibcpp_double_denorm_min 4.9406564584124654e-324
+
+#define __glibcpp_float_quiet_NaN \
+  (__extension__ ((union { unsigned int __l; float __d; })		\
+		  { __l: 0x7fc00000 }).__d)
+#define __glibcpp_double_quiet_NaN \
+  (__extension__ ((union { unsigned long long __l; double __d; })	\
+		  { __l: 0x7ff8000000000000ULL }).__d)
+
+#define __glibcpp_float_signaling_NaN \
+  (__extension__ ({ union { unsigned int __l; float __d; } __u;		\
+		    __u.__l = 0x7fa00000;				\
+		    __asm ("" : : "r" (&__u) : "memory"); __u.__d; }))
+#define __glibcpp_double_signaling_NaN \
+  (__extension__ ({ union { unsigned long long __l; double __d; } __u;	\
+		    __u.__l = 0x7ff4000000000000ULL;			\
+		    __asm ("" : : "r" (&__u) : "memory"); __u.__d; }))
+
+#if __glibcpp_long_double_bits == 80
+
+#define __glibcpp_long_double_denorm_min 3.64519953188247460253e-4951L
+#define __glibcpp_long_double_quiet_NaN \
+  (__extension__ ({ union { unsigned long long __l[2];			\
+			    long double __d; } __u;			\
+		    __u.__l[0] = 0xcULL << 60; __u.__l[1] = 0x7fff;	\
+		    __u.__d; }))
+#define __glibcpp_long_double_signaling_NaN \
+  (__extension__ ({ union { unsigned long long __l[2];			\
+			    long double __d; } __u;			\
+		    __u.__l[0] = 0xaULL << 60; __u.__l[1] = 0x7fff;	\
+		    __asm ("" : : "r" (&__u) : "memory"); __u.__d; }))
+
+#else
+
+#define __glibcpp_long_double_denorm_min 4.9406564584124654e-324L
+#define __glibcpp_long_double_quiet_NaN \
+  (__extension__ ((union { unsigned long long __l; long double __d; })	\
+		  { __l: 0x7ff8000000000000ULL }).__d)
+#define __glibcpp_long_double_signaling_NaN \
+  (__extension__ ({ union { unsigned long long __l;			\
+			    long double __d; } __u;			\
+		     __u.__l = 0x7ff4000000000000ULL;			\
+		     __asm ("" : : "r" (&__u) : "memory"); __u.__d; }))
+
+#endif
+
+#endif
+
 #endif
--- libstdc++33-v3/config/os/hpux/os_defines.h.jj	2003-09-04 08:39:34.000000000 -0400
+++ libstdc++33-v3/config/os/hpux/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -37,6 +37,8 @@
 #define __off64_t off64_t
 #define __ssize_t ssize_t
 
+#define __glibcpp_wchar_t_is_signed false
+
 // Use macro form of ctype functions to ensure __SB_masks is defined.
 #define _SB_CTYPE_MACROS 1
 
--- libstdc++33-v3/config/os/irix/irix5.2/os_defines.h.jj	2002-09-26 01:25:11.000000000 -0400
+++ libstdc++33-v3/config/os/irix/irix5.2/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -51,5 +51,11 @@
 // GCC does not use thunks on IRIX. 
 #define _G_USING_THUNKS 0
 
+#define __glibcpp_long_double_bits 64
+
+#if __LONG_MAX__ > 2147483647
+#define __glibcpp_long_bits 64
+#endif
+
 #endif
 
--- libstdc++33-v3/config/os/irix/irix6.5/os_defines.h.jj	2002-09-26 01:25:11.000000000 -0400
+++ libstdc++33-v3/config/os/irix/irix6.5/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -51,5 +51,12 @@
 // GCC does not use thunks on IRIX. 
 #define _G_USING_THUNKS 0
 
+#define __glibcpp_long_double_bits 64
+
+#if __LONG_MAX__ > 2147483647
+#define __glibcpp_wchar_t_bits 64
+#define __glibcpp_long_bits 64
+#endif
+
 #endif
 
--- libstdc++33-v3/config/os/solaris/solaris2.7/os_defines.h.jj	2002-09-26 01:25:11.000000000 -0400
+++ libstdc++33-v3/config/os/solaris/solaris2.7/os_defines.h	2004-10-14 12:28:01.000000000 -0400
@@ -39,5 +39,9 @@
 #define __off64_t   off64_t
 #define __ssize_t   ssize_t
 
+#if defined(__sparcv9) || defined(__arch64__)
+#define __glibcpp_long_bits 64
+#endif
+
 #endif
 
--- libstdc++33-v3/config/cpu/alpha/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/alpha/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,38 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_bits 64
+
+#define __glibcpp_long_double_bits 64
+
+#endif
+
+
+
--- libstdc++33-v3/config/cpu/s390/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/s390/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,33 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_double_bits 64
+
+#endif
--- libstdc++33-v3/config/cpu/cris/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/cris/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,33 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_double_bits 64
+
+#endif
--- libstdc++33-v3/config/cpu/powerpc/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/powerpc/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,42 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#ifdef __powerpc64__
+#define __glibcpp_long_bits 64
+#endif
+
+#ifndef __LONG_DOUBLE_128__
+#define __glibcpp_long_double_bits 64
+#endif
+
+#endif
+
+
+
--- libstdc++33-v3/config/cpu/i386/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/i386/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,33 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_double_bits 80
+
+#endif
--- libstdc++33-v3/config/cpu/m68k/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/m68k/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,35 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_double_bits 96
+
+#endif
+
+
--- libstdc++33-v3/config/cpu/ia64/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/ia64/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,36 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#define __glibcpp_long_bits 64
+
+// While sizeof(long double) == 16, the format is the same as the x86.
+#define __glibcpp_long_double_bits 80
+
+#endif
--- libstdc++33-v3/config/cpu/generic/cpu_limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/generic/cpu_limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,41 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+// Nothing is defined in the generic file.  In that way, we fall back
+// on the defaults in std_limits.h.
+
+// If you need to override these defaults, you can either use a
+// CPU-specific version (in which case you must modify
+// configure.target) or you must add the overrides to your
+// os_defines.h.  In general, if all systems for your CPU use the
+// same values, it is best to use a cpu-specific configuration file.
+
+#endif
+
--- libstdc++33-v3/config/cpu/generic/limits.h.jj	2004-10-14 12:28:01.000000000 -0400
+++ libstdc++33-v3/config/cpu/generic/limits.h	2004-10-14 12:28:01.000000000 -0400
@@ -0,0 +1,40 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+// Nothing is defined in the generic file.  In that way, we fall back
+// on the defaults in std_limits.h.
+
+// If you need to override these defaults, you can either use a
+// CPU-specific version (in which case you must modify
+// configure.target) or you must add the overrides to your
+// os_defines.h.  In general, if all systems for your CPU use the
+// same values, it is best to use a cpu-specific configuration file.
+
+#endif
--- libstdc++33-v3/config/cpu/x86-64/cpu_limits.h.jj	2004-10-14 12:53:35.000000000 -0400
+++ libstdc++33-v3/config/cpu/x86-64/cpu_limits.h	2004-10-14 12:53:42.000000000 -0400
@@ -0,0 +1,37 @@
+// Copyright (C) 2001 Free Software Foundation, Inc.
+//
+// This file is part of the GNU ISO C++ Library.  This library is free
+// software; you can redistribute it and/or modify it under the
+// terms of the GNU General Public License as published by the
+// Free Software Foundation; either version 2, or (at your option)
+// any later version.
+
+// This library is distributed in the hope that it will be useful,
+// but WITHOUT ANY WARRANTY; without even the implied warranty of
+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+// GNU General Public License for more details.
+
+// You should have received a copy of the GNU General Public License along
+// with this library; see the file COPYING.  If not, write to the Free
+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,
+// USA.
+
+// As a special exception, you may use this file as part of a free software
+// library without restriction.  Specifically, if other files instantiate
+// templates or use macros or inline functions from this file, or you compile
+// this file and link it with other files to produce an executable, this
+// file does not by itself cause the resulting executable to be covered by
+// the GNU General Public License.  This exception does not however
+// invalidate any other reasons why the executable file might be covered by
+// the GNU General Public License.
+
+#ifndef _GLIBCPP_CPU_LIMITS
+#define _GLIBCPP_CPU_LIMITS 1
+
+#ifdef __x86_64__
+#define __glibcpp_long_bits 64
+#endif
+
+#define __glibcpp_long_double_bits 80
+
+#endif
--- libstdc++33-v3/libio/Makefile.in.jj	2003-03-17 14:07:38.000000000 -0500
+++ libstdc++33-v3/libio/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/include/std/std_limits.h.jj	2002-12-19 06:44:30.000000000 -0500
+++ libstdc++33-v3/include/std/std_limits.h	2004-10-14 12:51:05.000000000 -0400
@@ -45,6 +45,1898 @@
 
 #pragma GCC system_header
 
+#if __GNUC__ < 3 || (__GNUC__ == 3 && __GNUC_MINOR__ <= 2)
+
+#include <bits/cpu_limits.h>
+#include <bits/c++config.h>
+
+//
+// The numeric_limits<> traits document implementation-defined aspects
+// of fundamental arithmetic data types (integers and floating points).
+// From Standard C++ point of view, there are 13 such types:
+//   * integers
+//         bool						        (1)
+//         char, signed char, unsigned char			(3)
+//         short, unsigned short				(2)
+//         int, unsigned					(2)
+//         long, unsigned long					(2)
+//
+//   * floating points
+//         float						(1)
+//         double						(1)
+//         long double						(1)
+//
+// GNU C++ undertstands (where supported by the host C-library) 
+//   * integer
+//         long long, unsigned long long			(2)
+//
+// which brings us to 15 fundamental arithmetic data types in GNU C++.
+//
+// 
+// Since a numeric_limits<> is a bit tricky to get right, we rely on
+// an interface composed of macros which should be defined in config/os
+// or config/cpu when they differ from the generic (read arbitrary)
+// definitions given here.
+//
+
+// These values can be overridden in the target configuration file.
+// The default values are appropriate for many 32-bit targets.
+
+#ifndef __glibcpp_char_bits
+#define __glibcpp_char_bits 8
+#endif
+#ifdef __CHAR_UNSIGNED__
+#define __glibcpp_plain_char_is_signed false
+#else
+#define __glibcpp_plain_char_is_signed true
+#endif
+#ifndef __glibcpp_short_bits
+#define __glibcpp_short_bits 16
+#endif
+#ifndef __glibcpp_int_bits
+#define __glibcpp_int_bits 32
+#endif
+#ifndef __glibcpp_long_bits
+#define __glibcpp_long_bits 32
+#endif
+#ifndef __glibcpp_wchar_t_bits
+#define __glibcpp_wchar_t_bits 32
+#endif
+#ifndef __glibcpp_wchar_t_is_signed
+#define __glibcpp_wchar_t_is_signed true
+#endif
+#ifndef __glibcpp_long_long_bits
+#define __glibcpp_long_long_bits 64
+#endif
+#ifndef __glibcpp_float_bits
+#define __glibcpp_float_bits 32
+#endif
+#ifndef __glibcpp_double_bits
+#define __glibcpp_double_bits 64
+#endif
+#ifndef __glibcpp_long_double_bits
+#define __glibcpp_long_double_bits 128
+#endif
+
+#ifndef __glibcpp_char_traps
+#define __glibcpp_char_traps true
+#endif
+#ifndef __glibcpp_short_traps
+#define __glibcpp_short_traps true
+#endif
+#ifndef __glibcpp_int_traps
+#define __glibcpp_int_traps true
+#endif
+#ifndef __glibcpp_long_traps
+#define __glibcpp_long_traps true
+#endif
+#ifndef __glibcpp_wchar_t_traps
+#define __glibcpp_wchar_t_traps true
+#endif
+#ifndef __glibcpp_long_long_traps
+#define __glibcpp_long_long_traps true
+#endif
+
+// You should not need to define any macros below this point, unless
+// you have a machine with non-standard bit-widths.
+
+// These values are the minimums and maximums for standard data types
+// of common widths.
+
+#define __glibcpp_s8_max 127
+#define __glibcpp_s8_min (-__glibcpp_s8_max - 1)
+#define __glibcpp_s8_digits 7
+#define __glibcpp_s8_digits10 2
+#define __glibcpp_u8_min 0U
+#define __glibcpp_u8_max (__glibcpp_s8_max * 2 + 1)
+#define __glibcpp_u8_digits 8
+#define __glibcpp_u8_digits10 2
+#define __glibcpp_s16_max 32767
+#define __glibcpp_s16_min (-__glibcpp_s16_max - 1)
+#define __glibcpp_s16_digits 15
+#define __glibcpp_s16_digits10 4
+#define __glibcpp_u16_min 0U
+#define __glibcpp_u16_max (__glibcpp_s16_max * 2 + 1)
+#define __glibcpp_u16_digits 16
+#define __glibcpp_u16_digits10 4
+#define __glibcpp_s32_max 2147483647L
+#define __glibcpp_s32_min (-__glibcpp_s32_max - 1)
+#define __glibcpp_s32_digits 31
+#define __glibcpp_s32_digits10 9
+#define __glibcpp_u32_min 0UL
+#define __glibcpp_u32_max (__glibcpp_s32_max * 2U + 1)
+#define __glibcpp_u32_digits 32
+#define __glibcpp_u32_digits10 9
+#define __glibcpp_s64_max 9223372036854775807LL
+#define __glibcpp_s64_min (-__glibcpp_s64_max - 1)
+#define __glibcpp_s64_digits 63
+#define __glibcpp_s64_digits10 18
+#define __glibcpp_u64_min 0ULL
+#define __glibcpp_u64_max (__glibcpp_s64_max * 2ULL + 1)
+#define __glibcpp_u64_digits 64
+#define __glibcpp_u64_digits10 19
+
+#define __glibcpp_f32_min 1.17549435e-38F
+#define __glibcpp_f32_max 3.40282347e+38F
+#define __glibcpp_f32_digits 24
+#define __glibcpp_f32_digits10 6
+#define __glibcpp_f32_radix 2
+#define __glibcpp_f32_epsilon 1.19209290e-07F
+#ifndef __glibcpp_f32_round_error
+#define __glibcpp_f32_round_error 1.0F
+#endif
+#define __glibcpp_f32_min_exponent -125
+#define __glibcpp_f32_min_exponent10 -37
+#define __glibcpp_f32_max_exponent 128
+#define __glibcpp_f32_max_exponent10 38
+#define __glibcpp_f64_min 2.2250738585072014e-308
+#define __glibcpp_f64_max 1.7976931348623157e+308
+#define __glibcpp_f64_digits 53
+#define __glibcpp_f64_digits10 15
+#define __glibcpp_f64_radix 2
+#define __glibcpp_f64_epsilon 2.2204460492503131e-16
+#ifndef __glibcpp_f64_round_error
+#define __glibcpp_f64_round_error 1.0
+#endif
+#define __glibcpp_f64_min_exponent -1021
+#define __glibcpp_f64_min_exponent10 -307
+#define __glibcpp_f64_max_exponent 1024
+#define __glibcpp_f64_max_exponent10 308
+#define __glibcpp_f80_min 3.36210314311209350626e-4932L
+#define __glibcpp_f80_max 1.18973149535723176502e+4932L
+#define __glibcpp_f80_digits 64
+#define __glibcpp_f80_digits10 18
+#define __glibcpp_f80_radix 2
+#define __glibcpp_f80_epsilon 1.08420217248550443401e-19L
+#ifndef __glibcpp_f80_round_error
+#define __glibcpp_f80_round_error 1.0L
+#endif
+#define __glibcpp_f80_min_exponent -16381
+#define __glibcpp_f80_min_exponent10 -4931
+#define __glibcpp_f80_max_exponent 16384
+#define __glibcpp_f80_max_exponent10 4932
+#define __glibcpp_f96_min 1.68105157155604675313e-4932L
+#define __glibcpp_f96_max 1.18973149535723176502e+4932L
+#define __glibcpp_f96_digits 64
+#define __glibcpp_f96_digits10 18
+#define __glibcpp_f96_radix 2
+#define __glibcpp_f96_epsilon 1.08420217248550443401e-19L
+#ifndef __glibcpp_f96_round_error
+#define __glibcpp_f96_round_error 1.0L
+#endif
+#define __glibcpp_f96_min_exponent -16382
+#define __glibcpp_f96_min_exponent10 -4931
+#define __glibcpp_f96_max_exponent 16384
+#define __glibcpp_f96_max_exponent10 4932
+#define __glibcpp_f128_min 3.362103143112093506262677817321752603E-4932L
+#define __glibcpp_f128_max 1.189731495357231765085759326628007016E+4932L
+#define __glibcpp_f128_digits 113
+#define __glibcpp_f128_digits10 33
+#define __glibcpp_f128_radix 2
+#define __glibcpp_f128_epsilon 1.925929944387235853055977942584927319E-34L
+#ifndef __glibcpp_f128_round_error
+#define __glibcpp_f128_round_error 1.0L
+#endif
+#define __glibcpp_f128_min_exponent -16381
+#define __glibcpp_f128_min_exponent10 -4931
+#define __glibcpp_f128_max_exponent 16384
+#define __glibcpp_f128_max_exponent10 4932
+
+// bool-specific hooks:
+//     __glibcpp_bool_digits  __glibcpp_int_traps __glibcpp_long_traps
+
+#ifndef __glibcpp_bool_digits
+#define __glibcpp_bool_digits 1
+#endif
+
+// char.
+
+#define __glibcpp_plain_char_traps true
+#define __glibcpp_signed_char_traps true
+#define __glibcpp_unsigned_char_traps true
+#ifndef __glibcpp_char_is_modulo
+#define __glibcpp_char_is_modulo true
+#endif
+#ifndef __glibcpp_signed_char_is_modulo
+#define __glibcpp_signed_char_is_modulo true
+#endif
+#if __glibcpp_char_bits == 8
+#define __glibcpp_signed_char_min __glibcpp_s8_min
+#define __glibcpp_signed_char_max __glibcpp_s8_max
+#define __glibcpp_signed_char_digits __glibcpp_s8_digits
+#define __glibcpp_signed_char_digits10 __glibcpp_s8_digits10
+#define __glibcpp_unsigned_char_min __glibcpp_u8_min
+#define __glibcpp_unsigned_char_max __glibcpp_u8_max
+#define __glibcpp_unsigned_char_digits __glibcpp_u8_digits
+#define __glibcpp_unsigned_char_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_char_bits == 16
+#define __glibcpp_signed_char_min __glibcpp_s16_min
+#define __glibcpp_signed_char_max __glibcpp_s16_max
+#define __glibcpp_signed_char_digits __glibcpp_s16_digits
+#define __glibcpp_signed_char_digits10 __glibcpp_s16_digits10
+#define __glibcpp_unsigned_char_min __glibcpp_u16_min
+#define __glibcpp_unsigned_char_max __glibcpp_u16_max
+#define __glibcpp_unsigned_char_digits __glibcpp_u16_digits
+#define __glibcpp_unsigned_char_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_char_bits == 32
+#define __glibcpp_signed_char_min (signed char)__glibcpp_s32_min
+#define __glibcpp_signed_char_max (signed char)__glibcpp_s32_max
+#define __glibcpp_signed_char_digits __glibcpp_s32_digits
+#define __glibcpp_signed_char_digits10 __glibcpp_s32_digits10
+#define __glibcpp_unsigned_char_min (unsigned char)__glibcpp_u32_min
+#define __glibcpp_unsigned_char_max (unsigned char)__glibcpp_u32_max
+#define __glibcpp_unsigned_char_digits __glibcpp_u32_digits
+#define __glibcpp_unsigned_char_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_char_bits == 64
+#define __glibcpp_signed_char_min (signed char)__glibcpp_s64_min
+#define __glibcpp_signed_char_max (signed char)__glibcpp_s64_max
+#define __glibcpp_signed_char_digits __glibcpp_s64_digits
+#define __glibcpp_signed_char_digits10 __glibcpp_s64_digits10
+#define __glibcpp_unsigned_char_min (unsigned char)__glibcpp_u64_min
+#define __glibcpp_unsigned_char_max (unsigned char)__glibcpp_u64_max
+#define __glibcpp_unsigned_char_digits __glibcpp_u64_digits
+#define __glibcpp_unsigned_char_digits10 __glibcpp_u64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+#if __glibcpp_plain_char_is_signed
+#define __glibcpp_char_min (char)__glibcpp_signed_char_min
+#define __glibcpp_char_max (char)__glibcpp_signed_char_max
+#define __glibcpp_char_digits __glibcpp_signed_char_digits
+#define __glibcpp_char_digits10 __glibcpp_signed_char_digits10
+#else
+#define __glibcpp_char_min (char)__glibcpp_unsigned_char_min
+#define __glibcpp_char_max (char)__glibcpp_unsigned_char_max
+#define __glibcpp_char_digits __glibcpp_unsigned_char_digits
+#define __glibcpp_char_digits10 __glibcpp_unsigned_char_digits10
+#endif
+
+// short
+
+#define __glibcpp_signed_short_traps true
+#define __glibcpp_unsigned_short_traps true
+#ifndef __glibcpp_signed_short_is_modulo
+#define __glibcpp_signed_short_is_modulo true
+#endif
+#if __glibcpp_short_bits == 8
+#define __glibcpp_signed_short_min __glibcpp_s8_min
+#define __glibcpp_signed_short_max __glibcpp_s8_max
+#define __glibcpp_signed_short_digits __glibcpp_s8_digits
+#define __glibcpp_signed_short_digits10 __glibcpp_s8_digits10
+#define __glibcpp_unsigned_short_min __glibcpp_u8_min
+#define __glibcpp_unsigned_short_max __glibcpp_u8_max
+#define __glibcpp_unsigned_short_digits __glibcpp_u8_digits
+#define __glibcpp_unsigned_short_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_short_bits == 16
+#define __glibcpp_signed_short_min __glibcpp_s16_min
+#define __glibcpp_signed_short_max __glibcpp_s16_max
+#define __glibcpp_signed_short_digits __glibcpp_s16_digits
+#define __glibcpp_signed_short_digits10 __glibcpp_s16_digits10
+#define __glibcpp_unsigned_short_min __glibcpp_u16_min
+#define __glibcpp_unsigned_short_max __glibcpp_u16_max
+#define __glibcpp_unsigned_short_digits __glibcpp_u16_digits
+#define __glibcpp_unsigned_short_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_short_bits == 32
+#define __glibcpp_signed_short_min (short)__glibcpp_s32_min
+#define __glibcpp_signed_short_max (short)__glibcpp_s32_max
+#define __glibcpp_signed_short_digits __glibcpp_s32_digits
+#define __glibcpp_signed_short_digits10 __glibcpp_s32_digits10
+#define __glibcpp_unsigned_short_min (unsigned short)__glibcpp_u32_min
+#define __glibcpp_unsigned_short_max (unsigned short)__glibcpp_u32_max
+#define __glibcpp_unsigned_short_digits __glibcpp_u32_digits
+#define __glibcpp_unsigned_short_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_short_bits == 64
+#define __glibcpp_signed_short_min (short)__glibcpp_s64_min
+#define __glibcpp_signed_short_max (short)__glibcpp_s64_max
+#define __glibcpp_signed_short_digits __glibcpp_s64_digits
+#define __glibcpp_signed_short_digits10 __glibcpp_s64_digits10
+#define __glibcpp_unsigned_short_min (unsigned short)__glibcpp_u64_min
+#define __glibcpp_unsigned_short_max (unsigned short)__glibcpp_u64_max
+#define __glibcpp_unsigned_short_digits __glibcpp_u64_digits
+#define __glibcpp_unsigned_short_digits10 __glibcpp_u64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// int
+
+#define __glibcpp_signed_int_traps true
+#define __glibcpp_unsigned_int_traps true
+#ifndef __glibcpp_signed_int_is_modulo
+#define __glibcpp_signed_int_is_modulo true
+#endif
+#if __glibcpp_int_bits == 8
+#define __glibcpp_signed_int_min __glibcpp_s8_min
+#define __glibcpp_signed_int_max __glibcpp_s8_max
+#define __glibcpp_signed_int_digits __glibcpp_s8_digits
+#define __glibcpp_signed_int_digits10 __glibcpp_s8_digits10
+#define __glibcpp_unsigned_int_min __glibcpp_u8_min
+#define __glibcpp_unsigned_int_max __glibcpp_u8_max
+#define __glibcpp_unsigned_int_digits __glibcpp_u8_digits
+#define __glibcpp_unsigned_int_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_int_bits == 16
+#define __glibcpp_signed_int_min __glibcpp_s16_min
+#define __glibcpp_signed_int_max __glibcpp_s16_max
+#define __glibcpp_signed_int_digits __glibcpp_s16_digits
+#define __glibcpp_signed_int_digits10 __glibcpp_s16_digits10
+#define __glibcpp_unsigned_int_min __glibcpp_u16_min
+#define __glibcpp_unsigned_int_max __glibcpp_u16_max
+#define __glibcpp_unsigned_int_digits __glibcpp_u16_digits
+#define __glibcpp_unsigned_int_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_int_bits == 32
+#define __glibcpp_signed_int_min (int)__glibcpp_s32_min
+#define __glibcpp_signed_int_max (int)__glibcpp_s32_max
+#define __glibcpp_signed_int_digits __glibcpp_s32_digits
+#define __glibcpp_signed_int_digits10 __glibcpp_s32_digits10
+#define __glibcpp_unsigned_int_min (unsigned)__glibcpp_u32_min
+#define __glibcpp_unsigned_int_max (unsigned)__glibcpp_u32_max
+#define __glibcpp_unsigned_int_digits __glibcpp_u32_digits
+#define __glibcpp_unsigned_int_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_int_bits == 64
+#define __glibcpp_signed_int_min (int)__glibcpp_s64_min
+#define __glibcpp_signed_int_max (int)__glibcpp_s64_max
+#define __glibcpp_signed_int_digits __glibcpp_s64_digits
+#define __glibcpp_signed_int_digits10 __glibcpp_s64_digits10
+#define __glibcpp_unsigned_int_min (unsigned)__glibcpp_u64_min
+#define __glibcpp_unsigned_int_max (unsigned)__glibcpp_u64_max
+#define __glibcpp_unsigned_int_digits __glibcpp_u64_digits
+#define __glibcpp_unsigned_int_digits10 __glibcpp_u64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// long
+
+#define __glibcpp_signed_long_traps true
+#define __glibcpp_unsigned_long_traps true
+#ifndef __glibcpp_signed_long_is_modulo
+#define __glibcpp_signed_long_is_modulo true
+#endif
+#if __glibcpp_long_bits == 8
+#define __glibcpp_signed_long_min __glibcpp_s8_min
+#define __glibcpp_signed_long_max __glibcpp_s8_max
+#define __glibcpp_signed_long_digits __glibcpp_s8_digits
+#define __glibcpp_signed_long_digits10 __glibcpp_s8_digits10
+#define __glibcpp_unsigned_long_min __glibcpp_u8_min
+#define __glibcpp_unsigned_long_max __glibcpp_u8_max
+#define __glibcpp_unsigned_long_digits __glibcpp_u8_digits
+#define __glibcpp_unsigned_long_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_long_bits == 16
+#define __glibcpp_signed_long_min __glibcpp_s16_min
+#define __glibcpp_signed_long_max __glibcpp_s16_max
+#define __glibcpp_signed_long_digits __glibcpp_s16_digits
+#define __glibcpp_signed_long_digits10 __glibcpp_s16_digits10
+#define __glibcpp_unsigned_long_min __glibcpp_u16_min
+#define __glibcpp_unsigned_long_max __glibcpp_u16_max
+#define __glibcpp_unsigned_long_digits __glibcpp_u16_digits
+#define __glibcpp_unsigned_long_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_long_bits == 32
+#define __glibcpp_signed_long_min __glibcpp_s32_min
+#define __glibcpp_signed_long_max __glibcpp_s32_max
+#define __glibcpp_signed_long_digits __glibcpp_s32_digits
+#define __glibcpp_signed_long_digits10 __glibcpp_s32_digits10
+#define __glibcpp_unsigned_long_min __glibcpp_u32_min
+#define __glibcpp_unsigned_long_max __glibcpp_u32_max
+#define __glibcpp_unsigned_long_digits __glibcpp_u32_digits
+#define __glibcpp_unsigned_long_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_long_bits == 64
+#define __glibcpp_signed_long_min (long)__glibcpp_s64_min
+#define __glibcpp_signed_long_max (long)__glibcpp_s64_max
+#define __glibcpp_signed_long_digits __glibcpp_s64_digits
+#define __glibcpp_signed_long_digits10 __glibcpp_s64_digits10
+#define __glibcpp_unsigned_long_min (unsigned long)__glibcpp_u64_min
+#define __glibcpp_unsigned_long_max (unsigned long)__glibcpp_u64_max
+#define __glibcpp_unsigned_long_digits __glibcpp_u64_digits
+#define __glibcpp_unsigned_long_digits10 __glibcpp_u64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// long long
+
+#define __glibcpp_signed_long_long_traps true
+#define __glibcpp_signed_long_long_traps true
+#ifndef __glibcpp_signed_long_long_is_modulo
+#define __glibcpp_signed_long_long_is_modulo true
+#endif
+#if __glibcpp_long_long_bits == 8
+#define __glibcpp_signed_long_long_min __glibcpp_s8_min
+#define __glibcpp_signed_long_long_max __glibcpp_s8_max
+#define __glibcpp_signed_long_long_digits __glibcpp_s8_digits
+#define __glibcpp_signed_long_long_digits10 __glibcpp_s8_digits10
+#define __glibcpp_unsigned_long_long_min __glibcpp_u8_min
+#define __glibcpp_unsigned_long_long_max __glibcpp_u8_max
+#define __glibcpp_unsigned_long_long_digits __glibcpp_u8_digits
+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_long_long_bits == 16
+#define __glibcpp_signed_long_long_min __glibcpp_s16_min
+#define __glibcpp_signed_long_long_max __glibcpp_s16_max
+#define __glibcpp_signed_long_long_digits __glibcpp_s16_digits
+#define __glibcpp_signed_long_long_digits10 __glibcpp_s16_digits10
+#define __glibcpp_unsigned_long_long_min __glibcpp_u16_min
+#define __glibcpp_unsigned_long_long_max __glibcpp_u16_max
+#define __glibcpp_unsigned_long_long_digits __glibcpp_u16_digits
+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_long_long_bits == 32
+#define __glibcpp_signed_long_long_min __glibcpp_s32_min
+#define __glibcpp_signed_long_long_max __glibcpp_s32_max
+#define __glibcpp_signed_long_long_digits __glibcpp_s32_digits
+#define __glibcpp_signed_long_long_digits10 __glibcpp_s32_digits10
+#define __glibcpp_unsigned_long_long_min __glibcpp_u32_min
+#define __glibcpp_unsigned_long_long_max __glibcpp_u32_max
+#define __glibcpp_unsigned_long_long_digits __glibcpp_u32_digits
+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_long_long_bits == 64
+#define __glibcpp_signed_long_long_min __glibcpp_s64_min
+#define __glibcpp_signed_long_long_max __glibcpp_s64_max
+#define __glibcpp_signed_long_long_digits __glibcpp_s64_digits
+#define __glibcpp_signed_long_long_digits10 __glibcpp_s64_digits10
+#define __glibcpp_signed_long_long_traps true
+#define __glibcpp_unsigned_long_long_min __glibcpp_u64_min
+#define __glibcpp_unsigned_long_long_max __glibcpp_u64_max
+#define __glibcpp_unsigned_long_long_digits __glibcpp_u64_digits
+#define __glibcpp_unsigned_long_long_digits10 __glibcpp_u64_digits10
+#define __glibcpp_unsigned_long_long_traps true
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// wchar_t
+
+#define __glibcpp_wchar_t_traps true
+#ifndef __glibcpp_wchar_t_is_modulo
+#define __glibcpp_wchar_t_is_modulo true
+#endif
+#if __glibcpp_wchar_t_is_signed
+#if __glibcpp_wchar_t_bits == 8
+#define __glibcpp_wchar_t_min __glibcpp_s8_min
+#define __glibcpp_wchar_t_max __glibcpp_s8_max
+#define __glibcpp_wchar_t_digits __glibcpp_s8_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_s8_digits10
+#elif __glibcpp_wchar_t_bits == 16
+#define __glibcpp_wchar_t_min __glibcpp_s16_min
+#define __glibcpp_wchar_t_max __glibcpp_s16_max
+#define __glibcpp_wchar_t_digits __glibcpp_s16_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_s16_digits10
+#elif __glibcpp_wchar_t_bits == 32
+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_s32_min
+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_s32_max
+#define __glibcpp_wchar_t_digits __glibcpp_s32_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_s32_digits10
+#elif __glibcpp_wchar_t_bits == 64
+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_s64_min
+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_s64_max
+#define __glibcpp_wchar_t_digits __glibcpp_s64_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_s64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+#else
+#if __glibcpp_wchar_t_bits == 8
+#define __glibcpp_wchar_t_min __glibcpp_u8_min
+#define __glibcpp_wchar_t_max __glibcpp_u8_max
+#define __glibcpp_wchar_t_digits __glibcpp_u8_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_u8_digits10
+#elif __glibcpp_wchar_t_bits == 16
+#define __glibcpp_wchar_t_min __glibcpp_u16_min
+#define __glibcpp_wchar_t_max __glibcpp_u16_max
+#define __glibcpp_wchar_t_digits __glibcpp_u16_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_u16_digits10
+#elif __glibcpp_wchar_t_bits == 32
+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_u32_min
+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_u32_max
+#define __glibcpp_wchar_t_digits __glibcpp_u32_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_u32_digits10
+#elif __glibcpp_wchar_t_bits == 64
+#define __glibcpp_wchar_t_min (wchar_t)__glibcpp_u64_min
+#define __glibcpp_wchar_t_max (wchar_t)__glibcpp_u64_max
+#define __glibcpp_wchar_t_digits __glibcpp_u64_digits
+#define __glibcpp_wchar_t_digits10 __glibcpp_u64_digits10
+#else
+// You must define these macros in the configuration file.
+#endif
+#endif
+
+// float
+//
+
+#if __glibcpp_float_bits == 32
+#define __glibcpp_float_min __glibcpp_f32_min
+#define __glibcpp_float_max __glibcpp_f32_max
+#define __glibcpp_float_digits __glibcpp_f32_digits
+#define __glibcpp_float_digits10 __glibcpp_f32_digits10
+#define __glibcpp_float_radix __glibcpp_f32_radix
+#define __glibcpp_float_epsilon __glibcpp_f32_epsilon
+#define __glibcpp_float_round_error __glibcpp_f32_round_error
+#define __glibcpp_float_min_exponent __glibcpp_f32_min_exponent
+#define __glibcpp_float_min_exponent10 __glibcpp_f32_min_exponent10
+#define __glibcpp_float_max_exponent __glibcpp_f32_max_exponent
+#define __glibcpp_float_max_exponent10 __glibcpp_f32_max_exponent10
+#elif __glibcpp_float_bits == 64
+#define __glibcpp_float_min __glibcpp_f64_min
+#define __glibcpp_float_max __glibcpp_f64_max
+#define __glibcpp_float_digits __glibcpp_f64_digits
+#define __glibcpp_float_digits10 __glibcpp_f64_digits10
+#define __glibcpp_float_radix __glibcpp_f64_radix
+#define __glibcpp_float_epsilon __glibcpp_f64_epsilon
+#define __glibcpp_float_round_error __glibcpp_f64_round_error
+#define __glibcpp_float_min_exponent __glibcpp_f64_min_exponent
+#define __glibcpp_float_min_exponent10 __glibcpp_f64_min_exponent10
+#define __glibcpp_float_max_exponent __glibcpp_f64_max_exponent
+#define __glibcpp_float_max_exponent10 __glibcpp_f64_max_exponent10
+#elif __glibcpp_float_bits == 80
+#define __glibcpp_float_min __glibcpp_f80_min
+#define __glibcpp_float_max __glibcpp_f80_max
+#define __glibcpp_float_digits __glibcpp_f80_digits
+#define __glibcpp_float_digits10 __glibcpp_f80_digits10
+#define __glibcpp_float_radix __glibcpp_f80_radix
+#define __glibcpp_float_epsilon __glibcpp_f80_epsilon
+#define __glibcpp_float_round_error __glibcpp_f80_round_error
+#define __glibcpp_float_min_exponent __glibcpp_f80_min_exponent
+#define __glibcpp_float_min_exponent10 __glibcpp_f80_min_exponent10
+#define __glibcpp_float_max_exponent __glibcpp_f80_max_exponent
+#define __glibcpp_float_max_exponent10 __glibcpp_f80_max_exponent10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// FIXME: These are just stubs and inkorrect
+
+#ifndef __glibcpp_float_has_infinity
+#define __glibcpp_float_has_infinity false
+#endif
+
+#ifndef __glibcpp_float_has_quiet_NaN
+#define __glibcpp_float_has_quiet_NaN false
+#endif
+
+#ifndef __glibcpp_float_has_signaling_NaN
+#define __glibcpp_float_has_signaling_NaN false
+#endif
+
+#ifndef __glibcpp_float_has_denorm
+#define __glibcpp_float_has_denorm denorm_absent
+#endif
+
+#ifndef __glibcpp_float_has_denorm_loss
+#define __glibcpp_float_has_denorm_loss false
+#endif
+
+#ifndef __glibcpp_float_infinity
+#define __glibcpp_float_infinity 0.0F
+#endif
+
+#ifndef __glibcpp_float_quiet_NaN
+#define __glibcpp_float_quiet_NaN 0.0F
+#endif
+
+#ifndef __glibcpp_float_signaling_NaN
+#define __glibcpp_float_signaling_NaN 0.0F
+#endif
+
+#ifndef __glibcpp_float_denorm_min
+#define __glibcpp_float_denorm_min 0.0F
+#endif
+
+#ifndef __glibcpp_float_is_iec559
+#define __glibcpp_float_is_iec559 false
+#endif
+
+#ifndef __glibcpp_float_is_bounded
+#define __glibcpp_float_is_bounded true
+#endif
+
+#ifndef __glibcpp_float_is_modulo
+#define __glibcpp_float_is_modulo false
+#endif
+
+#ifndef __glibcpp_float_traps
+#define __glibcpp_float_traps false
+#endif
+
+#ifndef __glibcpp_float_tinyness_before
+#define __glibcpp_float_tinyness_before false
+#endif
+
+#ifndef __glibcpp_float_round_style
+#define __glibcpp_float_round_style round_toward_zero
+#endif
+
+// double
+
+#if __glibcpp_double_bits == 32
+#define __glibcpp_double_min __glibcpp_f32_min
+#define __glibcpp_double_max __glibcpp_f32_max
+#define __glibcpp_double_digits __glibcpp_f32_digits
+#define __glibcpp_double_digits10 __glibcpp_f32_digits10
+#define __glibcpp_double_radix __glibcpp_f32_radix
+#define __glibcpp_double_epsilon __glibcpp_f32_epsilon
+#define __glibcpp_double_round_error __glibcpp_f32_round_error
+#define __glibcpp_double_min_exponent __glibcpp_f32_min_exponent
+#define __glibcpp_double_min_exponent10 __glibcpp_f32_min_exponent10
+#define __glibcpp_double_max_exponent __glibcpp_f32_max_exponent
+#define __glibcpp_double_max_exponent10 __glibcpp_f32_max_exponent10
+#elif __glibcpp_double_bits == 64
+#define __glibcpp_double_min __glibcpp_f64_min
+#define __glibcpp_double_max __glibcpp_f64_max
+#define __glibcpp_double_digits __glibcpp_f64_digits
+#define __glibcpp_double_digits10 __glibcpp_f64_digits10
+#define __glibcpp_double_radix __glibcpp_f64_radix
+#define __glibcpp_double_epsilon __glibcpp_f64_epsilon
+#define __glibcpp_double_round_error __glibcpp_f64_round_error
+#define __glibcpp_double_min_exponent __glibcpp_f64_min_exponent
+#define __glibcpp_double_min_exponent10 __glibcpp_f64_min_exponent10
+#define __glibcpp_double_max_exponent __glibcpp_f64_max_exponent
+#define __glibcpp_double_max_exponent10 __glibcpp_f64_max_exponent10
+#elif __glibcpp_double_bits == 80
+#define __glibcpp_double_min __glibcpp_f80_min
+#define __glibcpp_double_max __glibcpp_f80_max
+#define __glibcpp_double_digits __glibcpp_f80_digits
+#define __glibcpp_double_digits10 __glibcpp_f80_digits10
+#define __glibcpp_double_radix __glibcpp_f80_radix
+#define __glibcpp_double_epsilon __glibcpp_f80_epsilon
+#define __glibcpp_double_round_error __glibcpp_f80_round_error
+#define __glibcpp_double_min_exponent __glibcpp_f80_min_exponent
+#define __glibcpp_double_min_exponent10 __glibcpp_f80_min_exponent10
+#define __glibcpp_double_max_exponent __glibcpp_f80_max_exponent
+#define __glibcpp_double_max_exponent10 __glibcpp_f80_max_exponent10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// FIXME: These are just stubs and inkorrect
+
+#ifndef __glibcpp_double_has_infinity
+#define __glibcpp_double_has_infinity false
+#endif
+
+#ifndef __glibcpp_double_has_quiet_NaN
+#define __glibcpp_double_has_quiet_NaN false
+#endif
+
+#ifndef __glibcpp_double_has_signaling_NaN
+#define __glibcpp_double_has_signaling_NaN false
+#endif
+
+#ifndef __glibcpp_double_has_denorm
+#define __glibcpp_double_has_denorm denorm_absent
+#endif
+
+#ifndef __glibcpp_double_has_denorm_loss
+#define __glibcpp_double_has_denorm_loss false
+#endif
+
+#ifndef __glibcpp_double_infinity
+#define __glibcpp_double_infinity 0.0
+#endif
+
+#ifndef __glibcpp_double_quiet_NaN
+#define __glibcpp_double_quiet_NaN 0.0
+#endif
+
+#ifndef __glibcpp_double_signaling_NaN
+#define __glibcpp_double_signaling_NaN 0.0
+#endif
+
+#ifndef __glibcpp_double_denorm_min
+#define __glibcpp_double_denorm_min 0.0
+#endif
+
+#ifndef __glibcpp_double_is_iec559
+#define __glibcpp_double_is_iec559 false
+#endif
+
+#ifndef __glibcpp_double_is_bounded
+#define __glibcpp_double_is_bounded true
+#endif
+
+#ifndef __glibcpp_double_is_modulo
+#define __glibcpp_double_is_modulo false
+#endif
+
+#ifndef __glibcpp_double_traps
+#define __glibcpp_double_traps false
+#endif
+
+#ifndef __glibcpp_double_tinyness_before
+#define __glibcpp_double_tinyness_before false
+#endif
+
+#ifndef __glibcpp_double_round_style
+#define __glibcpp_double_round_style round_toward_zero
+#endif
+
+// long double
+
+#if __glibcpp_long_double_bits == 32
+#define __glibcpp_long_double_min __glibcpp_f32_min
+#define __glibcpp_long_double_max __glibcpp_f32_max
+#define __glibcpp_long_double_digits __glibcpp_f32_digits
+#define __glibcpp_long_double_digits10 __glibcpp_f32_digits10
+#define __glibcpp_long_double_radix __glibcpp_f32_radix
+#define __glibcpp_long_double_epsilon __glibcpp_f32_epsilon
+#define __glibcpp_long_double_round_error __glibcpp_f32_round_error
+#define __glibcpp_long_double_min_exponent __glibcpp_f32_min_exponent
+#define __glibcpp_long_double_min_exponent10 __glibcpp_f32_min_exponent10
+#define __glibcpp_long_double_max_exponent __glibcpp_f32_max_exponent
+#define __glibcpp_long_double_max_exponent10 __glibcpp_f32_max_exponent10
+#elif __glibcpp_long_double_bits == 64
+#define __glibcpp_long_double_min __glibcpp_f64_min
+#define __glibcpp_long_double_max __glibcpp_f64_max
+#define __glibcpp_long_double_digits __glibcpp_f64_digits
+#define __glibcpp_long_double_digits10 __glibcpp_f64_digits10
+#define __glibcpp_long_double_radix __glibcpp_f64_radix
+#define __glibcpp_long_double_epsilon __glibcpp_f64_epsilon
+#define __glibcpp_long_double_round_error __glibcpp_f64_round_error
+#define __glibcpp_long_double_min_exponent __glibcpp_f64_min_exponent
+#define __glibcpp_long_double_min_exponent10 __glibcpp_f64_min_exponent10
+#define __glibcpp_long_double_max_exponent __glibcpp_f64_max_exponent
+#define __glibcpp_long_double_max_exponent10 __glibcpp_f64_max_exponent10
+#elif __glibcpp_long_double_bits == 80
+#define __glibcpp_long_double_min __glibcpp_f80_min
+#define __glibcpp_long_double_max __glibcpp_f80_max
+#define __glibcpp_long_double_digits __glibcpp_f80_digits
+#define __glibcpp_long_double_digits10 __glibcpp_f80_digits10
+#define __glibcpp_long_double_radix __glibcpp_f80_radix
+#define __glibcpp_long_double_epsilon __glibcpp_f80_epsilon
+#define __glibcpp_long_double_round_error __glibcpp_f80_round_error
+#define __glibcpp_long_double_min_exponent __glibcpp_f80_min_exponent
+#define __glibcpp_long_double_min_exponent10 __glibcpp_f80_min_exponent10
+#define __glibcpp_long_double_max_exponent __glibcpp_f80_max_exponent
+#define __glibcpp_long_double_max_exponent10 __glibcpp_f80_max_exponent10
+#elif __glibcpp_long_double_bits == 96
+#define __glibcpp_long_double_min __glibcpp_f96_min
+#define __glibcpp_long_double_max __glibcpp_f96_max
+#define __glibcpp_long_double_digits __glibcpp_f96_digits
+#define __glibcpp_long_double_digits10 __glibcpp_f96_digits10
+#define __glibcpp_long_double_radix __glibcpp_f96_radix
+#define __glibcpp_long_double_epsilon __glibcpp_f96_epsilon
+#define __glibcpp_long_double_round_error __glibcpp_f96_round_error
+#define __glibcpp_long_double_min_exponent __glibcpp_f96_min_exponent
+#define __glibcpp_long_double_min_exponent10 __glibcpp_f96_min_exponent10
+#define __glibcpp_long_double_max_exponent __glibcpp_f96_max_exponent
+#define __glibcpp_long_double_max_exponent10 __glibcpp_f96_max_exponent10
+#elif __glibcpp_long_double_bits == 128
+#define __glibcpp_long_double_min __glibcpp_f128_min
+#define __glibcpp_long_double_max __glibcpp_f128_max
+#define __glibcpp_long_double_digits __glibcpp_f128_digits
+#define __glibcpp_long_double_digits10 __glibcpp_f128_digits10
+#define __glibcpp_long_double_radix __glibcpp_f128_radix
+#define __glibcpp_long_double_epsilon __glibcpp_f128_epsilon
+#define __glibcpp_long_double_round_error __glibcpp_f128_round_error
+#define __glibcpp_long_double_min_exponent __glibcpp_f128_min_exponent
+#define __glibcpp_long_double_min_exponent10 __glibcpp_f128_min_exponent10
+#define __glibcpp_long_double_max_exponent __glibcpp_f128_max_exponent
+#define __glibcpp_long_double_max_exponent10 __glibcpp_f128_max_exponent10
+#else
+// You must define these macros in the configuration file.
+#endif
+
+// FIXME: These are just stubs and inkorrect
+
+#ifndef __glibcpp_long_double_has_infinity
+#define __glibcpp_long_double_has_infinity false
+#endif
+
+#ifndef __glibcpp_long_double_has_quiet_NaN
+#define __glibcpp_long_double_has_quiet_NaN false
+#endif
+
+#ifndef __glibcpp_long_double_has_signaling_NaN
+#define __glibcpp_long_double_has_signaling_NaN false
+#endif
+
+#ifndef __glibcpp_long_double_has_denorm
+#define __glibcpp_long_double_has_denorm denorm_absent
+#endif
+
+#ifndef __glibcpp_long_double_has_denorm_loss
+#define __glibcpp_long_double_has_denorm_loss false
+#endif
+
+#ifndef __glibcpp_long_double_infinity
+#define __glibcpp_long_double_infinity 0.0L
+#endif
+
+#ifndef __glibcpp_long_double_quiet_NaN
+#define __glibcpp_long_double_quiet_NaN 0.0L
+#endif
+
+#ifndef __glibcpp_long_double_signaling_NaN
+#define __glibcpp_long_double_signaling_NaN 0.0L
+#endif
+
+#ifndef __glibcpp_long_double_denorm_min
+#define __glibcpp_long_double_denorm_min 0.0L
+#endif
+
+#ifndef __glibcpp_long_double_is_iec559
+#define __glibcpp_long_double_is_iec559 false
+#endif
+
+#ifndef __glibcpp_long_double_is_bounded
+#define __glibcpp_long_double_is_bounded true
+#endif
+
+#ifndef __glibcpp_long_double_is_modulo
+#define __glibcpp_long_double_is_modulo false
+#endif
+
+#ifndef __glibcpp_long_double_traps
+#define __glibcpp_long_double_traps false
+#endif
+
+#ifndef __glibcpp_long_double_tinyness_before
+#define __glibcpp_long_double_tinyness_before false
+#endif
+
+#ifndef __glibcpp_long_double_round_style
+#define __glibcpp_long_double_round_style round_toward_zero
+#endif
+
+
+namespace std
+{
+  enum float_round_style 
+  {
+    round_indeterminate       = -1,
+    round_toward_zero         = 0,
+    round_to_nearest          = 1,
+    round_toward_infinity     = 2,
+    round_toward_neg_infinity = 3
+  };
+
+  enum float_denorm_style 
+  {
+    denorm_indeterminate = -1,
+    denorm_absent        = 0,
+    denorm_present       = 1
+  };
+
+  //
+  // The primary class traits
+  //
+  struct __numeric_limits_base
+  {
+    static const bool is_specialized = false;
+
+    static const int digits = 0;
+    static const int digits10 = 0;
+    static const bool is_signed = false;
+    static const bool is_integer = false;
+    static const bool is_exact = false;
+    static const int radix = 0;
+
+    static const int min_exponent = 0;
+    static const int min_exponent10 = 0;
+    static const int max_exponent = 0;
+    static const int max_exponent10 = 0;
+    
+    static const bool has_infinity = false;
+    static const bool has_quiet_NaN = false;
+    static const bool has_signaling_NaN = false;
+    static const float_denorm_style has_denorm = denorm_absent;
+    static const bool has_denorm_loss = false;
+
+    static const bool is_iec559 = false;
+    static const bool is_bounded = false;
+    static const bool is_modulo = false;
+
+    static const bool traps = false;
+    static const bool tinyness_before = false;
+    static const float_round_style round_style = round_toward_zero;
+  };
+
+  template<typename _Tp> 
+    struct numeric_limits : public __numeric_limits_base 
+    {
+      static _Tp min() throw() { return static_cast<_Tp>(0); }
+      static _Tp max() throw() { return static_cast<_Tp>(0); }
+      static _Tp epsilon() throw() { return static_cast<_Tp>(0); }
+      static _Tp round_error() throw() { return static_cast<_Tp>(0); }
+      static _Tp infinity() throw()  { return static_cast<_Tp>(0); }
+      static _Tp quiet_NaN() throw() { return static_cast<_Tp>(0); }
+      static _Tp signaling_NaN() throw() { return static_cast<_Tp>(0); }
+      static _Tp denorm_min() throw() { return static_cast<_Tp>(0); }
+    };
+
+  // Now there follow 15 explicit specializations.  Yes, 15.  Make sure
+  // you get the count right.  
+  template<>
+    struct numeric_limits<bool>
+    {
+      static const bool is_specialized = true;
+
+      static bool min() throw()
+      { return false; }
+
+      static bool max() throw()
+      { return true; }
+
+      static const int digits = __glibcpp_bool_digits;
+      static const int digits10 = 0;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static bool epsilon() throw()
+      { return false; }
+      static bool round_error() throw()
+      { return false; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static bool infinity() throw()
+      { return false; }
+      static bool quiet_NaN() throw()
+      { return false; }
+      static bool signaling_NaN() throw()
+      { return false; }
+      static bool denorm_min() throw()
+      { return false; }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = false;
+
+      // It is not clear what it means for a boolean type to trap.
+      // This is a DR on the LWG issue list.  Here, I use integer
+      // promotion semantics.
+      static const bool traps = __glibcpp_signed_int_traps
+               || __glibcpp_signed_long_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_bool_digits  
+  
+  template<>
+    struct numeric_limits<char>
+    {
+      static const bool is_specialized = true;
+
+      static char min() throw()
+      { return __glibcpp_char_min; }
+      static char max() throw()
+      { return __glibcpp_char_max; }
+
+      static const int digits = __glibcpp_char_digits;
+      static const int digits10 = __glibcpp_char_digits10;
+      static const bool is_signed = __glibcpp_plain_char_is_signed;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static char epsilon() throw()
+      { return char(); }
+      static char round_error() throw()
+      { return char(); }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static char infinity() throw()
+      { return char(); }
+      static char quiet_NaN() throw()
+      { return char(); }
+      static char signaling_NaN() throw()
+      { return char(); }
+      static char denorm_min() throw()
+      { return static_cast<char>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_char_is_modulo;
+
+      static const bool traps = __glibcpp_char_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_char_min
+#undef __glibcpp_char_max  
+#undef __glibcpp_char_digits
+#undef __glibcpp_char_digits10
+#undef __glibcpp_char_is_signed
+#undef __glibcpp_char_is_modulo
+#undef __glibcpp_char_traps
+
+
+
+  template<>
+    struct numeric_limits<signed char>
+    {
+      static const bool is_specialized = true;
+
+      static signed char min() throw()
+      { return __glibcpp_signed_char_min; }
+      static signed char max() throw()
+      { return __glibcpp_signed_char_max; }
+
+      static const int digits = __glibcpp_signed_char_digits;
+      static const int digits10 = __glibcpp_signed_char_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static signed char epsilon() throw()
+      { return 0; }
+      static signed char round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static signed char infinity() throw()
+      { return static_cast<signed char>(0); }
+      static signed char quiet_NaN() throw()
+      { return static_cast<signed char>(0); }
+      static signed char signaling_NaN() throw()
+      { return static_cast<signed char>(0); }
+      static signed char denorm_min() throw()
+      { return static_cast<signed char>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_signed_char_is_modulo;
+
+      static const bool traps = __glibcpp_signed_char_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_signed_char_min
+#undef __glibcpp_signed_char_max
+#undef __glibcpp_signed_char_digits
+#undef __glibcpp_signed_char_digits10
+#undef __glibcpp_signed_char_is_modulo  
+#undef __glibcpp_signed_char_traps  
+
+  template<>
+    struct numeric_limits<unsigned char>
+    {
+      static const bool is_specialized = true;
+
+      static unsigned char min() throw()
+      { return 0; }
+      static unsigned char max() throw()
+      { return __glibcpp_unsigned_char_max; }
+
+      static const int digits = __glibcpp_unsigned_char_digits;
+      static const int digits10 = __glibcpp_unsigned_char_digits10;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static unsigned char epsilon() throw()
+      { return 0; }
+      static unsigned char round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static unsigned char infinity() throw()
+      { return static_cast<unsigned char>(0); }
+      static unsigned char quiet_NaN() throw()
+      { return static_cast<unsigned char>(0); }
+      static unsigned char signaling_NaN() throw()
+      { return static_cast<unsigned char>(0); }
+      static unsigned char denorm_min() throw()
+      { return static_cast<unsigned char>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = true;
+
+      static const bool traps = __glibcpp_unsigned_char_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_unsigned_char_max
+#undef __glibcpp_unsigned_char_digits
+#undef __glibcpp_unsigned_char_digits10
+#undef __glibcpp_unsigned_char_traps  
+
+  template<>
+    struct numeric_limits<wchar_t>
+    {
+      static const bool is_specialized = true;
+
+      static wchar_t min() throw()
+      { return __glibcpp_wchar_t_min; }
+      static wchar_t max() throw()
+      { return __glibcpp_wchar_t_max; }
+
+      static const int digits = __glibcpp_wchar_t_digits;
+      static const int digits10 = __glibcpp_wchar_t_digits10;
+      static const bool is_signed = __glibcpp_wchar_t_is_signed;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static wchar_t epsilon() throw()
+      { return 0; }
+      static wchar_t round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static wchar_t infinity() throw()
+      { return wchar_t(); }
+      static wchar_t quiet_NaN() throw()
+      { return wchar_t(); }
+      static wchar_t signaling_NaN() throw()
+      { return wchar_t(); }
+      static wchar_t denorm_min() throw()
+      { return wchar_t(); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_wchar_t_is_modulo;
+
+      static const bool traps = __glibcpp_wchar_t_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_wchar_t_min
+#undef __glibcpp_wchar_t_max
+#undef __glibcpp_wchar_t_digits
+#undef __glibcpp_wchar_t_digits10  
+#undef __glibcpp_wchar_t_is_signed
+#undef __glibcpp_wchar_t_is_modulo
+#undef __glibcpp_wchar_t_traps  
+  
+  template<>
+    struct numeric_limits<short>
+    {
+      static const bool is_specialized = true;
+
+      static short min() throw()
+      { return __glibcpp_signed_short_min; }
+      static short max() throw()
+      { return __glibcpp_signed_short_max; }
+
+      static const int digits = __glibcpp_signed_short_digits;
+      static const int digits10 = __glibcpp_signed_short_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static short epsilon() throw()
+      { return 0; }
+      static short round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static short infinity() throw()
+      { return short(); }
+      static short quiet_NaN() throw()
+      { return short(); }
+      static short signaling_NaN() throw()
+      { return short(); }
+      static short denorm_min() throw()
+      { return short(); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_signed_short_is_modulo;
+
+      static const bool traps = __glibcpp_signed_short_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_signed_short_min
+#undef __glibcpp_signed_short_max
+#undef __glibcpp_signed_short_digits
+#undef __glibcpp_signed_short_digits10
+#undef __glibcpp_signed_short_is_modulo
+#undef __glibcpp_signed_short_traps  
+  
+  template<>
+    struct numeric_limits<unsigned short>
+    {
+      static const bool is_specialized = true;
+
+      static unsigned short min() throw()
+      { return 0; }
+      static unsigned short max() throw()
+      { return __glibcpp_unsigned_short_max; }
+
+      static const int digits = __glibcpp_unsigned_short_digits;
+      static const int digits10 = __glibcpp_unsigned_short_digits10;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static unsigned short epsilon() throw()
+      { return 0; }
+      static unsigned short round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static unsigned short infinity() throw()
+      { return static_cast<unsigned short>(0); }
+      static unsigned short quiet_NaN() throw()
+      { return static_cast<unsigned short>(0); }
+      static unsigned short signaling_NaN() throw()
+      { return static_cast<unsigned short>(0); }
+      static unsigned short denorm_min() throw()
+      { return static_cast<unsigned short>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = true;
+
+      static const bool traps = __glibcpp_unsigned_short_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_unsigned_short_max
+#undef __glibcpp_unsigned_short_digits
+#undef __glibcpp_unsigned_short_digits10
+#undef __glibcpp_unsigned_short_traps  
+  
+  template<>
+    struct numeric_limits<int>
+    {
+      static const bool is_specialized = true;
+
+      static int min() throw()
+      { return __glibcpp_signed_int_min; }
+      static int max() throw()
+      { return __glibcpp_signed_int_max; }
+
+      static const int digits = __glibcpp_signed_int_digits;
+      static const int digits10 = __glibcpp_signed_int_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static int epsilon() throw()
+      { return 0; }
+      static int round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static int infinity() throw()
+      { return static_cast<int>(0); }
+      static int quiet_NaN() throw()
+      { return static_cast<int>(0); }
+      static int signaling_NaN() throw()
+      { return static_cast<int>(0); }
+      static int denorm_min() throw()
+      { return static_cast<int>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_signed_int_is_modulo;
+
+      static const bool traps = __glibcpp_signed_int_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_signed_int_min
+#undef __glibcpp_signed_int_max
+#undef __glibcpp_signed_int_digits
+#undef __glibcpp_signed_int_digits10
+#undef __glibcpp_signed_int_is_modulo
+#undef __glibcpp_signed_int_traps  
+  
+  template<>
+    struct numeric_limits<unsigned int>
+    {
+      static const bool is_specialized = true;
+
+      static unsigned int min() throw()
+      { return 0; }
+          static unsigned int max() throw()
+      { return __glibcpp_unsigned_int_max; }
+
+      static const int digits = __glibcpp_unsigned_int_digits;
+      static const int digits10 = __glibcpp_unsigned_int_digits10;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static unsigned int epsilon() throw()
+      { return 0; }
+      static unsigned int round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static unsigned int infinity() throw()
+      { return static_cast<unsigned int>(0); }
+      static unsigned int quiet_NaN() throw()
+      { return static_cast<unsigned int>(0); }
+      static unsigned int signaling_NaN() throw()
+      { return static_cast<unsigned int>(0); }
+      static unsigned int denorm_min() throw()
+      { return static_cast<unsigned int>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = true;
+
+      static const bool traps = __glibcpp_unsigned_int_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_unsigned_int_max
+#undef __glibcpp_unsigned_int_digits
+#undef __glibcpp_unsigned_int_digits10
+#undef __glibcpp_unsigned_int_traps  
+
+  template<>
+    struct numeric_limits<long>
+    {
+      static const bool is_specialized = true;
+
+      static long min() throw()
+      { return __glibcpp_signed_long_min; }
+      static long max() throw()
+      { return __glibcpp_signed_long_max; }
+
+      static const int digits = __glibcpp_signed_long_digits;
+      static const int digits10 = __glibcpp_signed_long_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static long epsilon() throw()
+      { return 0; }
+      static long round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static long infinity() throw()
+      { return static_cast<long>(0); }
+      static long quiet_NaN() throw()
+      { return static_cast<long>(0); }
+      static long signaling_NaN() throw()
+      { return static_cast<long>(0); }
+      static long denorm_min() throw()
+      { return static_cast<long>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_signed_long_is_modulo;
+
+      static const bool traps = __glibcpp_signed_long_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_signed_long_min
+#undef __glibcpp_signed_long_max
+#undef __glibcpp_signed_long_digits
+#undef __glibcpp_signed_long_digits10
+#undef __glibcpp_signed_long_is_modulo
+#undef __glibcpp_signed_long_traps  
+  
+  template<>
+    struct numeric_limits<unsigned long>
+    {
+      static const bool is_specialized = true;
+
+      static unsigned long min() throw()
+      { return 0; }
+      static unsigned long max() throw()
+      { return __glibcpp_unsigned_long_max; }
+
+      static const int digits = __glibcpp_unsigned_long_digits;
+      static const int digits10 = __glibcpp_unsigned_long_digits10;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static unsigned long epsilon() throw()
+      { return 0; }
+      static unsigned long round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static unsigned long infinity() throw()
+      { return static_cast<unsigned long>(0); }
+      static unsigned long quiet_NaN() throw()
+      { return static_cast<unsigned long>(0); }
+      static unsigned long signaling_NaN() throw()
+      { return static_cast<unsigned long>(0); }
+      static unsigned long denorm_min() throw()
+      { return static_cast<unsigned long>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = true;
+
+      static const bool traps = __glibcpp_unsigned_long_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_unsigned_long_max
+#undef __glibcpp_unsigned_long_digits
+#undef __glibcpp_unsigned_long_digits10
+#undef __glibcpp_unsigned_long_traps  
+
+  template<>
+    struct numeric_limits<long long>
+    {
+      static const bool is_specialized = true;
+      
+      static long long min() throw()
+      { return __glibcpp_signed_long_long_min; }
+      static long long max() throw()
+      { return __glibcpp_signed_long_long_max; }
+      
+      static const int digits = __glibcpp_signed_long_long_digits;
+      static const int digits10 = __glibcpp_signed_long_long_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static long long epsilon() throw()
+      { return 0; }
+      static long long round_error() throw()
+      { return 0; }
+      
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+      
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+      
+      static long long infinity() throw()
+      { return static_cast<long long>(0); }
+      static long long quiet_NaN() throw()
+      { return static_cast<long long>(0); }
+      static long long signaling_NaN() throw()
+      { return static_cast<long long>(0); }
+      static long long denorm_min() throw()
+      { return static_cast<long long>(0); }
+      
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = __glibcpp_signed_long_long_is_modulo;
+
+      static const bool traps = __glibcpp_signed_long_long_traps;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_signed_long_long_min
+#undef __glibcpp_signed_long_long_max
+#undef __glibcpp_signed_long_long_digits
+#undef __glibcpp_signed_long_long_digits10
+#undef __glibcpp_signed_long_long_is_modulo
+#undef __glibcpp_signed_long_long_traps  
+  
+  template<>
+    struct numeric_limits<unsigned long long>
+    {
+      static const bool is_specialized = true;
+
+      static unsigned long long min() throw()
+      { return 0; }
+      static unsigned long long max() throw()
+      { return __glibcpp_unsigned_long_long_max; }
+
+      static const int digits = __glibcpp_unsigned_long_long_digits;
+      static const int digits10 = __glibcpp_unsigned_long_long_digits10;
+      static const bool is_signed = false;
+      static const bool is_integer = true;
+      static const bool is_exact = true;
+      static const int radix = 2;
+      static unsigned long long epsilon() throw()
+      { return 0; }
+      static unsigned long long round_error() throw()
+      { return 0; }
+
+      static const int min_exponent = 0;
+      static const int min_exponent10 = 0;
+      static const int max_exponent = 0;
+      static const int max_exponent10 = 0;
+
+      static const bool has_infinity = false;
+      static const bool has_quiet_NaN = false;
+      static const bool has_signaling_NaN = false;
+      static const float_denorm_style has_denorm = denorm_absent;
+      static const bool has_denorm_loss = false;
+
+      static unsigned long long infinity() throw()
+      { return static_cast<unsigned long long>(0); }
+      static unsigned long long quiet_NaN() throw()
+      { return static_cast<unsigned long long>(0); }
+      static unsigned long long signaling_NaN() throw()
+      { return static_cast<unsigned long long>(0); }
+      static unsigned long long denorm_min() throw()
+      { return static_cast<unsigned long long>(0); }
+
+      static const bool is_iec559 = false;
+      static const bool is_bounded = true;
+      static const bool is_modulo = true;
+
+      static const bool traps = true;
+      static const bool tinyness_before = false;
+      static const float_round_style round_style = round_toward_zero;
+    };
+
+#undef __glibcpp_unsigned_long_long_max
+#undef __glibcpp_unsigned_long_long_digits
+#undef __glibcpp_unsigned_long_long_digits10
+#undef __glibcpp_unsigned_long_long_traps  
+
+  template<>
+    struct numeric_limits<float>
+    {
+      static const bool is_specialized = true;
+
+      static float min() throw()
+      { return __glibcpp_float_min; }
+      static float max() throw()
+      { return __glibcpp_float_max; }
+
+      static const int digits = __glibcpp_float_digits;
+      static const int digits10 = __glibcpp_float_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = false;
+      static const bool is_exact = false;
+      static const int radix = __glibcpp_float_radix;
+      static float epsilon() throw()
+      { return __glibcpp_float_epsilon; }
+      static float round_error() throw()
+      { return __glibcpp_float_round_error; }
+
+      static const int min_exponent = __glibcpp_float_min_exponent;
+      static const int min_exponent10 = __glibcpp_float_min_exponent10;
+      static const int max_exponent = __glibcpp_float_max_exponent;
+      static const int max_exponent10 = __glibcpp_float_max_exponent10;
+
+      static const bool has_infinity = __glibcpp_float_has_infinity;
+      static const bool has_quiet_NaN = __glibcpp_float_has_quiet_NaN;
+      static const bool has_signaling_NaN = __glibcpp_float_has_signaling_NaN;
+      static const float_denorm_style has_denorm = __glibcpp_float_has_denorm;
+      static const bool has_denorm_loss = __glibcpp_float_has_denorm_loss;
+
+      static float infinity() throw()
+      { return __glibcpp_float_infinity; }
+      static float quiet_NaN() throw()
+      { return __glibcpp_float_quiet_NaN; }
+      static float signaling_NaN() throw()
+      { return __glibcpp_float_signaling_NaN; }
+      static float denorm_min() throw()
+      { return __glibcpp_float_denorm_min; }
+
+      static const bool is_iec559 = __glibcpp_float_is_iec559;
+      static const bool is_bounded = __glibcpp_float_is_bounded;
+      static const bool is_modulo = __glibcpp_float_is_modulo;
+
+      static const bool traps = __glibcpp_float_traps;
+      static const bool tinyness_before = __glibcpp_float_tinyness_before;
+      static const float_round_style round_style = __glibcpp_float_round_style;
+    };
+
+#undef __glibcpp_float_min
+#undef __glibcpp_float_max
+#undef __glibcpp_float_digits
+#undef __glibcpp_float_digits10
+#undef __glibcpp_float_radix
+#undef __glibcpp_float_round_error
+#undef __glibcpp_float_min_exponent
+#undef __glibcpp_float_min_exponent10
+#undef __glibcpp_float_max_exponent
+#undef __glibcpp_float_max_exponent10
+#undef __glibcpp_float_has_infinity
+#undef __glibcpp_float_has_quiet_NaN
+#undef __glibcpp_float_has_signaling_NaN
+#undef __glibcpp_float_has_denorm
+#undef __glibcpp_float_has_denorm_loss
+#undef __glibcpp_float_infinity
+#undef __glibcpp_float_quiet_NaN
+#undef __glibcpp_float_signaling_NaN
+#undef __glibcpp_float_denorm_min
+#undef __glibcpp_float_is_iec559
+#undef __glibcpp_float_is_bounded
+#undef __glibcpp_float_is_modulo
+#undef __glibcpp_float_traps
+#undef __glibcpp_float_tinyness_before
+#undef __glibcpp_float_round_style  
+
+  template<>
+    struct numeric_limits<double>
+    {
+      static const bool is_specialized = true;
+
+      static double min() throw()
+      { return __glibcpp_double_min; }
+      static double max() throw()
+      { return __glibcpp_double_max; }
+
+      static const int digits = __glibcpp_double_digits;
+      static const int digits10 = __glibcpp_double_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = false;
+      static const bool is_exact = false;
+      static const int radix = __glibcpp_double_radix;
+      static double epsilon() throw()
+      { return __glibcpp_double_epsilon; }
+      static double round_error() throw()
+      { return __glibcpp_double_round_error; }
+
+      static const int min_exponent = __glibcpp_double_min_exponent;
+      static const int min_exponent10 = __glibcpp_double_min_exponent10;
+      static const int max_exponent = __glibcpp_double_max_exponent;
+      static const int max_exponent10 = __glibcpp_double_max_exponent10;
+
+      static const bool has_infinity = __glibcpp_double_has_infinity;
+      static const bool has_quiet_NaN = __glibcpp_double_has_quiet_NaN;
+      static const bool has_signaling_NaN = __glibcpp_double_has_signaling_NaN;
+      static const float_denorm_style has_denorm =
+              __glibcpp_double_has_denorm;
+      static const bool has_denorm_loss = __glibcpp_double_has_denorm_loss;
+
+      static double infinity() throw()
+      { return __glibcpp_double_infinity; }
+      static double quiet_NaN() throw()
+      { return __glibcpp_double_quiet_NaN; }
+      static double signaling_NaN() throw()
+      { return __glibcpp_double_signaling_NaN; }
+      static double denorm_min() throw()
+      { return __glibcpp_double_denorm_min; }
+
+      static const bool is_iec559 = __glibcpp_double_is_iec559;
+      static const bool is_bounded = __glibcpp_double_is_bounded;
+      static const bool is_modulo = __glibcpp_double_is_modulo;
+
+      static const bool traps = __glibcpp_double_traps;
+      static const bool tinyness_before = __glibcpp_double_tinyness_before;
+      static const float_round_style round_style =
+              __glibcpp_double_round_style;
+    };
+
+#undef __glibcpp_double_min
+#undef __glibcpp_double_max
+#undef __glibcpp_double_digits
+#undef __glibcpp_double_digits10
+#undef __glibcpp_double_radix
+#undef __glibcpp_double_round_error
+#undef __glibcpp_double_min_exponent
+#undef __glibcpp_double_min_exponent10
+#undef __glibcpp_double_max_exponent
+#undef __glibcpp_double_max_exponent10
+#undef __glibcpp_double_has_infinity
+#undef __glibcpp_double_has_quiet_NaN
+#undef __glibcpp_double_has_signaling_NaN
+#undef __glibcpp_double_has_denorm
+#undef __glibcpp_double_has_denorm_loss
+#undef __glibcpp_double_infinity
+#undef __glibcpp_double_quiet_NaN
+#undef __glibcpp_double_signaling_NaN
+#undef __glibcpp_double_denorm_min
+#undef __glibcpp_double_is_iec559
+#undef __glibcpp_double_is_bounded
+#undef __glibcpp_double_is_modulo
+#undef __glibcpp_double_traps
+#undef __glibcpp_double_tinyness_before
+#undef __glibcpp_double_round_style  
+  
+  
+  template<>
+    struct numeric_limits<long double>
+    {
+      static const bool is_specialized = true;
+
+      static long double min() throw()
+      { return __glibcpp_long_double_min; }
+      static long double max() throw()
+      { return __glibcpp_long_double_max; }
+
+      static const int digits = __glibcpp_long_double_digits;
+      static const int digits10 = __glibcpp_long_double_digits10;
+      static const bool is_signed = true;
+      static const bool is_integer = false;
+      static const bool is_exact = false;
+      static const int radix = __glibcpp_long_double_radix;
+      static long double epsilon() throw()
+      { return __glibcpp_long_double_epsilon; }
+      static long double round_error() throw()
+      { return __glibcpp_long_double_round_error; }
+
+      static const int min_exponent = __glibcpp_long_double_min_exponent;
+      static const int min_exponent10 = __glibcpp_long_double_min_exponent10;
+      static const int max_exponent = __glibcpp_long_double_max_exponent;
+      static const int max_exponent10 = __glibcpp_long_double_max_exponent10;
+
+      static const bool has_infinity = __glibcpp_long_double_has_infinity;
+      static const bool has_quiet_NaN = __glibcpp_long_double_has_quiet_NaN;
+      static const bool has_signaling_NaN =
+                __glibcpp_long_double_has_signaling_NaN;
+      static const float_denorm_style has_denorm =
+                __glibcpp_long_double_has_denorm;
+      static const bool has_denorm_loss =
+                __glibcpp_long_double_has_denorm_loss;
+
+      static long double infinity() throw()
+      { return __glibcpp_long_double_infinity; }
+      static long double quiet_NaN() throw()
+      { return __glibcpp_long_double_quiet_NaN; }
+      static long double signaling_NaN() throw()
+      { return __glibcpp_long_double_signaling_NaN; }
+      static long double denorm_min() throw()
+      { return __glibcpp_long_double_denorm_min; }
+
+      static const bool is_iec559 = __glibcpp_long_double_is_iec559;
+      static const bool is_bounded = __glibcpp_long_double_is_bounded;
+      static const bool is_modulo = __glibcpp_long_double_is_modulo;
+
+      static const bool traps = __glibcpp_long_double_traps; 
+      static const bool tinyness_before = __glibcpp_long_double_tinyness_before;
+      static const float_round_style round_style = 
+        __glibcpp_long_double_round_style;
+    };
+
+#undef __glibcpp_long_double_min
+#undef __glibcpp_long_double_max
+#undef __glibcpp_long_double_digits
+#undef __glibcpp_long_double_digits10
+#undef __glibcpp_long_double_radix
+#undef __glibcpp_long_double_round_error
+#undef __glibcpp_long_double_min_exponent
+#undef __glibcpp_long_double_min_exponent10
+#undef __glibcpp_long_double_max_exponent
+#undef __glibcpp_long_double_max_exponent10
+#undef __glibcpp_long_double_has_infinity
+#undef __glibcpp_long_double_has_quiet_NaN
+#undef __glibcpp_long_double_has_signaling_NaN
+#undef __glibcpp_long_double_has_denorm
+#undef __glibcpp_long_double_has_denorm_loss
+#undef __glibcpp_long_double_infinity
+#undef __glibcpp_long_double_quiet_NaN
+#undef __glibcpp_long_double_signaling_NaN
+#undef __glibcpp_long_double_denorm_min
+#undef __glibcpp_long_double_is_iec559
+#undef __glibcpp_long_double_is_bounded
+#undef __glibcpp_long_double_is_modulo
+#undef __glibcpp_long_double_traps
+#undef __glibcpp_long_double_tinyness_before
+#undef __glibcpp_long_double_round_style  
+  
+} // namespace std
+
+#else
+
 #include <bits/c++config.h>
 
 //
@@ -1050,4 +2942,6 @@ namespace std
 #undef __glibcpp_digits
 #undef __glibcpp_digits10
 
+#endif // GCC 3.3+
+
 #endif // _CPP_NUMERIC_LIMITS
--- libstdc++33-v3/include/Makefile.am.jj	2003-08-12 10:15:25.000000000 -0400
+++ libstdc++33-v3/include/Makefile.am	2004-10-14 12:28:42.000000000 -0400
@@ -316,7 +316,8 @@ target_headers = \
 	${target_srcdir}/ctype_inline.h \
 	${target_srcdir}/ctype_noninline.h \
 	${target_srcdir}/os_defines.h \
-	${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h 
+	${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h  \
+	${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h
 
 # Non-installed target_header files.
 target_headers_noinst = \
--- libstdc++33-v3/include/Makefile.in.jj	2003-08-12 10:15:25.000000000 -0400
+++ libstdc++33-v3/include/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
@@ -429,7 +430,8 @@ target_headers = \
 	${target_srcdir}/ctype_inline.h \
 	${target_srcdir}/ctype_noninline.h \
 	${target_srcdir}/os_defines.h \
-	${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h 
+	${glibcpp_srcdir}/@ATOMICITY_INC_SRCDIR@/atomicity.h \
+	${glibcpp_srcdir}/@CPU_LIMITS_INC_SRCDIR@/cpu_limits.h 
 
 
 # Non-installed target_header files.
--- libstdc++33-v3/po/Makefile.in.jj	2003-03-17 14:07:39.000000000 -0500
+++ libstdc++33-v3/po/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/testsuite/Makefile.in.jj	2003-12-19 04:18:29.000000000 -0500
+++ libstdc++33-v3/testsuite/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/Makefile.in.jj	2003-07-09 05:08:57.000000000 -0400
+++ libstdc++33-v3/Makefile.in	2004-10-14 12:28:01.000000000 -0400
@@ -83,6 +83,7 @@ CMESSAGES_H = @CMESSAGES_H@
 CMONEY_CC = @CMONEY_CC@
 CNUMERIC_CC = @CNUMERIC_CC@
 CPP = @CPP@
+CPU_LIMITS_INC_SRCDIR = @CPU_LIMITS_INC_SRCDIR@
 CSTDIO_H = @CSTDIO_H@
 CTIME_CC = @CTIME_CC@
 CTIME_H = @CTIME_H@
--- libstdc++33-v3/configure.jj	2004-08-18 03:44:22.000000000 -0400
+++ libstdc++33-v3/configure	2004-10-14 12:35:55.000000000 -0400
@@ -23989,6 +23989,7 @@ fi
 # uses it, and it only gets used in this file.)
 OS_INC_SRCDIR=config/${os_include_dir}
 ATOMICITY_INC_SRCDIR=config/${ATOMICITYH}
+CPU_LIMITS_INC_SRCDIR=config/${CPULIMITSH}
 
 
 
@@ -24442,6 +24443,7 @@ s%@GLIBCPP_TEST_ABI_TRUE@%$GLIBCPP_TEST_
 s%@GLIBCPP_TEST_ABI_FALSE@%$GLIBCPP_TEST_ABI_FALSE%g
 s%@OS_INC_SRCDIR@%$OS_INC_SRCDIR%g
 s%@ATOMICITY_INC_SRCDIR@%$ATOMICITY_INC_SRCDIR%g
+s%@CPU_LIMITS_INC_SRCDIR@%$CPU_LIMITS_INC_SRCDIR%g
 s%@GLIBCPP_IS_CROSS_COMPILING@%$GLIBCPP_IS_CROSS_COMPILING%g
 s%@CANADIAN_TRUE@%$CANADIAN_TRUE%g
 s%@CANADIAN_FALSE@%$CANADIAN_FALSE%g
--- libstdc++33-v3/configure.in.jj	2004-08-18 03:44:22.000000000 -0400
+++ libstdc++33-v3/configure.in	2004-10-14 12:35:27.000000000 -0400
@@ -451,8 +451,10 @@ GLIBCPP_CONFIGURE_TESTSUITE
 # uses it, and it only gets used in this file.)
 OS_INC_SRCDIR=config/${os_include_dir}
 ATOMICITY_INC_SRCDIR=config/${ATOMICITYH}
+CPU_LIMITS_INC_SRCDIR=config/${CPULIMITSH}
 AC_SUBST(OS_INC_SRCDIR)
 AC_SUBST(ATOMICITY_INC_SRCDIR)
+AC_SUBST(CPU_LIMITS_INC_SRCDIR)
 
 # Set up cross-compile flags
 AC_SUBST(GLIBCPP_IS_CROSS_COMPILING)  dnl Unused so far.
--- libstdc++33-v3/configure.target.jj	2003-10-23 11:45:20.000000000 -0400
+++ libstdc++33-v3/configure.target	2004-10-14 12:34:27.000000000 -0400
@@ -32,6 +32,8 @@
 #
 #   ATOMICITYH             location of atomicity.h,
 #                          defaults to cpu_include_dir
+#   CPULIMITSH             location of cpu_limits.h,
+#                          defaults to cpu_include_dir
 #
 # It possibly modifies the following variables:
 #
@@ -198,3 +200,45 @@ case "${target}" in
     abi_baseline_pair="sparc-freebsd5"
     ;;
 esac
+
+# Set CPULIMITSH to the directory where the configuration-dependent
+# cpu_limits.h can be found.
+# THIS TABLE IS SORTED.  KEEP IT THAT WAY.
+case "${target}" in
+   *-*-hpux*)
+     CPULIMITSH=os/hpux
+     ;;
+   alpha*-*-*osf5*)
+     CPULIMITSH=os/osf/osf5.0
+     ;;
+   alpha*-*-*)
+     CPULIMITSH=cpu/alpha
+     ;;
+   cris-*-*)
+     CPULIMITSH=cpu/cris
+     ;;
+   ia64-*-*)
+     CPULIMITSH=cpu/ia64
+     ;;
+   i?86-*-*)
+     CPULIMITSH=cpu/i386
+     ;;
+   m68k-*-* | m680[246]0-*-*)
+     CPULIMITSH=cpu/m68k
+     ;;
+   mmix-*-*)
+     CPULIMITSH=cpu/mmix
+     ;;
+   powerpc*-*-* | rs6000-*-*)
+     CPULIMITSH=cpu/powerpc
+     ;;
+   s390-*-* | s390x-*-*)
+     CPULIMITSH=cpu/s390
+     ;;
+   x86_64-*-*)
+     CPULIMITSH=cpu/x86-64
+     ;;
+   *)
+     CPULIMITSH=cpu/generic
+     ;;
+esac
