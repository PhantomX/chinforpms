diff -U 3 -dHrNp -- gtk+-3.24.4.orig/gtk/gtkmenu.c gtk+-3.24.4/gtk/gtkmenu.c
--- gtk+-3.24.4.orig/gtk/gtkmenu.c	2019-01-19 01:57:45.000000000 -0200
+++ gtk+-3.24.4/gtk/gtkmenu.c	2019-01-23 10:22:46.121493752 -0200
@@ -213,12 +213,6 @@ enum {
   CHILD_PROP_BOTTOM_ATTACH
 };
 
-typedef enum _GtkMenuScrollFlag
-{
-  GTK_MENU_SCROLL_FLAG_NONE = 0,
-  GTK_MENU_SCROLL_FLAG_ADAPT = 1 << 0,
-} GtkMenuScrollFlag;
-
 static void     gtk_menu_set_property      (GObject          *object,
                                             guint             prop_id,
                                             const GValue     *value,
@@ -261,8 +255,7 @@ static gboolean gtk_menu_enter_notify
 static gboolean gtk_menu_leave_notify      (GtkWidget        *widget,
                                             GdkEventCrossing *event);
 static void     gtk_menu_scroll_to         (GtkMenu          *menu,
-                                            gint              offset,
-                                            GtkMenuScrollFlag flags);
+                                            gint              offset);
 static void     gtk_menu_grab_notify       (GtkWidget        *widget,
                                             gboolean          was_grabbed);
 static gboolean gtk_menu_captured_event    (GtkWidget        *widget,
@@ -1984,7 +1977,7 @@ gtk_menu_popup_internal (GtkMenu
 
   associate_menu_grab_transfer_window (menu);
 
-  gtk_menu_scroll_to (menu, priv->scroll_offset, GTK_MENU_SCROLL_FLAG_NONE);
+  gtk_menu_scroll_to (menu, priv->scroll_offset);
 
   /* if no item is selected, select the first one */
   if (!menu_shell->priv->active_menu_item &&
@@ -1992,7 +1985,6 @@ gtk_menu_popup_internal (GtkMenu
     gtk_menu_shell_select_first (menu_shell, TRUE);
 
   /* Once everything is set up correctly, map the toplevel */
-  gtk_window_force_resize (GTK_WINDOW (priv->toplevel));
   gtk_widget_show (priv->toplevel);
 
   if (xgrab_shell == widget)
@@ -2486,8 +2478,7 @@ gtk_menu_update_scroll_offset (GtkMenu
 
   get_arrows_border (menu, &arrows_border);
   menu->priv->scroll_offset = arrows_border.top + (final_rect->y - flipped_rect->y);
-  gtk_menu_scroll_to (menu, menu->priv->scroll_offset,
-                      GTK_MENU_SCROLL_FLAG_ADAPT);
+  gtk_menu_scroll_to (menu, menu->priv->scroll_offset);
 }
 
 /**
@@ -2560,8 +2551,7 @@ gtk_menu_popdown (GtkMenu *menu)
        * non-tearoff menu was popped down.
        */
       if (!priv->tearoff_active)
-        gtk_menu_scroll_to (menu, priv->saved_scroll_offset,
-                            GTK_MENU_SCROLL_FLAG_NONE);
+        gtk_menu_scroll_to (menu, priv->saved_scroll_offset);
       priv->tearoff_active = TRUE;
     }
   else
@@ -2852,7 +2842,7 @@ gtk_menu_scrollbar_changed (GtkAdjustmen
 
   value = gtk_adjustment_get_value (adjustment);
   if (menu->priv->scroll_offset != value)
-    gtk_menu_scroll_to (menu, value, GTK_MENU_SCROLL_FLAG_NONE);
+    gtk_menu_scroll_to (menu, value);
 }
 
 static void
@@ -3045,7 +3035,7 @@ gtk_menu_set_tearoff_state (GtkMenu  *me
           gtk_widget_show (GTK_WIDGET (menu));
           gtk_widget_show (priv->tearoff_window);
 
-          gtk_menu_scroll_to (menu, 0, GTK_MENU_SCROLL_FLAG_NONE);
+          gtk_menu_scroll_to (menu, 0);
 
         }
       else
@@ -3491,7 +3481,7 @@ gtk_menu_size_allocate (GtkWidget     *w
   height = allocation->height - (2 * border_width) - padding.top - padding.bottom;
 
   if (menu_shell->priv->active)
-    gtk_menu_scroll_to (menu, priv->scroll_offset, GTK_MENU_SCROLL_FLAG_NONE);
+    gtk_menu_scroll_to (menu, priv->scroll_offset);
 
   get_arrows_border (menu, &arrow_border);
 
@@ -3599,7 +3589,7 @@ gtk_menu_size_allocate (GtkWidget     *w
                   gtk_widget_hide (priv->tearoff_scrollbar);
                   gtk_menu_set_tearoff_hints (menu, allocation->width);
 
-                  gtk_menu_scroll_to (menu, 0, GTK_MENU_SCROLL_FLAG_NONE);
+                  gtk_menu_scroll_to (menu, 0);
                 }
             }
           else
@@ -4177,7 +4167,7 @@ gtk_menu_scroll_by (GtkMenu *menu,
     offset = priv->requested_height - view_height;
 
   if (offset != priv->scroll_offset)
-    gtk_menu_scroll_to (menu, offset, GTK_MENU_SCROLL_FLAG_NONE);
+    gtk_menu_scroll_to (menu, offset);
 }
 
 static gboolean
@@ -4687,7 +4677,7 @@ gtk_menu_captured_event (GtkWidget *widg
                               MIN (priv->scroll_offset, 0),
                               MAX (priv->scroll_offset, priv->requested_height - view_height));
 
-              gtk_menu_scroll_to (menu, offset, GTK_MENU_SCROLL_FLAG_NONE);
+              gtk_menu_scroll_to (menu, offset);
 
               retval = TRUE;
             }
@@ -5253,16 +5243,10 @@ gtk_menu_position (GtkMenu  *menu,
 
   if (!rect_window)
     {
-      gtk_window_set_unlimited_guessed_size (GTK_WINDOW (priv->toplevel),
-                                             FALSE, FALSE);
       gtk_menu_position_legacy (menu, set_scroll_offset);
       return;
     }
 
-  gtk_window_set_unlimited_guessed_size (GTK_WINDOW (priv->toplevel),
-                                         !!(anchor_hints & GDK_ANCHOR_RESIZE_X),
-                                         !!(anchor_hints & GDK_ANCHOR_RESIZE_Y));
-
   /* Realize so we have the proper width and height to figure out
    * the right place to popup the menu.
    */
@@ -5332,26 +5316,11 @@ gtk_menu_stop_scrolling (GtkMenu *menu)
 }
 
 static void
-sync_arrows_state (GtkMenu *menu)
+gtk_menu_scroll_to (GtkMenu *menu,
+                    gint    offset)
 {
   GtkMenuPrivate *priv = menu->priv;
   GtkCssNode *top_arrow_node, *bottom_arrow_node;
-
-  top_arrow_node = gtk_css_gadget_get_node (priv->top_arrow_gadget);
-  gtk_css_node_set_visible (top_arrow_node, priv->upper_arrow_visible);
-  gtk_css_node_set_state (top_arrow_node, priv->upper_arrow_state);
-
-  bottom_arrow_node = gtk_css_gadget_get_node (priv->bottom_arrow_gadget);
-  gtk_css_node_set_visible (bottom_arrow_node, priv->lower_arrow_visible);
-  gtk_css_node_set_state (bottom_arrow_node, priv->lower_arrow_state);
-}
-
-static void
-gtk_menu_scroll_to (GtkMenu           *menu,
-                    gint               offset,
-                    GtkMenuScrollFlag  flags)
-{
-  GtkMenuPrivate *priv = menu->priv;
   GtkBorder arrow_border, padding;
   GtkWidget *widget;
   gint x, y;
@@ -5387,25 +5356,13 @@ gtk_menu_scroll_to (GtkMenu           *m
         {
           GtkStateFlags upper_arrow_previous_state = priv->upper_arrow_state;
           GtkStateFlags lower_arrow_previous_state = priv->lower_arrow_state;
-          gboolean should_offset_by_arrow;
 
           if (!priv->upper_arrow_visible || !priv->lower_arrow_visible)
             gtk_widget_queue_draw (GTK_WIDGET (menu));
 
-          if (!priv->upper_arrow_visible &
-              flags & GTK_MENU_SCROLL_FLAG_ADAPT)
-            should_offset_by_arrow = TRUE;
-          else
-            should_offset_by_arrow = FALSE;
-
           priv->upper_arrow_visible = priv->lower_arrow_visible = TRUE;
 
-          if (flags & GTK_MENU_SCROLL_FLAG_ADAPT)
-            sync_arrows_state (menu);
-
           get_arrows_border (menu, &arrow_border);
-          if (should_offset_by_arrow)
-            offset += arrow_border.top;
           y += arrow_border.top;
           view_height -= arrow_border.top;
           view_height -= arrow_border.bottom;
@@ -5472,7 +5429,13 @@ gtk_menu_scroll_to (GtkMenu           *m
         }
     }
 
-  sync_arrows_state (menu);
+  top_arrow_node = gtk_css_gadget_get_node (priv->top_arrow_gadget);
+  gtk_css_node_set_visible (top_arrow_node, priv->upper_arrow_visible);
+  gtk_css_node_set_state (top_arrow_node, priv->upper_arrow_state);
+
+  bottom_arrow_node = gtk_css_gadget_get_node (priv->bottom_arrow_gadget);
+  gtk_css_node_set_visible (bottom_arrow_node, priv->lower_arrow_visible);
+  gtk_css_node_set_state (bottom_arrow_node, priv->lower_arrow_state);
 
   /* Scroll the menu: */
   if (gtk_widget_get_realized (widget))
@@ -5558,7 +5521,7 @@ gtk_menu_scroll_item_visible (GtkMenuShe
            * is on the menu
            */
           menu_shell->priv->ignore_enter = TRUE;
-          gtk_menu_scroll_to (menu, child_offset, GTK_MENU_SCROLL_FLAG_NONE);
+          gtk_menu_scroll_to (menu, child_offset);
         }
       else
         {
@@ -5579,7 +5542,7 @@ gtk_menu_scroll_item_visible (GtkMenuShe
                * is on the menu
                */
               menu_shell->priv->ignore_enter = TRUE;
-              gtk_menu_scroll_to (menu, y, GTK_MENU_SCROLL_FLAG_NONE);
+              gtk_menu_scroll_to (menu, y);
             }
         }
     }
@@ -6063,7 +6026,7 @@ gtk_menu_real_move_scroll (GtkMenu
         new_offset = priv->scroll_offset + step;
         new_offset = CLAMP (new_offset, 0, end_position - page_size);
 
-        gtk_menu_scroll_to (menu, new_offset, GTK_MENU_SCROLL_FLAG_NONE);
+        gtk_menu_scroll_to (menu, new_offset);
 
         if (menu_shell->priv->active_menu_item)
           {
diff -U 3 -dHrNp -- gtk+-3.24.4.orig/gtk/gtkwindow.c gtk+-3.24.4/gtk/gtkwindow.c
--- gtk+-3.24.4.orig/gtk/gtkwindow.c	2019-01-19 01:57:45.000000000 -0200
+++ gtk+-3.24.4/gtk/gtkwindow.c	2019-01-23 10:22:46.122493748 -0200
@@ -262,9 +262,6 @@ struct _GtkWindowPrivate
   guint    maximized                 : 1;
   guint    fullscreen                : 1;
   guint    tiled                     : 1;
-  guint    unlimited_guessed_size_x  : 1;
-  guint    unlimited_guessed_size_y  : 1;
-  guint    force_resize              : 1;
 
   guint    use_subsurface            : 1;
 
@@ -6458,25 +6455,6 @@ gtk_window_unmap (GtkWidget *widget)
     gtk_widget_unmap (child);
 }
 
-void
-gtk_window_set_unlimited_guessed_size (GtkWindow *window,
-                                       gboolean   x,
-                                       gboolean   y)
-{
-  GtkWindowPrivate *priv = window->priv;
-
-  priv->unlimited_guessed_size_x = x;
-  priv->unlimited_guessed_size_y = y;
-}
-
-void
-gtk_window_force_resize (GtkWindow *window)
-{
-  GtkWindowPrivate *priv = window->priv;
-
-  priv->force_resize = TRUE;
-}
-
 /* (Note: Replace "size" with "width" or "height". Also, the request
  * mode is honoured.)
  * For selecting the default window size, the following conditions
@@ -6515,15 +6493,8 @@ gtk_window_guess_default_size (GtkWindow
 
   gdk_monitor_get_workarea (monitor, &workarea);
 
-  if (window->priv->unlimited_guessed_size_x)
-    *width = INT_MAX;
-  else
-    *width = workarea.width;
-
-  if (window->priv->unlimited_guessed_size_y)
-    *height = INT_MAX;
-  else
-    *height = workarea.height;
+  *width = workarea.width;
+  *height = workarea.height;
 
   if (gtk_widget_get_request_mode (widget) == GTK_SIZE_REQUEST_WIDTH_FOR_HEIGHT)
     {
@@ -9393,8 +9364,7 @@ gtk_window_compute_configure_request_siz
   
   info = gtk_window_get_geometry_info (window, FALSE);
 
-  if (priv->need_default_size ||
-      priv->force_resize)
+  if (priv->need_default_size)
     {
       gtk_window_guess_default_size (window, width, height);
       gtk_window_get_remembered_size (window, &w, &h);
@@ -9799,13 +9769,9 @@ gtk_window_move_resize (GtkWindow *windo
       info->last.configure_request.y != new_request.y)
     configure_request_pos_changed = TRUE;
 
-  if (priv->force_resize ||
-      (info->last.configure_request.width != new_request.width ||
+  if ((info->last.configure_request.width != new_request.width ||
        info->last.configure_request.height != new_request.height))
-    {
-      priv->force_resize = FALSE;
-      configure_request_size_changed = TRUE;
-    }
+    configure_request_size_changed = TRUE;
   
   hints_changed = FALSE;
   
diff -U 3 -dHrNp -- gtk+-3.24.4.orig/gtk/gtkwindowprivate.h gtk+-3.24.4/gtk/gtkwindowprivate.h
--- gtk+-3.24.4.orig/gtk/gtkwindowprivate.h	2019-01-19 01:57:45.000000000 -0200
+++ gtk+-3.24.4/gtk/gtkwindowprivate.h	2019-01-23 10:22:46.122493748 -0200
@@ -135,11 +135,6 @@ void       gtk_window_set_hardcoded_wind
 
 GdkScreen *_gtk_window_get_screen (GtkWindow *window);
 
-void       gtk_window_set_unlimited_guessed_size (GtkWindow *window,
-                                                  gboolean   x,
-                                                  gboolean   y);
-void       gtk_window_force_resize (GtkWindow *window);
-
 /* Exported handles */
 
 typedef void (*GtkWindowHandleExported)  (GtkWindow               *window,
