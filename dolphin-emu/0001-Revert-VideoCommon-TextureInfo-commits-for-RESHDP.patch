From 9061cdbbc502ce2ab6c36815310f65be2a0587a1 Mon Sep 17 00:00:00 2001
From: Phantom X <PhantomX@users.noreply.github.com>
Date: Sat, 22 Jan 2022 00:12:28 -0300
Subject: [PATCH] Revert VideoCommon/TextureInfo commits for RESHDP

2d59dcb95d1256bdbe0bf020c029b191477a241c - VideoCommon/TextureInfo: Fix mipmap loading from tmem
df53a5f8809d1f9c21a2975a2fd6e98e9c7a8424 - VideoCommon: enhance hi res texture support by having exact matches be picked before wildcard matches.
8fb0f913315f98c9c3f3bf51ad0fc4e534991e10 - VideoCommon: split the texture hash from the base name when generating the texture name
faec77a9714b31e0c3864890bc44c4bf31e06a66 - Fix -Wreorder warnings
182dfc38e6cb6256cc41f5dd3437a7e4f407ff17 - VideoCommon: move all texture calculations to a "TextureInfo"
42d1658c5055a6f100cd5154a582e6422a89ad2e - VideoCommon/TextureInfo: Restore old mipmap detection logic
ef0e401708dc534e8bfac52e5e43086b4255c22d - BPMem: Abstract TexUnit Addressing into struct
9fa26624b02562fb8626c93c45acf2015fc06f40 - BPMemory: Refactor/consolidate TexUnit Addressing
88bd10cd30d487cc3efba20875b32df7cdacb686 - Extend TMEM cache implementation
a33cf278854ff2cb3fe8c1de193a0a344b1c9abd - TMEM: Handle savestate and init
d771bee0fee0f09f9c6eeb72d514fd9d66038b87 - TMEM: Add some helpful comments
edb66dab8469736e5c2954fd3ffb9704de4542c3 - TextureCache: Remove deleted textures from bound_textures
pull/9956 - VideoCommon: Manually handle texture wrapping and sampling
20257634209dba85d2cd51ad42e660090a5224e6 - VideoCommon: Support shader logic ops on Metal (Apple GPUs) and OpenGL ES
b1f79d9ecf87070c78789acdf5bc329637bc5812 - Treewide: Adjust order of includes
08396c56e56708344d63fded5900020f47337b8e - VideoConfig: Add bool for sampler LOD bias support
91cdeb5aa6e46ea0cc60e157d4d30863e54f7ec0 - SamplerCache: Check for bSupportsLodBiasInSampler instead of IsGLES
4e12d6e871680fe70bb45e7909f00a89539f7a3f - ShaderGenCommon: Add bit for LOD bias
056613ecc5c79941d4bc9747bdc6f79fe332183a - PixelShaderGen: Add LOD bias to texture() call on systems that don't support it in the sampler
a96cfe253114d28f7318d33eb9bb8cb0017bd45d - GLES: Fix LOD bias int/float mismatch
---
 Source/Core/AudioCommon/AlsaSoundStream.cpp   |   3 +-
 Source/Core/AudioCommon/AudioStretcher.cpp    |   3 +-
 Source/Core/AudioCommon/CubebStream.cpp       |   3 +-
 Source/Core/AudioCommon/CubebUtils.cpp        |   3 +-
 Source/Core/AudioCommon/Mixer.cpp             |   2 +-
 Source/Core/AudioCommon/OpenALStream.cpp      |   3 +-
 Source/Core/AudioCommon/SurroundDecoder.cpp   |   4 +-
 Source/Core/Common/Analytics.cpp              |   3 +-
 Source/Core/Common/Arm64Emitter.cpp           |   3 +-
 Source/Core/Common/ArmCPUDetect.cpp           |   3 +-
 Source/Core/Common/ArmFPURoundMode.cpp        |   7 +-
 Source/Core/Common/BitField.h                 |   2 -
 Source/Core/Common/CDUtils.cpp                |  11 +-
 Source/Core/Common/CommonFuncs.cpp            |   4 +-
 Source/Core/Common/Config/ConfigInfo.cpp      |   3 +-
 Source/Core/Common/Config/Layer.cpp           |   3 +-
 Source/Core/Common/Crypto/AES.cpp             |   4 +-
 Source/Core/Common/Crypto/bn.cpp              |   3 +-
 Source/Core/Common/Crypto/ec.cpp              |   3 +-
 Source/Core/Common/ENetUtil.cpp               |   2 +-
 Source/Core/Common/FileSearch.cpp             |   3 +-
 .../Common/GL/GLExtensions/GLExtensions.cpp   |   3 +-
 Source/Core/Common/GL/GLInterface/EGL.cpp     |   3 +-
 .../Core/Common/GL/GLInterface/EGLAndroid.cpp |   1 -
 Source/Core/Common/GL/GLInterface/GLX.cpp     |   3 +-
 Source/Core/Common/GL/GLInterface/WGL.cpp     |   3 +-
 Source/Core/Common/GL/GLUtil.cpp              |   3 +-
 Source/Core/Common/GenericFPURoundMode.cpp    |   3 +-
 Source/Core/Common/IOFile.cpp                 |   3 +-
 Source/Core/Common/LdrWatcher.cpp             |   4 +-
 .../Common/Logging/ConsoleListenerDroid.cpp   |   4 +-
 .../Common/Logging/ConsoleListenerNix.cpp     |   3 +-
 .../Common/Logging/ConsoleListenerWin.cpp     |   3 +-
 Source/Core/Common/Matrix.cpp                 |   4 +-
 Source/Core/Common/MemoryUtil.cpp             |   3 +-
 Source/Core/Common/PcapFile.cpp               |   3 +-
 Source/Core/Common/PerformanceCounter.cpp     |   2 +-
 Source/Core/Common/Profiler.cpp               |   3 +-
 Source/Core/Common/QoSSession.cpp             |   3 +-
 Source/Core/Common/SymbolDB.cpp               |   3 +-
 Source/Core/Common/Thread.cpp                 |   7 +-
 Source/Core/Common/x64Emitter.cpp             |   3 +-
 Source/Core/Common/x64FPURoundMode.cpp        |   3 +-
 Source/Core/Core/CheatGeneration.cpp          |   4 +-
 Source/Core/Core/Config/FreeLookSettings.cpp  |   2 +-
 Source/Core/Core/Config/GraphicsSettings.cpp  |   2 -
 Source/Core/Core/Config/GraphicsSettings.h    |   1 -
 Source/Core/Core/DSP/DSPAccelerator.cpp       |   4 +-
 Source/Core/Core/DSP/DSPHWInterface.cpp       |   3 +-
 Source/Core/Core/DSP/DSPMemoryMap.cpp         |   3 +-
 Source/Core/Core/DSP/DSPStacks.cpp            |   3 +-
 .../Core/DSP/Interpreter/DSPIntArithmetic.cpp |   3 +-
 .../Core/DSP/Interpreter/DSPIntBranch.cpp     |   3 +-
 .../Core/DSP/Interpreter/DSPIntLoadStore.cpp  |   3 +-
 .../Core/Core/DSP/Interpreter/DSPIntMisc.cpp  |   3 +-
 .../Core/DSP/Interpreter/DSPIntMultiplier.cpp |   3 +-
 .../Core/DSP/Jit/x64/DSPJitArithmetic.cpp     |   4 +-
 Source/Core/Core/DSP/Jit/x64/DSPJitBranch.cpp |   3 +-
 Source/Core/Core/DSP/Jit/x64/DSPJitCCUtil.cpp |   3 +-
 Source/Core/Core/DSP/Jit/x64/DSPJitExtOps.cpp |   3 +-
 .../Core/Core/DSP/Jit/x64/DSPJitLoadStore.cpp |   3 +-
 Source/Core/Core/DSP/Jit/x64/DSPJitMisc.cpp   |   3 +-
 .../Core/DSP/Jit/x64/DSPJitMultiplier.cpp     |   3 +-
 Source/Core/Core/DSP/Jit/x64/DSPJitUtil.cpp   |   4 +-
 .../Core/Core/HW/EXI/BBA/TAPServer_Apple.cpp  |   3 +-
 Source/Core/Core/HW/EXI/BBA/TAP_Apple.cpp     |   3 +-
 Source/Core/Core/HW/EXI/BBA/TAP_Unix.cpp      |   3 +-
 Source/Core/Core/HW/EXI/BBA/TAP_Win32.cpp     |   3 +-
 Source/Core/Core/HW/EXI/EXI_DeviceIPL.cpp     |   1 +
 Source/Core/Core/HW/SI/SI_DeviceGBAEmu.cpp    |   3 +-
 Source/Core/Core/HW/SI/SI_DeviceNull.cpp      |   3 +
 Source/Core/Core/HW/StreamADPCM.cpp           |   4 +-
 .../Core/HW/WiimoteEmu/EmuSubroutines.cpp     |   5 +-
 Source/Core/Core/HW/WiimoteReal/IOAndroid.cpp |   4 +-
 Source/Core/Core/HW/WiimoteReal/IOLinux.cpp   |   3 +-
 Source/Core/Core/HW/WiimoteReal/IOWin.cpp     |   3 +-
 Source/Core/Core/HW/WiimoteReal/IOhidapi.cpp  |   3 +-
 Source/Core/Core/IOS/ES/NandUtils.cpp         |   3 +-
 Source/Core/Core/IOS/FS/HostBackend/FS.cpp    |   3 +-
 Source/Core/Core/IOS/FS/HostBackend/File.cpp  |   4 +-
 Source/Core/Core/LibusbUtils.cpp              |   3 +-
 Source/Core/Core/MemoryWatcher.cpp            |   3 +-
 Source/Core/Core/MemoryWatcher.h              |   3 -
 .../Interpreter/Interpreter_Branch.cpp        |   3 +-
 .../Interpreter/Interpreter_FloatingPoint.cpp |   3 +-
 .../Interpreter_LoadStorePaired.cpp           |   3 +-
 .../Interpreter/Interpreter_Paired.cpp        |   3 +-
 .../Interpreter/Interpreter_Tables.cpp        |   3 +-
 .../Core/Core/PowerPC/Jit64/Jit64_Tables.cpp  |   3 +-
 Source/Core/Core/PowerPC/Jit64/Jit_Branch.cpp |   3 +-
 .../Core/PowerPC/Jit64/Jit_FloatingPoint.cpp  |   3 +-
 .../Core/Core/PowerPC/Jit64/Jit_Integer.cpp   |   3 +-
 .../PowerPC/Jit64/Jit_LoadStoreFloating.cpp   |   3 +-
 Source/Core/Core/PowerPC/Jit64/Jit_Paired.cpp |   3 +-
 .../PowerPC/Jit64/Jit_SystemRegisters.cpp     |   3 +-
 .../PowerPC/JitArm64/JitArm64_BackPatch.cpp   |   3 +-
 .../Core/PowerPC/JitArm64/JitArm64_Branch.cpp |   3 +-
 .../JitArm64/JitArm64_FloatingPoint.cpp       |   3 +-
 .../PowerPC/JitArm64/JitArm64_Integer.cpp     |   3 +-
 .../PowerPC/JitArm64/JitArm64_LoadStore.cpp   |   3 +-
 .../JitArm64/JitArm64_LoadStoreFloating.cpp   |   3 +-
 .../JitArm64/JitArm64_LoadStorePaired.cpp     |   3 +-
 .../Core/PowerPC/JitArm64/JitArm64_Paired.cpp |   3 +-
 .../JitArm64/JitArm64_SystemRegisters.cpp     |   3 +-
 Source/Core/Core/PowerPC/JitArm64/JitAsm.cpp  |   3 +-
 .../Core/Core/PowerPC/JitArm64/Jit_Util.cpp   |   3 +-
 .../Core/Core/PowerPC/JitCommon/DivUtils.cpp  |   4 +-
 .../Core/Core/PowerPC/JitCommon/JitCache.cpp  |   2 -
 Source/Core/Core/State.cpp                    |   2 +-
 Source/Core/DiscIO/Blob.cpp                   |   3 +-
 Source/Core/DiscIO/CISOBlob.cpp               |   3 +-
 Source/Core/DiscIO/CompressedBlob.cpp         |  11 +-
 Source/Core/DiscIO/DriveBlob.cpp              |   3 +-
 Source/Core/DiscIO/Enums.cpp                  |   3 +-
 Source/Core/DiscIO/FileBlob.cpp               |   3 +-
 Source/Core/DiscIO/FileSystemGCWii.cpp        |   3 +-
 Source/Core/DiscIO/GameModDescriptor.cpp      |   4 +-
 Source/Core/DiscIO/VolumeWad.cpp              |   3 +-
 Source/Core/DolphinLib.props                  |   5 +-
 Source/Core/DolphinQt/AboutDialog.cpp         |   3 +-
 .../Config/Graphics/AdvancedWidget.cpp        |  15 -
 .../Config/Graphics/AdvancedWidget.h          |   1 -
 .../Config/Graphics/GraphicsBool.cpp          |   7 +-
 .../DolphinQt/Config/Graphics/HacksWidget.h   |   2 +-
 Source/Core/DolphinQt/Config/InfoWidget.cpp   |   3 +-
 .../Config/Mapping/GCKeyboardEmu.cpp          |   4 +-
 .../DolphinQt/Config/Mapping/GCMicrophone.cpp |   4 +-
 .../DolphinQt/Config/PropertiesDialog.cpp     |   3 +-
 .../Core/DolphinQt/Config/SettingsWindow.cpp  |   3 +-
 .../DolphinQt/GameList/ListProxyModel.cpp     |   1 -
 Source/Core/DolphinQt/MainWindow.cpp          |   3 +-
 .../DolphinQt/QtUtils/DolphinFileDialog.cpp   |   2 +-
 .../QtUtils/DoubleClickEventFilter.cpp        |   4 +-
 .../DolphinQt/QtUtils/FileOpenEventFilter.cpp |   4 +-
 .../QtUtils/WindowActivationEventFilter.cpp   |   4 +-
 Source/Core/DolphinQt/Settings/PathPane.cpp   |   3 +-
 .../Core/DolphinQt/TAS/WiiTASInputWindow.cpp  |   3 +-
 Source/Core/DolphinQt/ToolBar.cpp             |   3 +-
 .../ControllerInterface/Android/Android.cpp   |   1 -
 .../DInput/DInputJoystick.cpp                 |   3 +-
 .../DInput/XInputFilter.cpp                   |   2 -
 .../ControllerInterface/OSX/OSX.mm            |   3 +-
 .../ControllerInterface/Pipes/Pipes.cpp       |   3 +-
 .../ControllerInterface/Pipes/Pipes.h         |   2 -
 .../Touch/ButtonManager.cpp                   |   3 +-
 .../ControllerInterface/Touch/Touchscreen.cpp |   7 +-
 .../ControllerInterface/Xlib/XInput2.cpp      |   4 +-
 .../ControllerInterface/evdev/evdev.cpp       |   3 +-
 Source/Core/InputCommon/GCAdapter_Android.cpp |   3 +-
 Source/Core/InputCommon/InputConfig.cpp       |   3 +-
 Source/Core/UICommon/CommandLineParse.cpp     |   3 +-
 Source/Core/UICommon/UICommon.cpp             |   3 +-
 .../Core/VideoBackends/D3D/D3DBoundingBox.cpp |   4 +-
 Source/Core/VideoBackends/D3D/D3DMain.cpp     |   3 -
 Source/Core/VideoBackends/D3D/D3DState.cpp    |  33 +-
 Source/Core/VideoBackends/D3D/D3DState.h      |   2 +-
 Source/Core/VideoBackends/D3D/DXPipeline.cpp  |   3 +-
 Source/Core/VideoBackends/D3D/DXPipeline.h    |   2 -
 Source/Core/VideoBackends/D3D/DXTexture.cpp   |   3 +-
 Source/Core/VideoBackends/D3D/DXTexture.h     |   2 -
 .../VideoBackends/D3D12/D3D12Renderer.cpp     |   3 +-
 .../D3D12/D3D12VertexManager.cpp              |   2 +
 .../Core/VideoBackends/D3D12/DX12Pipeline.cpp |   3 +-
 .../Core/VideoBackends/D3D12/DX12Texture.cpp  |   2 -
 .../D3D12/DescriptorHeapManager.cpp           |  32 +-
 .../D3D12/DescriptorHeapManager.h             |   2 +-
 .../Core/VideoBackends/D3D12/VideoBackend.cpp |   3 -
 .../VideoBackends/D3DCommon/D3DCommon.cpp     |   4 +-
 .../Core/VideoBackends/D3DCommon/Shader.cpp   |   4 +-
 .../Core/VideoBackends/Null/NullBackend.cpp   |   3 -
 Source/Core/VideoBackends/OGL/OGLMain.cpp     |   8 +-
 Source/Core/VideoBackends/OGL/OGLPipeline.cpp |   3 +-
 Source/Core/VideoBackends/OGL/OGLRender.cpp   |   7 -
 Source/Core/VideoBackends/OGL/OGLTexture.cpp  |   3 +-
 .../VideoBackends/OGL/ProgramShaderCache.cpp  |   9 +-
 .../Core/VideoBackends/OGL/SamplerCache.cpp   |  31 +-
 .../Core/VideoBackends/Software/DebugUtil.cpp |  14 +-
 .../VideoBackends/Software/Rasterizer.cpp     |  32 +-
 .../VideoBackends/Software/SWOGLWindow.cpp    |   3 +-
 .../Core/VideoBackends/Software/SWTexture.cpp |   3 +-
 Source/Core/VideoBackends/Software/SWmain.cpp |   6 +-
 .../Core/VideoBackends/Software/SetupUnit.cpp |   6 +-
 .../VideoBackends/Software/TextureSampler.cpp |  28 +-
 .../Core/VideoBackends/Vulkan/ObjectCache.cpp |  26 +-
 .../VideoBackends/Vulkan/ShaderCompiler.cpp   |   6 +-
 .../VideoBackends/Vulkan/StagingBuffer.cpp    |   3 +-
 .../VideoBackends/Vulkan/VKBoundingBox.cpp    |   3 +-
 Source/Core/VideoBackends/Vulkan/VKMain.cpp   |   3 +-
 .../Core/VideoBackends/Vulkan/VKRenderer.cpp  |  11 +-
 Source/Core/VideoBackends/Vulkan/VKShader.cpp |   3 +-
 .../Core/VideoBackends/Vulkan/VKTexture.cpp   |   3 +-
 .../VideoBackends/Vulkan/VulkanContext.cpp    |  24 +-
 .../VideoBackends/Vulkan/VulkanLoader.cpp     |   4 +-
 .../VideoCommon/AbstractStagingTexture.cpp    |   3 +-
 Source/Core/VideoCommon/AbstractTexture.cpp   |   3 +-
 Source/Core/VideoCommon/AsyncRequests.cpp     |   3 +-
 Source/Core/VideoCommon/BPMemory.h            | 168 +------
 Source/Core/VideoCommon/BPStructs.cpp         |  88 ++--
 Source/Core/VideoCommon/CMakeLists.txt        |   9 +-
 Source/Core/VideoCommon/CommandProcessor.cpp  |   3 +-
 Source/Core/VideoCommon/ConstantManager.h     |  10 +-
 Source/Core/VideoCommon/DriverDetails.cpp     |   3 +-
 Source/Core/VideoCommon/FPSCounter.cpp        |   3 +-
 Source/Core/VideoCommon/GXPipelineTypes.h     |   2 +-
 .../VideoCommon/GeometryShaderManager.cpp     |   3 +-
 Source/Core/VideoCommon/HiresTextures.cpp     |  93 +++-
 Source/Core/VideoCommon/HiresTextures.h       |   9 +-
 Source/Core/VideoCommon/PixelShaderGen.cpp    | 472 ++----------------
 Source/Core/VideoCommon/PixelShaderGen.h      |   2 -
 .../Core/VideoCommon/PixelShaderManager.cpp   |  32 +-
 Source/Core/VideoCommon/PixelShaderManager.h  |   1 -
 Source/Core/VideoCommon/RenderState.cpp       | 119 +++--
 Source/Core/VideoCommon/RenderState.h         | 157 ++----
 Source/Core/VideoCommon/SamplerCommon.h       |  27 +
 Source/Core/VideoCommon/ShaderCache.cpp       |   4 +-
 Source/Core/VideoCommon/ShaderGenCommon.cpp   |  28 --
 Source/Core/VideoCommon/ShaderGenCommon.h     |  16 -
 Source/Core/VideoCommon/TMEM.cpp              | 290 -----------
 Source/Core/VideoCommon/TMEM.h                |  26 -
 Source/Core/VideoCommon/TextureCacheBase.cpp  | 370 +++++++-------
 Source/Core/VideoCommon/TextureCacheBase.h    |  17 +-
 Source/Core/VideoCommon/TextureConfig.cpp     |   3 +-
 .../VideoCommon/TextureDecoder_Generic.cpp    |  16 +-
 .../Core/VideoCommon/TextureDecoder_x64.cpp   |   3 +-
 Source/Core/VideoCommon/TextureInfo.cpp       | 315 ------------
 Source/Core/VideoCommon/TextureInfo.h         | 118 -----
 Source/Core/VideoCommon/UberShaderCommon.cpp  |  19 +-
 Source/Core/VideoCommon/UberShaderCommon.h    |  19 +
 Source/Core/VideoCommon/UberShaderPixel.cpp   | 155 ++----
 Source/Core/VideoCommon/UberShaderVertex.cpp  |   2 +-
 Source/Core/VideoCommon/VertexLoaderBase.h    |   5 +-
 .../Core/VideoCommon/VertexLoader_Color.cpp   |   3 +-
 Source/Core/VideoCommon/VertexManagerBase.cpp |   3 +-
 Source/Core/VideoCommon/VideoBackendBase.cpp  |   2 -
 Source/Core/VideoCommon/VideoConfig.cpp       |   1 -
 Source/Core/VideoCommon/VideoConfig.h         |  14 -
 Source/Core/VideoCommon/VideoState.cpp        |   8 +-
 237 files changed, 948 insertions(+), 2549 deletions(-)
 create mode 100644 Source/Core/VideoCommon/SamplerCommon.h
 delete mode 100644 Source/Core/VideoCommon/TMEM.cpp
 delete mode 100644 Source/Core/VideoCommon/TMEM.h
 delete mode 100644 Source/Core/VideoCommon/TextureInfo.cpp
 delete mode 100644 Source/Core/VideoCommon/TextureInfo.h

diff --git a/Source/Core/AudioCommon/AlsaSoundStream.cpp b/Source/Core/AudioCommon/AlsaSoundStream.cpp
index 5645efa..c45d7be 100644
--- a/Source/Core/AudioCommon/AlsaSoundStream.cpp
+++ b/Source/Core/AudioCommon/AlsaSoundStream.cpp
@@ -1,10 +1,9 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "AudioCommon/AlsaSoundStream.h"
-
 #include <mutex>
 
+#include "AudioCommon/AlsaSoundStream.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
 #include "Common/Thread.h"
diff --git a/Source/Core/AudioCommon/AudioStretcher.cpp b/Source/Core/AudioCommon/AudioStretcher.cpp
index a5e54b8..c786dc0 100644
--- a/Source/Core/AudioCommon/AudioStretcher.cpp
+++ b/Source/Core/AudioCommon/AudioStretcher.cpp
@@ -1,12 +1,11 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "AudioCommon/AudioStretcher.h"
-
 #include <algorithm>
 #include <cmath>
 #include <cstddef>
 
+#include "AudioCommon/AudioStretcher.h"
 #include "Common/Logging/Log.h"
 #include "Core/Config/MainSettings.h"
 
diff --git a/Source/Core/AudioCommon/CubebStream.cpp b/Source/Core/AudioCommon/CubebStream.cpp
index b8ccbbd..6d903bb 100644
--- a/Source/Core/AudioCommon/CubebStream.cpp
+++ b/Source/Core/AudioCommon/CubebStream.cpp
@@ -1,10 +1,9 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "AudioCommon/CubebStream.h"
-
 #include <cubeb/cubeb.h>
 
+#include "AudioCommon/CubebStream.h"
 #include "AudioCommon/CubebUtils.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
diff --git a/Source/Core/AudioCommon/CubebUtils.cpp b/Source/Core/AudioCommon/CubebUtils.cpp
index 7b998b1..512535e 100644
--- a/Source/Core/AudioCommon/CubebUtils.cpp
+++ b/Source/Core/AudioCommon/CubebUtils.cpp
@@ -1,12 +1,11 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "AudioCommon/CubebUtils.h"
-
 #include <cstdarg>
 #include <cstddef>
 #include <cstring>
 
+#include "AudioCommon/CubebUtils.h"
 #include "Common/CommonPaths.h"
 #include "Common/Logging/Log.h"
 #include "Common/Logging/LogManager.h"
diff --git a/Source/Core/AudioCommon/Mixer.cpp b/Source/Core/AudioCommon/Mixer.cpp
index f6bebb6..e3b834a 100644
--- a/Source/Core/AudioCommon/Mixer.cpp
+++ b/Source/Core/AudioCommon/Mixer.cpp
@@ -2,12 +2,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "AudioCommon/Mixer.h"
+#include "AudioCommon/Enums.h"
 
 #include <algorithm>
 #include <cmath>
 #include <cstring>
 
-#include "AudioCommon/Enums.h"
 #include "Common/ChunkFile.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
diff --git a/Source/Core/AudioCommon/OpenALStream.cpp b/Source/Core/AudioCommon/OpenALStream.cpp
index cdd4450..45d1aa2 100644
--- a/Source/Core/AudioCommon/OpenALStream.cpp
+++ b/Source/Core/AudioCommon/OpenALStream.cpp
@@ -3,13 +3,12 @@
 
 #ifdef _WIN32
 
-#include "AudioCommon/OpenALStream.h"
-
 #include <windows.h>
 #include <climits>
 #include <cstring>
 #include <thread>
 
+#include "AudioCommon/OpenALStream.h"
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 #include "Common/Thread.h"
diff --git a/Source/Core/AudioCommon/SurroundDecoder.cpp b/Source/Core/AudioCommon/SurroundDecoder.cpp
index ffc0b00..08a1169 100644
--- a/Source/Core/AudioCommon/SurroundDecoder.cpp
+++ b/Source/Core/AudioCommon/SurroundDecoder.cpp
@@ -1,11 +1,11 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "AudioCommon/SurroundDecoder.h"
-
 #include <FreeSurround/FreeSurroundDecoder.h>
 #include <limits>
 
+#include "AudioCommon/SurroundDecoder.h"
+
 namespace AudioCommon
 {
 constexpr size_t STEREO_CHANNELS = 2;
diff --git a/Source/Core/Common/Analytics.cpp b/Source/Core/Common/Analytics.cpp
index 294e05c..31f22b6 100644
--- a/Source/Core/Common/Analytics.cpp
+++ b/Source/Core/Common/Analytics.cpp
@@ -1,13 +1,12 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Analytics.h"
-
 #include <cmath>
 #include <cstdio>
 #include <string>
 #include <type_traits>
 
+#include "Common/Analytics.h"
 #include "Common/CommonTypes.h"
 #include "Common/StringUtil.h"
 #include "Common/Thread.h"
diff --git a/Source/Core/Common/Arm64Emitter.cpp b/Source/Core/Common/Arm64Emitter.cpp
index b5c3293..3d23668 100644
--- a/Source/Core/Common/Arm64Emitter.cpp
+++ b/Source/Core/Common/Arm64Emitter.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Arm64Emitter.h"
-
 #include <algorithm>
 #include <array>
 #include <cstring>
@@ -14,6 +12,7 @@
 #include <fmt/format.h>
 
 #include "Common/Align.h"
+#include "Common/Arm64Emitter.h"
 #include "Common/Assert.h"
 #include "Common/BitUtils.h"
 #include "Common/CommonTypes.h"
diff --git a/Source/Core/Common/ArmCPUDetect.cpp b/Source/Core/Common/ArmCPUDetect.cpp
index a12deac..45b6e67 100644
--- a/Source/Core/Common/ArmCPUDetect.cpp
+++ b/Source/Core/Common/ArmCPUDetect.cpp
@@ -1,8 +1,6 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/CPUDetect.h"
-
 #include <cstring>
 #include <fstream>
 #include <sstream>
@@ -19,6 +17,7 @@
 
 #include <fmt/format.h>
 
+#include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
 #include "Common/FileUtil.h"
 
diff --git a/Source/Core/Common/ArmFPURoundMode.cpp b/Source/Core/Common/ArmFPURoundMode.cpp
index 109e961..1f666d6 100644
--- a/Source/Core/Common/ArmFPURoundMode.cpp
+++ b/Source/Core/Common/ArmFPURoundMode.cpp
@@ -1,16 +1,15 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#include "Common/CPUDetect.h"
+#include "Common/CommonTypes.h"
 #include "Common/FPURoundMode.h"
+#include "Common/Logging/Log.h"
 
 #ifdef _MSC_VER
 #include <intrin.h>
 #endif
 
-#include "Common/CPUDetect.h"
-#include "Common/CommonTypes.h"
-#include "Common/Logging/Log.h"
-
 static u64 GetFPCR()
 {
 #ifdef _MSC_VER
diff --git a/Source/Core/Common/BitField.h b/Source/Core/Common/BitField.h
index 68c0577..20a68c9 100644
--- a/Source/Core/Common/BitField.h
+++ b/Source/Core/Common/BitField.h
@@ -149,7 +149,6 @@ public:
 
   constexpr T Value() const { return Value(std::is_signed<T>()); }
   constexpr operator T() const { return Value(); }
-  static constexpr bool IsSigned() { return std::is_signed<T>(); }
   static constexpr std::size_t StartBit() { return position; }
   static constexpr std::size_t NumBits() { return bits; }
 
@@ -245,7 +244,6 @@ public:
   BitFieldArray& operator=(const BitFieldArray&) = delete;
 
 public:
-  constexpr bool IsSigned() const { return std::is_signed<T>(); }
   constexpr std::size_t StartBit() const { return position; }
   constexpr std::size_t NumBits() const { return bits; }
   constexpr std::size_t Size() const { return size; }
diff --git a/Source/Core/Common/CDUtils.cpp b/Source/Core/Common/CDUtils.cpp
index 630f5d9..6785969 100644
--- a/Source/Core/Common/CDUtils.cpp
+++ b/Source/Core/Common/CDUtils.cpp
@@ -3,8 +3,6 @@
 
 // Most of the code in this file was shamelessly ripped from libcdio With minor adjustments
 
-#include "Common/CDUtils.h"
-
 #include <algorithm>
 #include <cstdlib>
 #include <string>
@@ -12,6 +10,11 @@
 
 #include <fmt/format.h>
 
+#include "Common/CDUtils.h"
+#include "Common/Common.h"
+#include "Common/CommonTypes.h"
+#include "Common/StringUtil.h"
+
 #ifdef _WIN32
 #include <windows.h>
 #elif __APPLE__
@@ -33,10 +36,6 @@
 #include <linux/cdrom.h>
 #endif
 
-#include "Common/Common.h"
-#include "Common/CommonTypes.h"
-#include "Common/StringUtil.h"
-
 namespace Common
 {
 #ifdef _WIN32
diff --git a/Source/Core/Common/CommonFuncs.cpp b/Source/Core/Common/CommonFuncs.cpp
index 6883420..9db88d5 100644
--- a/Source/Core/Common/CommonFuncs.cpp
+++ b/Source/Core/Common/CommonFuncs.cpp
@@ -1,13 +1,13 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/CommonFuncs.h"
-
 #include <cstddef>
 #include <cstring>
 #include <errno.h>
 #include <type_traits>
 
+#include "Common/CommonFuncs.h"
+
 #ifdef _WIN32
 #include <windows.h>
 #define strerror_r(err, buf, len) strerror_s(buf, len, err)
diff --git a/Source/Core/Common/Config/ConfigInfo.cpp b/Source/Core/Common/Config/ConfigInfo.cpp
index e0546bf..8fd736c 100644
--- a/Source/Core/Common/Config/ConfigInfo.cpp
+++ b/Source/Core/Common/Config/ConfigInfo.cpp
@@ -1,11 +1,10 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Config/ConfigInfo.h"
-
 #include <cstring>
 
 #include "Common/CommonFuncs.h"
+#include "Common/Config/ConfigInfo.h"
 
 namespace Config
 {
diff --git a/Source/Core/Common/Config/Layer.cpp b/Source/Core/Common/Config/Layer.cpp
index 5520e02..ace3074 100644
--- a/Source/Core/Common/Config/Layer.cpp
+++ b/Source/Core/Common/Config/Layer.cpp
@@ -1,13 +1,12 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Config/Layer.h"
-
 #include <algorithm>
 #include <cstring>
 #include <map>
 
 #include "Common/Config/Config.h"
+#include "Common/Config/Layer.h"
 
 namespace Config
 {
diff --git a/Source/Core/Common/Crypto/AES.cpp b/Source/Core/Common/Crypto/AES.cpp
index 5412969..7d7ab9c 100644
--- a/Source/Core/Common/Crypto/AES.cpp
+++ b/Source/Core/Common/Crypto/AES.cpp
@@ -1,10 +1,10 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Crypto/AES.h"
-
 #include <mbedtls/aes.h>
 
+#include "Common/Crypto/AES.h"
+
 namespace Common::AES
 {
 std::vector<u8> DecryptEncrypt(const u8* key, u8* iv, const u8* src, size_t size, Mode mode)
diff --git a/Source/Core/Common/Crypto/bn.cpp b/Source/Core/Common/Crypto/bn.cpp
index 3dc8c75..fa38b46 100644
--- a/Source/Core/Common/Crypto/bn.cpp
+++ b/Source/Core/Common/Crypto/bn.cpp
@@ -1,12 +1,11 @@
 // Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Crypto/bn.h"
-
 #include <cstdio>
 #include <cstring>
 
 #include "Common/CommonTypes.h"
+#include "Common/Crypto/bn.h"
 
 static void bn_zero(u8* d, int n)
 {
diff --git a/Source/Core/Common/Crypto/ec.cpp b/Source/Core/Common/Crypto/ec.cpp
index 4cce6ce..6f2aa0b 100644
--- a/Source/Core/Common/Crypto/ec.cpp
+++ b/Source/Core/Common/Crypto/ec.cpp
@@ -2,12 +2,11 @@
 // Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Crypto/ec.h"
-
 #include <algorithm>
 #include <cstring>
 
 #include "Common/Crypto/bn.h"
+#include "Common/Crypto/ec.h"
 #include "Common/Inline.h"
 #include "Common/Random.h"
 #include "Common/StringUtil.h"
diff --git a/Source/Core/Common/ENetUtil.cpp b/Source/Core/Common/ENetUtil.cpp
index 646e7f5..cd9518e 100644
--- a/Source/Core/Common/ENetUtil.cpp
+++ b/Source/Core/Common/ENetUtil.cpp
@@ -1,7 +1,7 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/ENetUtil.h"
+#include "ENetUtil.h"
 
 #include "Common/CommonTypes.h"
 
diff --git a/Source/Core/Common/FileSearch.cpp b/Source/Core/Common/FileSearch.cpp
index 0da6c4f..490835b 100644
--- a/Source/Core/Common/FileSearch.cpp
+++ b/Source/Core/Common/FileSearch.cpp
@@ -1,13 +1,12 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/FileSearch.h"
-
 #include <algorithm>
 #include <functional>
 #include <iterator>
 
 #include "Common/CommonPaths.h"
+#include "Common/FileSearch.h"
 #include "Common/StringUtil.h"
 
 #ifdef _MSC_VER
diff --git a/Source/Core/Common/GL/GLExtensions/GLExtensions.cpp b/Source/Core/Common/GL/GLExtensions/GLExtensions.cpp
index d43e898..e7c41f1 100644
--- a/Source/Core/Common/GL/GLExtensions/GLExtensions.cpp
+++ b/Source/Core/Common/GL/GLExtensions/GLExtensions.cpp
@@ -1,12 +1,11 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/GL/GLExtensions/GLExtensions.h"
-
 #include <sstream>
 #include <unordered_map>
 
 #include "Common/GL/GLContext.h"
+#include "Common/GL/GLExtensions/GLExtensions.h"
 #include "Common/Logging/Log.h"
 
 #if defined(__linux__) || defined(__APPLE__)
diff --git a/Source/Core/Common/GL/GLInterface/EGL.cpp b/Source/Core/Common/GL/GLInterface/EGL.cpp
index 30230e7..090a6cf 100644
--- a/Source/Core/Common/GL/GLInterface/EGL.cpp
+++ b/Source/Core/Common/GL/GLInterface/EGL.cpp
@@ -1,13 +1,12 @@
 // Copyright 2012 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/GL/GLInterface/EGL.h"
-
 #include <array>
 #include <cstdlib>
 #include <sstream>
 #include <vector>
 
+#include "Common/GL/GLInterface/EGL.h"
 #include "Common/Logging/Log.h"
 
 #ifndef EGL_KHR_create_context
diff --git a/Source/Core/Common/GL/GLInterface/EGLAndroid.cpp b/Source/Core/Common/GL/GLInterface/EGLAndroid.cpp
index 873387f..abe8bc3 100644
--- a/Source/Core/Common/GL/GLInterface/EGLAndroid.cpp
+++ b/Source/Core/Common/GL/GLInterface/EGLAndroid.cpp
@@ -2,7 +2,6 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Common/GL/GLInterface/EGLAndroid.h"
-
 #include <android/native_window.h>
 
 EGLDisplay GLContextEGLAndroid::OpenEGLDisplay()
diff --git a/Source/Core/Common/GL/GLInterface/GLX.cpp b/Source/Core/Common/GL/GLInterface/GLX.cpp
index 930994a..5154424 100644
--- a/Source/Core/Common/GL/GLInterface/GLX.cpp
+++ b/Source/Core/Common/GL/GLInterface/GLX.cpp
@@ -1,11 +1,10 @@
 // Copyright 2012 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/GL/GLInterface/GLX.h"
-
 #include <array>
 #include <sstream>
 
+#include "Common/GL/GLInterface/GLX.h"
 #include "Common/Logging/Log.h"
 
 #define GLX_CONTEXT_MAJOR_VERSION_ARB 0x2091
diff --git a/Source/Core/Common/GL/GLInterface/WGL.cpp b/Source/Core/Common/GL/GLInterface/WGL.cpp
index 286859d..d0d343b 100644
--- a/Source/Core/Common/GL/GLInterface/WGL.cpp
+++ b/Source/Core/Common/GL/GLInterface/WGL.cpp
@@ -1,12 +1,11 @@
 // Copyright 2012 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/GL/GLInterface/WGL.h"
-
 #include <windows.h>
 #include <array>
 #include <string>
 
+#include "Common/GL/GLInterface/WGL.h"
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 
diff --git a/Source/Core/Common/GL/GLUtil.cpp b/Source/Core/Common/GL/GLUtil.cpp
index 9f65e71..216487c 100644
--- a/Source/Core/Common/GL/GLUtil.cpp
+++ b/Source/Core/Common/GL/GLUtil.cpp
@@ -1,12 +1,11 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/GL/GLUtil.h"
-
 #include <memory>
 
 #include "Common/Assert.h"
 #include "Common/GL/GLContext.h"
+#include "Common/GL/GLUtil.h"
 #include "Common/Logging/Log.h"
 
 namespace GLUtil
diff --git a/Source/Core/Common/GenericFPURoundMode.cpp b/Source/Core/Common/GenericFPURoundMode.cpp
index 803a327..b5075a9 100644
--- a/Source/Core/Common/GenericFPURoundMode.cpp
+++ b/Source/Core/Common/GenericFPURoundMode.cpp
@@ -1,9 +1,8 @@
 // Copyright 2003 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/FPURoundMode.h"
-
 #include "Common/CommonTypes.h"
+#include "Common/FPURoundMode.h"
 
 // Generic, do nothing
 namespace FPURoundMode
diff --git a/Source/Core/Common/IOFile.cpp b/Source/Core/Common/IOFile.cpp
index 1378906..5ecec71 100644
--- a/Source/Core/Common/IOFile.cpp
+++ b/Source/Core/Common/IOFile.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/IOFile.h"
-
 #include <cstddef>
 #include <cstdio>
 #include <string>
@@ -24,6 +22,7 @@
 
 #include "Common/CommonTypes.h"
 #include "Common/FileUtil.h"
+#include "Common/IOFile.h"
 
 namespace File
 {
diff --git a/Source/Core/Common/LdrWatcher.cpp b/Source/Core/Common/LdrWatcher.cpp
index 4e3fb88..35b2a33 100644
--- a/Source/Core/Common/LdrWatcher.cpp
+++ b/Source/Core/Common/LdrWatcher.cpp
@@ -1,13 +1,13 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/LdrWatcher.h"
-
 #include <Windows.h>
 #include <TlHelp32.h>
 #include <string>
 #include <winternl.h>
 
+#include "Common/LdrWatcher.h"
+
 typedef struct _LDR_DLL_LOADED_NOTIFICATION_DATA
 {
   ULONG Flags;                   // Reserved.
diff --git a/Source/Core/Common/Logging/ConsoleListenerDroid.cpp b/Source/Core/Common/Logging/ConsoleListenerDroid.cpp
index ac64f0c..f6832ce 100644
--- a/Source/Core/Common/Logging/ConsoleListenerDroid.cpp
+++ b/Source/Core/Common/Logging/ConsoleListenerDroid.cpp
@@ -1,10 +1,10 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Logging/ConsoleListener.h"
-
 #include <android/log.h>
 
+#include "Common/Logging/ConsoleListener.h"
+
 ConsoleListener::ConsoleListener()
 {
 }
diff --git a/Source/Core/Common/Logging/ConsoleListenerNix.cpp b/Source/Core/Common/Logging/ConsoleListenerNix.cpp
index 99f4018..7908bdd 100644
--- a/Source/Core/Common/Logging/ConsoleListenerNix.cpp
+++ b/Source/Core/Common/Logging/ConsoleListenerNix.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Logging/ConsoleListener.h"
-
 #include <cstdio>
 #include <cstring>
 
@@ -10,6 +8,7 @@
 #include <unistd.h>
 #endif
 
+#include "Common/Logging/ConsoleListener.h"
 #include "Common/Logging/Log.h"
 
 ConsoleListener::ConsoleListener()
diff --git a/Source/Core/Common/Logging/ConsoleListenerWin.cpp b/Source/Core/Common/Logging/ConsoleListenerWin.cpp
index 7b4f08f..741c2e3 100644
--- a/Source/Core/Common/Logging/ConsoleListenerWin.cpp
+++ b/Source/Core/Common/Logging/ConsoleListenerWin.cpp
@@ -1,10 +1,9 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Logging/ConsoleListener.h"
-
 #include <windows.h>
 
+#include "Common/Logging/ConsoleListener.h"
 #include "Common/StringUtil.h"
 
 ConsoleListener::ConsoleListener()
diff --git a/Source/Core/Common/Matrix.cpp b/Source/Core/Common/Matrix.cpp
index 724d28f..8e4d504 100644
--- a/Source/Core/Common/Matrix.cpp
+++ b/Source/Core/Common/Matrix.cpp
@@ -3,11 +3,11 @@
 
 #include "Common/Matrix.h"
 
+#include "Common/MathUtil.h"
+
 #include <algorithm>
 #include <cmath>
 
-#include "Common/MathUtil.h"
-
 namespace
 {
 // Multiply a NxM matrix by a MxP matrix.
diff --git a/Source/Core/Common/MemoryUtil.cpp b/Source/Core/Common/MemoryUtil.cpp
index 858135b..2088916 100644
--- a/Source/Core/Common/MemoryUtil.cpp
+++ b/Source/Core/Common/MemoryUtil.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/MemoryUtil.h"
-
 #include <cstddef>
 #include <cstdlib>
 #include <string>
@@ -10,6 +8,7 @@
 #include "Common/CommonFuncs.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
+#include "Common/MemoryUtil.h"
 #include "Common/MsgHandler.h"
 
 #ifdef _WIN32
diff --git a/Source/Core/Common/PcapFile.cpp b/Source/Core/Common/PcapFile.cpp
index 71fcdc9..56b3ece 100644
--- a/Source/Core/Common/PcapFile.cpp
+++ b/Source/Core/Common/PcapFile.cpp
@@ -1,12 +1,11 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/PcapFile.h"
-
 #include <chrono>
 
 #include "Common/CommonTypes.h"
 #include "Common/IOFile.h"
+#include "Common/PcapFile.h"
 
 namespace Common
 {
diff --git a/Source/Core/Common/PerformanceCounter.cpp b/Source/Core/Common/PerformanceCounter.cpp
index efe78e3..5df0c0d 100644
--- a/Source/Core/Common/PerformanceCounter.cpp
+++ b/Source/Core/Common/PerformanceCounter.cpp
@@ -2,7 +2,6 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #if !defined(_WIN32)
-#include "Common/PerformanceCounter.h"
 
 #include <cstdint>
 #include <ctime>
@@ -10,6 +9,7 @@
 #include <unistd.h>
 
 #include "Common/CommonTypes.h"
+#include "Common/PerformanceCounter.h"
 
 #if defined(_POSIX_TIMERS) && _POSIX_TIMERS > 0
 #if defined(_POSIX_MONOTONIC_CLOCK) && _POSIX_MONOTONIC_CLOCK > 0
diff --git a/Source/Core/Common/Profiler.cpp b/Source/Core/Common/Profiler.cpp
index 6e35318..1b1053b 100644
--- a/Source/Core/Common/Profiler.cpp
+++ b/Source/Core/Common/Profiler.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/Profiler.h"
-
 #include <algorithm>
 #include <cmath>
 #include <cstdio>
@@ -11,6 +9,7 @@
 #include <ios>
 #include <sstream>
 
+#include "Common/Profiler.h"
 #include "Common/Timer.h"
 
 namespace Common
diff --git a/Source/Core/Common/QoSSession.cpp b/Source/Core/Common/QoSSession.cpp
index f143517..b7c0258 100644
--- a/Source/Core/Common/QoSSession.cpp
+++ b/Source/Core/Common/QoSSession.cpp
@@ -2,14 +2,13 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Common/QoSSession.h"
+#include "Core/ConfigManager.h"
 
 #if defined(_WIN32)
 #include <Qos2.h>
 #pragma comment(lib, "qwave")
 #endif
 
-#include "Core/ConfigManager.h"
-
 namespace Common
 {
 #if defined(_WIN32)
diff --git a/Source/Core/Common/SymbolDB.cpp b/Source/Core/Common/SymbolDB.cpp
index f9d352b..361444d 100644
--- a/Source/Core/Common/SymbolDB.cpp
+++ b/Source/Core/Common/SymbolDB.cpp
@@ -1,8 +1,6 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/SymbolDB.h"
-
 #include <cstring>
 #include <map>
 #include <string>
@@ -10,6 +8,7 @@
 
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
+#include "Common/SymbolDB.h"
 
 namespace Common
 {
diff --git a/Source/Core/Common/Thread.cpp b/Source/Core/Common/Thread.cpp
index 7bbc27e..a0967e5 100644
--- a/Source/Core/Common/Thread.cpp
+++ b/Source/Core/Common/Thread.cpp
@@ -2,6 +2,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Common/Thread.h"
+#include "Common/CommonFuncs.h"
+#include "Common/CommonTypes.h"
+#include "Common/StringUtil.h"
 
 #ifdef _WIN32
 #include <Windows.h>
@@ -25,10 +28,6 @@
 #pragma comment(lib, "libittnotify.lib")
 #endif
 
-#include "Common/CommonFuncs.h"
-#include "Common/CommonTypes.h"
-#include "Common/StringUtil.h"
-
 namespace Common
 {
 int CurrentThreadId()
diff --git a/Source/Core/Common/x64Emitter.cpp b/Source/Core/Common/x64Emitter.cpp
index d583765..5f73066 100644
--- a/Source/Core/Common/x64Emitter.cpp
+++ b/Source/Core/Common/x64Emitter.cpp
@@ -1,13 +1,12 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/x64Emitter.h"
-
 #include <cstring>
 
 #include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
+#include "Common/x64Emitter.h"
 #include "Common/x64Reg.h"
 
 namespace Gen
diff --git a/Source/Core/Common/x64FPURoundMode.cpp b/Source/Core/Common/x64FPURoundMode.cpp
index 553c96b..f694223 100644
--- a/Source/Core/Common/x64FPURoundMode.cpp
+++ b/Source/Core/Common/x64FPURoundMode.cpp
@@ -1,12 +1,11 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Common/FPURoundMode.h"
-
 #include <cfenv>
 
 #include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
+#include "Common/FPURoundMode.h"
 #include "Common/Intrinsics.h"
 
 namespace FPURoundMode
diff --git a/Source/Core/Core/CheatGeneration.cpp b/Source/Core/Core/CheatGeneration.cpp
index e6120a0..8011a87 100644
--- a/Source/Core/Core/CheatGeneration.cpp
+++ b/Source/Core/Core/CheatGeneration.cpp
@@ -1,12 +1,12 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/CheatGeneration.h"
-
 #include <vector>
 
 #include <fmt/format.h>
 
+#include "Core/CheatGeneration.h"
+
 #include "Common/Align.h"
 #include "Common/CommonTypes.h"
 #include "Common/Result.h"
diff --git a/Source/Core/Core/Config/FreeLookSettings.cpp b/Source/Core/Core/Config/FreeLookSettings.cpp
index 7ac600c..ee8d27c 100644
--- a/Source/Core/Core/Config/FreeLookSettings.cpp
+++ b/Source/Core/Core/Config/FreeLookSettings.cpp
@@ -2,11 +2,11 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Core/Config/FreeLookSettings.h"
+#include "Core/FreeLookConfig.h"
 
 #include <string>
 
 #include "Common/Config/Config.h"
-#include "Core/FreeLookConfig.h"
 
 namespace Config
 {
diff --git a/Source/Core/Core/Config/GraphicsSettings.cpp b/Source/Core/Core/Config/GraphicsSettings.cpp
index 1015bd4..fdf128f 100644
--- a/Source/Core/Core/Config/GraphicsSettings.cpp
+++ b/Source/Core/Core/Config/GraphicsSettings.cpp
@@ -151,8 +151,6 @@ const Info<bool> GFX_HACK_EFB_EMULATE_FORMAT_CHANGES{
 const Info<bool> GFX_HACK_VERTEX_ROUDING{{System::GFX, "Hacks", "VertexRounding"}, false};
 const Info<u32> GFX_HACK_MISSING_COLOR_VALUE{{System::GFX, "Hacks", "MissingColorValue"},
                                              0xFFFFFFFF};
-const Info<bool> GFX_HACK_FAST_TEXTURE_SAMPLING{{System::GFX, "Hacks", "FastTextureSampling"},
-                                                true};
 
 // Graphics.GameSpecific
 
diff --git a/Source/Core/Core/Config/GraphicsSettings.h b/Source/Core/Core/Config/GraphicsSettings.h
index e5289a3..2c6aa4c 100644
--- a/Source/Core/Core/Config/GraphicsSettings.h
+++ b/Source/Core/Core/Config/GraphicsSettings.h
@@ -124,7 +124,6 @@ extern const Info<bool> GFX_HACK_COPY_EFB_SCALED;
 extern const Info<bool> GFX_HACK_EFB_EMULATE_FORMAT_CHANGES;
 extern const Info<bool> GFX_HACK_VERTEX_ROUDING;
 extern const Info<u32> GFX_HACK_MISSING_COLOR_VALUE;
-extern const Info<bool> GFX_HACK_FAST_TEXTURE_SAMPLING;
 
 // Graphics.GameSpecific
 
diff --git a/Source/Core/Core/DSP/DSPAccelerator.cpp b/Source/Core/Core/DSP/DSPAccelerator.cpp
index bdfcb65..afa2bbc 100644
--- a/Source/Core/Core/DSP/DSPAccelerator.cpp
+++ b/Source/Core/Core/DSP/DSPAccelerator.cpp
@@ -1,10 +1,10 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/DSPAccelerator.h"
-
 #include <algorithm>
 
+#include "Core/DSP/DSPAccelerator.h"
+
 #include "Common/ChunkFile.h"
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
diff --git a/Source/Core/Core/DSP/DSPHWInterface.cpp b/Source/Core/Core/DSP/DSPHWInterface.cpp
index 7cdd4d0..3f2dcec 100644
--- a/Source/Core/Core/DSP/DSPHWInterface.cpp
+++ b/Source/Core/Core/DSP/DSPHWInterface.cpp
@@ -2,8 +2,6 @@
 // Copyright 2004 Duddie & Tratax
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/DSPCore.h"
-
 #include <atomic>
 #include <cstddef>
 #include <cstring>
@@ -16,6 +14,7 @@
 #include "Common/Swap.h"
 
 #include "Core/DSP/DSPAccelerator.h"
+#include "Core/DSP/DSPCore.h"
 #include "Core/DSP/DSPHost.h"
 #include "Core/DSP/DSPTables.h"
 
diff --git a/Source/Core/Core/DSP/DSPMemoryMap.cpp b/Source/Core/Core/DSP/DSPMemoryMap.cpp
index 1554e52..1e0ea30 100644
--- a/Source/Core/Core/DSP/DSPMemoryMap.cpp
+++ b/Source/Core/Core/DSP/DSPMemoryMap.cpp
@@ -2,10 +2,9 @@
 // Copyright 2004 Duddie & Tratax
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/DSPCore.h"
-
 #include "Common/Logging/Log.h"
 
+#include "Core/DSP/DSPCore.h"
 #include "Core/DSP/DSPTables.h"
 
 namespace DSP
diff --git a/Source/Core/Core/DSP/DSPStacks.cpp b/Source/Core/Core/DSP/DSPStacks.cpp
index 6020758..9a3bf9f 100644
--- a/Source/Core/Core/DSP/DSPStacks.cpp
+++ b/Source/Core/Core/DSP/DSPStacks.cpp
@@ -2,11 +2,10 @@
 // Copyright 2004 Duddie & Tratax
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/DSPCore.h"
-
 #include <cstddef>
 
 #include "Common/CommonTypes.h"
+#include "Core/DSP/DSPCore.h"
 
 // Stacks. The stacks are outside the DSP RAM, in dedicated hardware.
 namespace DSP
diff --git a/Source/Core/Core/DSP/Interpreter/DSPIntArithmetic.cpp b/Source/Core/Core/DSP/Interpreter/DSPIntArithmetic.cpp
index 9a6e133..c4319db 100644
--- a/Source/Core/Core/DSP/Interpreter/DSPIntArithmetic.cpp
+++ b/Source/Core/Core/DSP/Interpreter/DSPIntArithmetic.cpp
@@ -3,10 +3,9 @@
 //
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Interpreter/DSPInterpreter.h"
-
 #include "Core/DSP/Interpreter/DSPIntCCUtil.h"
 #include "Core/DSP/Interpreter/DSPIntUtil.h"
+#include "Core/DSP/Interpreter/DSPInterpreter.h"
 
 // Arithmetic and accumulator control.
 
diff --git a/Source/Core/Core/DSP/Interpreter/DSPIntBranch.cpp b/Source/Core/Core/DSP/Interpreter/DSPIntBranch.cpp
index 8b2aca8..5f67d95 100644
--- a/Source/Core/Core/DSP/Interpreter/DSPIntBranch.cpp
+++ b/Source/Core/Core/DSP/Interpreter/DSPIntBranch.cpp
@@ -3,9 +3,8 @@
 //
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Interpreter/DSPInterpreter.h"
-
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Interpreter/DSPInterpreter.h"
 
 namespace DSP::Interpreter
 {
diff --git a/Source/Core/Core/DSP/Interpreter/DSPIntLoadStore.cpp b/Source/Core/Core/DSP/Interpreter/DSPIntLoadStore.cpp
index 17973a9..df6fb4c 100644
--- a/Source/Core/Core/DSP/Interpreter/DSPIntLoadStore.cpp
+++ b/Source/Core/Core/DSP/Interpreter/DSPIntLoadStore.cpp
@@ -3,9 +3,8 @@
 //
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Interpreter/DSPInterpreter.h"
-
 #include "Common/CommonTypes.h"
+#include "Core/DSP/Interpreter/DSPInterpreter.h"
 
 namespace DSP::Interpreter
 {
diff --git a/Source/Core/Core/DSP/Interpreter/DSPIntMisc.cpp b/Source/Core/Core/DSP/Interpreter/DSPIntMisc.cpp
index 7b1971a..4335bb2 100644
--- a/Source/Core/Core/DSP/Interpreter/DSPIntMisc.cpp
+++ b/Source/Core/Core/DSP/Interpreter/DSPIntMisc.cpp
@@ -3,11 +3,10 @@
 //
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Interpreter/DSPInterpreter.h"
-
 #include "Core/DSP/DSPCore.h"
 #include "Core/DSP/DSPTables.h"
 #include "Core/DSP/Interpreter/DSPIntUtil.h"
+#include "Core/DSP/Interpreter/DSPInterpreter.h"
 
 namespace DSP::Interpreter
 {
diff --git a/Source/Core/Core/DSP/Interpreter/DSPIntMultiplier.cpp b/Source/Core/Core/DSP/Interpreter/DSPIntMultiplier.cpp
index 9f94505..0816e8d 100644
--- a/Source/Core/Core/DSP/Interpreter/DSPIntMultiplier.cpp
+++ b/Source/Core/Core/DSP/Interpreter/DSPIntMultiplier.cpp
@@ -5,11 +5,10 @@
 
 // Multiplier and product register control
 
-#include "Core/DSP/Interpreter/DSPInterpreter.h"
-
 #include "Core/DSP/DSPTables.h"
 #include "Core/DSP/Interpreter/DSPIntCCUtil.h"
 #include "Core/DSP/Interpreter/DSPIntUtil.h"
+#include "Core/DSP/Interpreter/DSPInterpreter.h"
 
 namespace DSP::Interpreter
 {
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitArithmetic.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitArithmetic.cpp
index 864c488..1a9270c 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitArithmetic.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitArithmetic.cpp
@@ -3,10 +3,10 @@
 
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
+
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitBranch.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitBranch.cpp
index 12e70e4..81ee4f6 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitBranch.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitBranch.cpp
@@ -1,13 +1,12 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
 
 #include "Core/DSP/DSPAnalyzer.h"
 #include "Core/DSP/DSPCore.h"
 #include "Core/DSP/DSPTables.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitCCUtil.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitCCUtil.cpp
index 30cd5d8..a891d0c 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitCCUtil.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitCCUtil.cpp
@@ -3,9 +3,8 @@
 
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitExtOps.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitExtOps.cpp
index d84b626..9614723 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitExtOps.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitExtOps.cpp
@@ -1,11 +1,10 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
 
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitLoadStore.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitLoadStore.cpp
index 29ed5f0..282bc16 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitLoadStore.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitLoadStore.cpp
@@ -3,11 +3,10 @@
 
 // Additional copyrights go to Duddie and Tratax (c) 2004
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
 
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitMisc.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitMisc.cpp
index a5e3d20..0e0dd08 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitMisc.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitMisc.cpp
@@ -1,11 +1,10 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
 
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitMultiplier.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitMultiplier.cpp
index d37e7fd..7fba07f 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitMultiplier.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitMultiplier.cpp
@@ -5,13 +5,12 @@
 
 // Multiplier and product register control
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include <cstddef>
 
 #include "Common/CommonTypes.h"
 
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/DSP/Jit/x64/DSPJitUtil.cpp b/Source/Core/Core/DSP/Jit/x64/DSPJitUtil.cpp
index 67c66e0..bbf97b9 100644
--- a/Source/Core/Core/DSP/Jit/x64/DSPJitUtil.cpp
+++ b/Source/Core/Core/DSP/Jit/x64/DSPJitUtil.cpp
@@ -1,11 +1,11 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/DSP/Jit/x64/DSPEmitter.h"
-
 #include "Common/CommonTypes.h"
+
 #include "Common/Logging/Log.h"
 #include "Core/DSP/DSPCore.h"
+#include "Core/DSP/Jit/x64/DSPEmitter.h"
 
 using namespace Gen;
 
diff --git a/Source/Core/Core/HW/EXI/BBA/TAPServer_Apple.cpp b/Source/Core/Core/HW/EXI/BBA/TAPServer_Apple.cpp
index ad87b5e..516b79a 100644
--- a/Source/Core/Core/HW/EXI/BBA/TAPServer_Apple.cpp
+++ b/Source/Core/Core/HW/EXI/BBA/TAPServer_Apple.cpp
@@ -1,8 +1,6 @@
 // Copyright 2020 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/EXI/EXI_DeviceEthernet.h"
-
 #include <fcntl.h>
 #include <sys/socket.h>
 #include <sys/un.h>
@@ -11,6 +9,7 @@
 #include "Common/Logging/Log.h"
 #include "Common/StringUtil.h"
 #include "Core/HW/EXI/EXI_Device.h"
+#include "Core/HW/EXI/EXI_DeviceEthernet.h"
 
 namespace ExpansionInterface
 {
diff --git a/Source/Core/Core/HW/EXI/BBA/TAP_Apple.cpp b/Source/Core/Core/HW/EXI/BBA/TAP_Apple.cpp
index b6aa647..2dbff03 100644
--- a/Source/Core/Core/HW/EXI/BBA/TAP_Apple.cpp
+++ b/Source/Core/Core/HW/EXI/BBA/TAP_Apple.cpp
@@ -1,14 +1,13 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/EXI/EXI_DeviceEthernet.h"
-
 #include <fcntl.h>
 #include <unistd.h>
 
 #include "Common/Logging/Log.h"
 #include "Common/StringUtil.h"
 #include "Core/HW/EXI/EXI_Device.h"
+#include "Core/HW/EXI/EXI_DeviceEthernet.h"
 
 namespace ExpansionInterface
 {
diff --git a/Source/Core/Core/HW/EXI/BBA/TAP_Unix.cpp b/Source/Core/Core/HW/EXI/BBA/TAP_Unix.cpp
index 4904b2a..a0673e9 100644
--- a/Source/Core/Core/HW/EXI/BBA/TAP_Unix.cpp
+++ b/Source/Core/Core/HW/EXI/BBA/TAP_Unix.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/EXI/EXI_DeviceEthernet.h"
-
 #include <cstring>
 
 #ifndef _WIN32
@@ -12,6 +10,7 @@
 #include "Common/Logging/Log.h"
 #include "Common/StringUtil.h"
 #include "Core/HW/EXI/EXI_Device.h"
+#include "Core/HW/EXI/EXI_DeviceEthernet.h"
 
 #ifdef __linux__
 #include <fcntl.h>
diff --git a/Source/Core/Core/HW/EXI/BBA/TAP_Win32.cpp b/Source/Core/Core/HW/EXI/BBA/TAP_Win32.cpp
index 1f3b9fc..1d9b509 100644
--- a/Source/Core/Core/HW/EXI/BBA/TAP_Win32.cpp
+++ b/Source/Core/Core/HW/EXI/BBA/TAP_Win32.cpp
@@ -2,13 +2,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Core/HW/EXI/BBA/TAP_Win32.h"
-#include "Core/HW/EXI/EXI_DeviceEthernet.h"
-
 #include "Common/Assert.h"
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 #include "Common/StringUtil.h"
 #include "Core/HW/EXI/EXI_Device.h"
+#include "Core/HW/EXI/EXI_DeviceEthernet.h"
 
 namespace Win32TAPHelper
 {
diff --git a/Source/Core/Core/HW/EXI/EXI_DeviceIPL.cpp b/Source/Core/Core/HW/EXI/EXI_DeviceIPL.cpp
index e55f880..475a09f 100644
--- a/Source/Core/Core/HW/EXI/EXI_DeviceIPL.cpp
+++ b/Source/Core/Core/HW/EXI/EXI_DeviceIPL.cpp
@@ -2,6 +2,7 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Core/HW/EXI/EXI_DeviceIPL.h"
+#include "Core/HW/DVD/DVDInterface.h"
 
 #include <cstring>
 #include <string>
diff --git a/Source/Core/Core/HW/SI/SI_DeviceGBAEmu.cpp b/Source/Core/Core/HW/SI/SI_DeviceGBAEmu.cpp
index bb9a6d1..12e533d 100644
--- a/Source/Core/Core/HW/SI/SI_DeviceGBAEmu.cpp
+++ b/Source/Core/Core/HW/SI/SI_DeviceGBAEmu.cpp
@@ -1,8 +1,6 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/SI/SI_DeviceGBAEmu.h"
-
 #include <vector>
 
 #include "Common/ChunkFile.h"
@@ -14,6 +12,7 @@
 #include "Core/HW/GBACore.h"
 #include "Core/HW/GBAPad.h"
 #include "Core/HW/SI/SI.h"
+#include "Core/HW/SI/SI_DeviceGBAEmu.h"
 #include "Core/HW/SI/SI_DeviceGCController.h"
 #include "Core/HW/SystemTimers.h"
 #include "Core/Host.h"
diff --git a/Source/Core/Core/HW/SI/SI_DeviceNull.cpp b/Source/Core/Core/HW/SI/SI_DeviceNull.cpp
index 72e769e..910e5d0 100644
--- a/Source/Core/Core/HW/SI/SI_DeviceNull.cpp
+++ b/Source/Core/Core/HW/SI/SI_DeviceNull.cpp
@@ -2,6 +2,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "Core/HW/SI/SI_DeviceNull.h"
+#include "Common/Swap.h"
+
+#include <cstring>
 
 namespace SerialInterface
 {
diff --git a/Source/Core/Core/HW/StreamADPCM.cpp b/Source/Core/Core/HW/StreamADPCM.cpp
index 07ede79..b23a1eb 100644
--- a/Source/Core/Core/HW/StreamADPCM.cpp
+++ b/Source/Core/Core/HW/StreamADPCM.cpp
@@ -3,10 +3,10 @@
 
 // Adapted from in_cube by hcs & destop
 
-#include "Core/HW/StreamADPCM.h"
-
 #include <algorithm>
 
+#include "Core/HW/StreamADPCM.h"
+
 #include "Common/ChunkFile.h"
 #include "Common/CommonTypes.h"
 
diff --git a/Source/Core/Core/HW/WiimoteEmu/EmuSubroutines.cpp b/Source/Core/Core/HW/WiimoteEmu/EmuSubroutines.cpp
index 8f0cce5..631d395 100644
--- a/Source/Core/Core/HW/WiimoteEmu/EmuSubroutines.cpp
+++ b/Source/Core/Core/HW/WiimoteEmu/EmuSubroutines.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/WiimoteEmu/WiimoteEmu.h"
-
 #include <cmath>
 #include <fstream>
 #include <iterator>
@@ -16,8 +14,9 @@
 #include "Common/Swap.h"
 #include "Core/Core.h"
 #include "Core/DolphinAnalytics.h"
-#include "Core/HW/Wiimote.h"
 #include "Core/HW/WiimoteCommon/WiimoteHid.h"
+#include "Core/HW/WiimoteEmu/WiimoteEmu.h"
+#include "Core/HW/WiimoteReal/WiimoteReal.h"
 #include "InputCommon/ControllerEmu/ControlGroup/Attachments.h"
 
 namespace WiimoteEmu
diff --git a/Source/Core/Core/HW/WiimoteReal/IOAndroid.cpp b/Source/Core/Core/HW/WiimoteReal/IOAndroid.cpp
index 10234ce..fbc319b 100644
--- a/Source/Core/Core/HW/WiimoteReal/IOAndroid.cpp
+++ b/Source/Core/Core/HW/WiimoteReal/IOAndroid.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/WiimoteReal/IOAndroid.h"
-
 #include <jni.h>
 
 #include "Common/CommonTypes.h"
@@ -13,6 +11,8 @@
 #include "Common/Thread.h"
 #include "Common/Timer.h"
 
+#include "Core/HW/WiimoteReal/IOAndroid.h"
+
 #include "jni/AndroidCommon/IDCache.h"
 
 namespace WiimoteReal
diff --git a/Source/Core/Core/HW/WiimoteReal/IOLinux.cpp b/Source/Core/Core/HW/WiimoteReal/IOLinux.cpp
index b8db0b6..7326ae7 100644
--- a/Source/Core/Core/HW/WiimoteReal/IOLinux.cpp
+++ b/Source/Core/Core/HW/WiimoteReal/IOLinux.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/WiimoteReal/IOLinux.h"
-
 #include <bluetooth/bluetooth.h>
 #include <bluetooth/hci.h>
 #include <bluetooth/hci_lib.h>
@@ -12,6 +10,7 @@
 
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
+#include "Core/HW/WiimoteReal/IOLinux.h"
 
 namespace WiimoteReal
 {
diff --git a/Source/Core/Core/HW/WiimoteReal/IOWin.cpp b/Source/Core/Core/HW/WiimoteReal/IOWin.cpp
index 2079ed9..fbe21ab 100644
--- a/Source/Core/Core/HW/WiimoteReal/IOWin.cpp
+++ b/Source/Core/Core/HW/WiimoteReal/IOWin.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/WiimoteReal/IOWin.h"
-
 #include <algorithm>
 #include <cstdio>
 #include <cstdlib>
@@ -33,6 +31,7 @@
 #include "Core/HW/WiimoteCommon/DataReport.h"
 #include "Core/HW/WiimoteCommon/WiimoteConstants.h"
 #include "Core/HW/WiimoteCommon/WiimoteReport.h"
+#include "Core/HW/WiimoteReal/IOWin.h"
 
 // Create func_t function pointer type and declare a nullptr-initialized static variable of that
 // type named "pfunc".
diff --git a/Source/Core/Core/HW/WiimoteReal/IOhidapi.cpp b/Source/Core/Core/HW/WiimoteReal/IOhidapi.cpp
index ca0c2c5..ff0de2e 100644
--- a/Source/Core/Core/HW/WiimoteReal/IOhidapi.cpp
+++ b/Source/Core/Core/HW/WiimoteReal/IOhidapi.cpp
@@ -1,14 +1,13 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/HW/WiimoteReal/IOhidapi.h"
-
 #include <algorithm>
 
 #include "Common/Assert.h"
 #include "Common/Logging/Log.h"
 #include "Common/StringUtil.h"
 #include "Core/HW/WiimoteCommon/WiimoteHid.h"
+#include "Core/HW/WiimoteReal/IOhidapi.h"
 
 using namespace WiimoteCommon;
 using namespace WiimoteReal;
diff --git a/Source/Core/Core/IOS/ES/NandUtils.cpp b/Source/Core/Core/IOS/ES/NandUtils.cpp
index af0b17f..ddba2c2 100644
--- a/Source/Core/Core/IOS/ES/NandUtils.cpp
+++ b/Source/Core/Core/IOS/ES/NandUtils.cpp
@@ -1,8 +1,6 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/IOS/ES/ES.h"
-
 #include <algorithm>
 #include <array>
 #include <cctype>
@@ -19,6 +17,7 @@
 #include "Common/NandPaths.h"
 #include "Common/ScopeGuard.h"
 #include "Common/StringUtil.h"
+#include "Core/IOS/ES/ES.h"
 #include "Core/IOS/ES/Formats.h"
 #include "Core/IOS/FS/FileSystemProxy.h"
 #include "Core/IOS/Uids.h"
diff --git a/Source/Core/Core/IOS/FS/HostBackend/FS.cpp b/Source/Core/Core/IOS/FS/HostBackend/FS.cpp
index 2e2fee3..fce3967 100644
--- a/Source/Core/Core/IOS/FS/HostBackend/FS.cpp
+++ b/Source/Core/Core/IOS/FS/HostBackend/FS.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/IOS/FS/HostBackend/FS.h"
-
 #include <algorithm>
 #include <optional>
 #include <string_view>
@@ -19,6 +17,7 @@
 #include "Common/StringUtil.h"
 #include "Common/Swap.h"
 #include "Core/IOS/ES/ES.h"
+#include "Core/IOS/FS/HostBackend/FS.h"
 #include "Core/IOS/IOS.h"
 
 namespace IOS::HLE::FS
diff --git a/Source/Core/Core/IOS/FS/HostBackend/File.cpp b/Source/Core/Core/IOS/FS/HostBackend/File.cpp
index 1e4ea5e..bdc4518 100644
--- a/Source/Core/Core/IOS/FS/HostBackend/File.cpp
+++ b/Source/Core/Core/IOS/FS/HostBackend/File.cpp
@@ -1,8 +1,6 @@
 // Copyright 2018 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/IOS/FS/HostBackend/FS.h"
-
 #include <algorithm>
 #include <memory>
 
@@ -11,6 +9,8 @@
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 
+#include "Core/IOS/FS/HostBackend/FS.h"
+
 namespace IOS::HLE::FS
 {
 // This isn't theadsafe, but it's only called from the CPU thread.
diff --git a/Source/Core/Core/LibusbUtils.cpp b/Source/Core/Core/LibusbUtils.cpp
index 8ab2f40..2195825 100644
--- a/Source/Core/Core/LibusbUtils.cpp
+++ b/Source/Core/Core/LibusbUtils.cpp
@@ -1,8 +1,6 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/LibusbUtils.h"
-
 #include <mutex>
 #include <thread>
 
@@ -13,6 +11,7 @@
 #include "Common/Assert.h"
 #include "Common/Flag.h"
 #include "Common/Thread.h"
+#include "Core/LibusbUtils.h"
 
 namespace LibusbUtils
 {
diff --git a/Source/Core/Core/MemoryWatcher.cpp b/Source/Core/Core/MemoryWatcher.cpp
index ec30fa6..343f9d0 100644
--- a/Source/Core/Core/MemoryWatcher.cpp
+++ b/Source/Core/Core/MemoryWatcher.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/MemoryWatcher.h"
-
 #include <cstring>
 #include <fstream>
 #include <iostream>
@@ -11,6 +9,7 @@
 
 #include "Common/FileUtil.h"
 #include "Core/HW/SystemTimers.h"
+#include "Core/MemoryWatcher.h"
 #include "Core/PowerPC/MMU.h"
 
 MemoryWatcher::MemoryWatcher()
diff --git a/Source/Core/Core/MemoryWatcher.h b/Source/Core/Core/MemoryWatcher.h
index 3887d68..ed721d1 100644
--- a/Source/Core/Core/MemoryWatcher.h
+++ b/Source/Core/Core/MemoryWatcher.h
@@ -3,10 +3,7 @@
 
 #pragma once
 
-#include "Common/CommonTypes.h"
-
 #include <map>
-#include <string>
 #include <sys/socket.h>
 #include <sys/un.h>
 #include <vector>
diff --git a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Branch.cpp b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Branch.cpp
index 6f51ca9..54fe1ae 100644
--- a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Branch.cpp
+++ b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Branch.cpp
@@ -1,13 +1,12 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Interpreter/Interpreter.h"
-
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
 #include "Core/ConfigManager.h"
 #include "Core/HLE/HLE.h"
 #include "Core/PowerPC/Interpreter/ExceptionUtils.h"
+#include "Core/PowerPC/Interpreter/Interpreter.h"
 #include "Core/PowerPC/PowerPC.h"
 
 void Interpreter::bx(UGeckoInstruction inst)
diff --git a/Source/Core/Core/PowerPC/Interpreter/Interpreter_FloatingPoint.cpp b/Source/Core/Core/PowerPC/Interpreter/Interpreter_FloatingPoint.cpp
index 16e86de..244e4d8 100644
--- a/Source/Core/Core/PowerPC/Interpreter/Interpreter_FloatingPoint.cpp
+++ b/Source/Core/Core/PowerPC/Interpreter/Interpreter_FloatingPoint.cpp
@@ -1,14 +1,13 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Interpreter/Interpreter.h"
-
 #include <cmath>
 #include <limits>
 
 #include "Common/CommonTypes.h"
 #include "Common/FloatUtils.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/Interpreter/Interpreter.h"
 #include "Core/PowerPC/Interpreter/Interpreter_FPUtils.h"
 #include "Core/PowerPC/PowerPC.h"
 
diff --git a/Source/Core/Core/PowerPC/Interpreter/Interpreter_LoadStorePaired.cpp b/Source/Core/Core/PowerPC/Interpreter/Interpreter_LoadStorePaired.cpp
index 6905c7a..a09bbc7 100644
--- a/Source/Core/Core/PowerPC/Interpreter/Interpreter_LoadStorePaired.cpp
+++ b/Source/Core/Core/PowerPC/Interpreter/Interpreter_LoadStorePaired.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Interpreter/Interpreter.h"
-
 #include <algorithm>
 #include <tuple>
 #include <type_traits>
@@ -13,6 +11,7 @@
 #include "Common/CommonTypes.h"
 #include "Common/MathUtil.h"
 #include "Core/PowerPC/Interpreter/ExceptionUtils.h"
+#include "Core/PowerPC/Interpreter/Interpreter.h"
 #include "Core/PowerPC/Interpreter/Interpreter_FPUtils.h"
 #include "Core/PowerPC/MMU.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Paired.cpp b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Paired.cpp
index ef4603d..964d17c 100644
--- a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Paired.cpp
+++ b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Paired.cpp
@@ -1,12 +1,11 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Interpreter/Interpreter.h"
-
 #include <cmath>
 
 #include "Common/CommonTypes.h"
 #include "Common/FloatUtils.h"
+#include "Core/PowerPC/Interpreter/Interpreter.h"
 #include "Core/PowerPC/Interpreter/Interpreter_FPUtils.h"
 #include "Core/PowerPC/PowerPC.h"
 
diff --git a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Tables.cpp b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Tables.cpp
index caecbd3..f7eefbd 100644
--- a/Source/Core/Core/PowerPC/Interpreter/Interpreter_Tables.cpp
+++ b/Source/Core/Core/PowerPC/Interpreter/Interpreter_Tables.cpp
@@ -1,11 +1,10 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Interpreter/Interpreter.h"
-
 #include <array>
 
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/Interpreter/Interpreter.h"
 #include "Core/PowerPC/PPCTables.h"
 
 namespace
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit64_Tables.cpp b/Source/Core/Core/PowerPC/Jit64/Jit64_Tables.cpp
index 482303f..2a5b77b 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit64_Tables.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit64_Tables.cpp
@@ -1,11 +1,10 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include <array>
 
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 
 namespace
 {
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_Branch.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_Branch.cpp
index ad78a06..e2e6bfd 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_Branch.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_Branch.cpp
@@ -1,13 +1,12 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
 #include "Common/x64Emitter.h"
 #include "Core/CoreTiming.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64PowerPCState.h"
 #include "Core/PowerPC/PPCAnalyst.h"
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_FloatingPoint.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_FloatingPoint.cpp
index 40999ca..463cfc1 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_FloatingPoint.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_FloatingPoint.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include <algorithm>
 #include <cmath>
 #include <limits>
@@ -16,6 +14,7 @@
 #include "Core/Config/SessionSettings.h"
 #include "Core/ConfigManager.h"
 #include "Core/Core.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64PowerPCState.h"
 #include "Core/PowerPC/PPCAnalyst.h"
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_Integer.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_Integer.cpp
index c870682..12a5938 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_Integer.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_Integer.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include <array>
 #include <limits>
 #include <vector>
@@ -16,6 +14,7 @@
 
 #include "Core/CoreTiming.h"
 #include "Core/PowerPC/Interpreter/ExceptionUtils.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64PowerPCState.h"
 #include "Core/PowerPC/JitCommon/DivUtils.h"
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_LoadStoreFloating.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_LoadStoreFloating.cpp
index 44cdd3c..c90bd56 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_LoadStoreFloating.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_LoadStoreFloating.cpp
@@ -1,11 +1,10 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include "Common/BitSet.h"
 #include "Common/CommonTypes.h"
 #include "Common/x64Emitter.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64PowerPCState.h"
 
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_Paired.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_Paired.cpp
index f0b525d..023d0d8 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_Paired.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_Paired.cpp
@@ -1,12 +1,11 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
 #include "Common/MsgHandler.h"
 #include "Common/x64Emitter.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64Constants.h"
 
diff --git a/Source/Core/Core/PowerPC/Jit64/Jit_SystemRegisters.cpp b/Source/Core/Core/PowerPC/Jit64/Jit_SystemRegisters.cpp
index f611fd7..2806879 100644
--- a/Source/Core/Core/PowerPC/Jit64/Jit_SystemRegisters.cpp
+++ b/Source/Core/Core/PowerPC/Jit64/Jit_SystemRegisters.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/Jit64/Jit.h"
-
 #include "Common/BitSet.h"
 #include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
@@ -11,6 +9,7 @@
 
 #include "Core/CoreTiming.h"
 #include "Core/HW/ProcessorInterface.h"
+#include "Core/PowerPC/Jit64/Jit.h"
 #include "Core/PowerPC/Jit64/RegCache/JitRegCache.h"
 #include "Core/PowerPC/Jit64Common/Jit64PowerPCState.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_BackPatch.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_BackPatch.cpp
index 5c68e12..12c6b9f 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_BackPatch.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_BackPatch.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include <cstddef>
 #include <optional>
 #include <string>
@@ -18,6 +16,7 @@
 
 #include "Core/HW/Memmap.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/Jit_Util.h"
 #include "Core/PowerPC/JitArmCommon/BackPatch.h"
 #include "Core/PowerPC/MMU.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Branch.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Branch.cpp
index a92bc95..c0682b6 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Branch.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Branch.cpp
@@ -1,13 +1,12 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/CommonTypes.h"
 
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/PPCTables.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_FloatingPoint.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_FloatingPoint.cpp
index de3a164..ff37923 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_FloatingPoint.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_FloatingPoint.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/CPUDetect.h"
 #include "Common/CommonTypes.h"
@@ -14,6 +12,7 @@
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/PPCTables.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Integer.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Integer.cpp
index cb73416..989a732 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Integer.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Integer.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/Assert.h"
 #include "Common/BitUtils.h"
@@ -10,6 +8,7 @@
 
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/JitCommon/DivUtils.h"
 #include "Core/PowerPC/PPCTables.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStore.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStore.cpp
index 99253b1..64866e7 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStore.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStore.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/BitSet.h"
 #include "Common/CommonTypes.h"
@@ -13,6 +11,7 @@
 #include "Core/HW/DSP.h"
 #include "Core/HW/MMIO.h"
 #include "Core/HW/Memmap.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/JitArm64/Jit_Util.h"
 #include "Core/PowerPC/JitInterface.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStoreFloating.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStoreFloating.cpp
index 9a0326e..3e03ef3 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStoreFloating.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStoreFloating.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include <algorithm>
 
 #include "Common/Arm64Emitter.h"
@@ -11,6 +9,7 @@
 
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/MMU.h"
 #include "Core/PowerPC/PPCTables.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStorePaired.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStorePaired.cpp
index 1319730..5a4daa5 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStorePaired.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_LoadStorePaired.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/BitSet.h"
 #include "Common/CommonTypes.h"
@@ -11,6 +9,7 @@
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/PPCTables.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Paired.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Paired.cpp
index 7682679..f2d35cb 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_Paired.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_Paired.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/CommonTypes.h"
 #include "Common/Config/Config.h"
@@ -12,6 +10,7 @@
 #include "Core/ConfigManager.h"
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitArm64/JitArm64_RegCache.h"
 #include "Core/PowerPC/PPCTables.h"
 #include "Core/PowerPC/PowerPC.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitArm64_SystemRegisters.cpp b/Source/Core/Core/PowerPC/JitArm64/JitArm64_SystemRegisters.cpp
index 3d48711..b311261 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitArm64_SystemRegisters.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitArm64_SystemRegisters.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
@@ -11,6 +9,7 @@
 #include "Core/Core.h"
 #include "Core/CoreTiming.h"
 #include "Core/PowerPC/Interpreter/ExceptionUtils.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/PPCTables.h"
 #include "Core/PowerPC/PowerPC.h"
 
diff --git a/Source/Core/Core/PowerPC/JitArm64/JitAsm.cpp b/Source/Core/Core/PowerPC/JitArm64/JitAsm.cpp
index 1b93a27..bf650ba 100644
--- a/Source/Core/Core/PowerPC/JitArm64/JitAsm.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/JitAsm.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit.h"
-
 #include <limits>
 
 #include "Common/Arm64Emitter.h"
@@ -16,6 +14,7 @@
 #include "Core/HW/CPU.h"
 #include "Core/HW/Memmap.h"
 #include "Core/PowerPC/Gekko.h"
+#include "Core/PowerPC/JitArm64/Jit.h"
 #include "Core/PowerPC/JitCommon/JitAsmCommon.h"
 #include "Core/PowerPC/JitCommon/JitCache.h"
 #include "Core/PowerPC/MMU.h"
diff --git a/Source/Core/Core/PowerPC/JitArm64/Jit_Util.cpp b/Source/Core/Core/PowerPC/JitArm64/Jit_Util.cpp
index 4799e35..7a1ecea 100644
--- a/Source/Core/Core/PowerPC/JitArm64/Jit_Util.cpp
+++ b/Source/Core/Core/PowerPC/JitArm64/Jit_Util.cpp
@@ -1,14 +1,13 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitArm64/Jit_Util.h"
-
 #include "Common/Arm64Emitter.h"
 #include "Common/Common.h"
 
 #include "Core/HW/MMIO.h"
 
 #include "Core/PowerPC/JitArm64/Jit.h"
+#include "Core/PowerPC/JitArm64/Jit_Util.h"
 
 using namespace Arm64Gen;
 
diff --git a/Source/Core/Core/PowerPC/JitCommon/DivUtils.cpp b/Source/Core/Core/PowerPC/JitCommon/DivUtils.cpp
index f1b6a1b..0c8f557 100644
--- a/Source/Core/Core/PowerPC/JitCommon/DivUtils.cpp
+++ b/Source/Core/Core/PowerPC/JitCommon/DivUtils.cpp
@@ -1,10 +1,10 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitCommon/DivUtils.h"
-
 #include <cstdlib>
 
+#include "Core/PowerPC/JitCommon/DivUtils.h"
+
 namespace JitCommon
 {
 Magic SignedDivisionConstants(s32 d)
diff --git a/Source/Core/Core/PowerPC/JitCommon/JitCache.cpp b/Source/Core/Core/PowerPC/JitCommon/JitCache.cpp
index de55900..06d82e9 100644
--- a/Source/Core/Core/PowerPC/JitCommon/JitCache.cpp
+++ b/Source/Core/Core/PowerPC/JitCommon/JitCache.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "Core/PowerPC/JitCommon/JitCache.h"
-
 #include <algorithm>
 #include <array>
 #include <cstring>
diff --git a/Source/Core/Core/State.cpp b/Source/Core/Core/State.cpp
index f89c1fc..18d6876 100644
--- a/Source/Core/Core/State.cpp
+++ b/Source/Core/Core/State.cpp
@@ -73,7 +73,7 @@ static Common::Event g_compressAndDumpStateSyncEvent;
 static std::thread g_save_thread;
 
 // Don't forget to increase this after doing changes on the savestate system
-constexpr u32 STATE_VERSION = 139;  // Last changed in PR 8350
+constexpr u32 STATE_VERSION = 138;  // Last changed in PR 9670
 
 // Maps savestate versions to Dolphin versions.
 // Versions after 42 don't need to be added to this list,
diff --git a/Source/Core/DiscIO/Blob.cpp b/Source/Core/DiscIO/Blob.cpp
index 7062c36..38416ad 100644
--- a/Source/Core/DiscIO/Blob.cpp
+++ b/Source/Core/DiscIO/Blob.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/Blob.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <limits>
@@ -15,6 +13,7 @@
 #include "Common/IOFile.h"
 #include "Common/MsgHandler.h"
 
+#include "DiscIO/Blob.h"
 #include "DiscIO/CISOBlob.h"
 #include "DiscIO/CompressedBlob.h"
 #include "DiscIO/DirectoryBlob.h"
diff --git a/Source/Core/DiscIO/CISOBlob.cpp b/Source/Core/DiscIO/CISOBlob.cpp
index 36c6850..ff0687d 100644
--- a/Source/Core/DiscIO/CISOBlob.cpp
+++ b/Source/Core/DiscIO/CISOBlob.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/CISOBlob.h"
-
 #include <algorithm>
 #include <cstdio>
 #include <memory>
@@ -10,6 +8,7 @@
 
 #include "Common/CommonTypes.h"
 #include "Common/IOFile.h"
+#include "DiscIO/CISOBlob.h"
 
 namespace DiscIO
 {
diff --git a/Source/Core/DiscIO/CompressedBlob.cpp b/Source/Core/DiscIO/CompressedBlob.cpp
index 8f491a4..70d123c 100644
--- a/Source/Core/DiscIO/CompressedBlob.cpp
+++ b/Source/Core/DiscIO/CompressedBlob.cpp
@@ -1,7 +1,10 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/CompressedBlob.h"
+#ifdef _WIN32
+#include <windows.h>
+#include <io.h>
+#endif
 
 #include <algorithm>
 #include <cstdio>
@@ -13,11 +16,6 @@
 
 #include <zlib.h>
 
-#ifdef _WIN32
-#include <windows.h>
-#include <io.h>
-#endif
-
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
 #include "Common/FileUtil.h"
@@ -26,6 +24,7 @@
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 #include "DiscIO/Blob.h"
+#include "DiscIO/CompressedBlob.h"
 #include "DiscIO/DiscScrubber.h"
 #include "DiscIO/MultithreadedCompressor.h"
 #include "DiscIO/Volume.h"
diff --git a/Source/Core/DiscIO/DriveBlob.cpp b/Source/Core/DiscIO/DriveBlob.cpp
index 3755317..643dad5 100644
--- a/Source/Core/DiscIO/DriveBlob.cpp
+++ b/Source/Core/DiscIO/DriveBlob.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/DriveBlob.h"
-
 #include <algorithm>
 #include <cstdio>
 #include <cstring>
@@ -14,6 +12,7 @@
 #include "Common/IOFile.h"
 #include "Common/Logging/Log.h"
 #include "DiscIO/Blob.h"
+#include "DiscIO/DriveBlob.h"
 
 #ifdef _WIN32
 #include "Common/StringUtil.h"
diff --git a/Source/Core/DiscIO/Enums.cpp b/Source/Core/DiscIO/Enums.cpp
index 0594e31..35ab81d 100644
--- a/Source/Core/DiscIO/Enums.cpp
+++ b/Source/Core/DiscIO/Enums.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/Enums.h"
-
 #include <map>
 #include <string>
 
@@ -11,6 +9,7 @@
 #include "Common/CommonTypes.h"
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
+#include "DiscIO/Enums.h"
 
 namespace DiscIO
 {
diff --git a/Source/Core/DiscIO/FileBlob.cpp b/Source/Core/DiscIO/FileBlob.cpp
index 17c855f..5392ed3 100644
--- a/Source/Core/DiscIO/FileBlob.cpp
+++ b/Source/Core/DiscIO/FileBlob.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/FileBlob.h"
-
 #include <algorithm>
 #include <memory>
 #include <string>
@@ -12,6 +10,7 @@
 #include "Common/Assert.h"
 #include "Common/FileUtil.h"
 #include "Common/MsgHandler.h"
+#include "DiscIO/FileBlob.h"
 
 namespace DiscIO
 {
diff --git a/Source/Core/DiscIO/FileSystemGCWii.cpp b/Source/Core/DiscIO/FileSystemGCWii.cpp
index 4090a98..36fe89c 100644
--- a/Source/Core/DiscIO/FileSystemGCWii.cpp
+++ b/Source/Core/DiscIO/FileSystemGCWii.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/FileSystemGCWii.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <cstring>
@@ -21,6 +19,7 @@
 #include "Common/MsgHandler.h"
 #include "Common/StringUtil.h"
 #include "DiscIO/DiscUtils.h"
+#include "DiscIO/FileSystemGCWii.h"
 #include "DiscIO/Filesystem.h"
 #include "DiscIO/VolumeDisc.h"
 
diff --git a/Source/Core/DiscIO/GameModDescriptor.cpp b/Source/Core/DiscIO/GameModDescriptor.cpp
index 5ed11de..eddf5e1 100644
--- a/Source/Core/DiscIO/GameModDescriptor.cpp
+++ b/Source/Core/DiscIO/GameModDescriptor.cpp
@@ -1,13 +1,13 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/GameModDescriptor.h"
-
 #include <optional>
 #include <string>
 #include <string_view>
 #include <vector>
 
+#include "DiscIO/GameModDescriptor.h"
+
 #include <picojson.h>
 
 #include "Common/IOFile.h"
diff --git a/Source/Core/DiscIO/VolumeWad.cpp b/Source/Core/DiscIO/VolumeWad.cpp
index df12eab..1d8e370 100644
--- a/Source/Core/DiscIO/VolumeWad.cpp
+++ b/Source/Core/DiscIO/VolumeWad.cpp
@@ -1,8 +1,6 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DiscIO/VolumeWad.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <cstring>
@@ -26,6 +24,7 @@
 #include "DiscIO/Blob.h"
 #include "DiscIO/Enums.h"
 #include "DiscIO/Volume.h"
+#include "DiscIO/VolumeWad.h"
 #include "DiscIO/WiiSaveBanner.h"
 
 namespace DiscIO
diff --git a/Source/Core/DolphinLib.props b/Source/Core/DolphinLib.props
index c0d465a..a8ca800 100644
--- a/Source/Core/DolphinLib.props
+++ b/Source/Core/DolphinLib.props
@@ -641,6 +641,7 @@
     <ClInclude Include="VideoCommon\PostProcessing.h" />
     <ClInclude Include="VideoCommon\RenderBase.h" />
     <ClInclude Include="VideoCommon\RenderState.h" />
+    <ClInclude Include="VideoCommon\SamplerCommon.h" />
     <ClInclude Include="VideoCommon\ShaderCache.h" />
     <ClInclude Include="VideoCommon\ShaderGenCommon.h" />
     <ClInclude Include="VideoCommon\Statistics.h" />
@@ -650,8 +651,6 @@
     <ClInclude Include="VideoCommon\TextureConverterShaderGen.h" />
     <ClInclude Include="VideoCommon\TextureDecoder_Util.h" />
     <ClInclude Include="VideoCommon\TextureDecoder.h" />
-    <ClInclude Include="VideoCommon\TextureInfo.h" />
-    <ClInclude Include="VideoCommon\TMEM.h" />
     <ClInclude Include="VideoCommon\UberShaderCommon.h" />
     <ClInclude Include="VideoCommon\UberShaderPixel.h" />
     <ClInclude Include="VideoCommon\UberShaderVertex.h" />
@@ -1215,8 +1214,6 @@
     <ClCompile Include="VideoCommon\TextureConversionShader.cpp" />
     <ClCompile Include="VideoCommon\TextureConverterShaderGen.cpp" />
     <ClCompile Include="VideoCommon\TextureDecoder_Common.cpp" />
-    <ClCompile Include="VideoCommon\TextureInfo.cpp" />
-    <ClCompile Include="VideoCommon\TMEM.cpp" />
     <ClCompile Include="VideoCommon\UberShaderCommon.cpp" />
     <ClCompile Include="VideoCommon\UberShaderPixel.cpp" />
     <ClCompile Include="VideoCommon\UberShaderVertex.cpp" />
diff --git a/Source/Core/DolphinQt/AboutDialog.cpp b/Source/Core/DolphinQt/AboutDialog.cpp
index e1dce12..f11461f 100644
--- a/Source/Core/DolphinQt/AboutDialog.cpp
+++ b/Source/Core/DolphinQt/AboutDialog.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/AboutDialog.h"
-
 #include <QLabel>
 #include <QTextEdit>
 #include <QVBoxLayout>
@@ -10,6 +8,7 @@
 
 #include "Common/Version.h"
 
+#include "DolphinQt/AboutDialog.h"
 #include "DolphinQt/Resources.h"
 
 AboutDialog::AboutDialog(QWidget* parent) : QDialog(parent)
diff --git a/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.cpp b/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.cpp
index e604f72..4b018d9 100644
--- a/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.cpp
+++ b/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.cpp
@@ -142,11 +142,8 @@ void AdvancedWidget::CreateWidgets()
 
   m_defer_efb_access_invalidation =
       new GraphicsBool(tr("Defer EFB Cache Invalidation"), Config::GFX_HACK_EFB_DEFER_INVALIDATION);
-  m_manual_texture_sampling =
-      new GraphicsBool(tr("Manual Texture Sampling"), Config::GFX_HACK_FAST_TEXTURE_SAMPLING, true);
 
   experimental_layout->addWidget(m_defer_efb_access_invalidation, 0, 0);
-  experimental_layout->addWidget(m_manual_texture_sampling, 0, 1);
 
   main_layout->addWidget(debugging_box);
   main_layout->addWidget(utility_box);
@@ -283,17 +280,6 @@ void AdvancedWidget::AddDescriptions()
       "<br><br>May improve performance in some games which rely on CPU EFB Access at the cost "
       "of stability.<br><br><dolphin_emphasis>If unsure, leave this "
       "unchecked.</dolphin_emphasis>");
-  static const char TR_MANUAL_TEXTURE_SAMPLING_DESCRIPTION[] = QT_TR_NOOP(
-      "Use a manual implementation of texture sampling instead of the graphics backend's built-in "
-      "functionality.<br><br>"
-      "This setting can fix graphical issues in some games on certain GPUs, most commonly vertical "
-      "lines on FMVs. In addition to this, enabling Manual Texture Sampling will allow for correct "
-      "emulation of texture wrapping special cases (at 1x IR or when scaled EFB is disabled, and "
-      "with custom textures disabled) and better emulates Level of Detail calculation.<br><br>"
-      "This comes at the cost of potentially worse performance, especially at higher internal "
-      "resolutions; additionally, Anisotropic Filtering is currently incompatible with Manual "
-      "Texture Sampling.<br><br>"
-      "<dolphin_emphasis>If unsure, leave this unchecked.</dolphin_emphasis>");
 
 #ifdef _WIN32
   static const char TR_BORDERLESS_FULLSCREEN_DESCRIPTION[] = QT_TR_NOOP(
@@ -328,5 +314,4 @@ void AdvancedWidget::AddDescriptions()
   m_borderless_fullscreen->SetDescription(tr(TR_BORDERLESS_FULLSCREEN_DESCRIPTION));
 #endif
   m_defer_efb_access_invalidation->SetDescription(tr(TR_DEFER_EFB_ACCESS_INVALIDATION_DESCRIPTION));
-  m_manual_texture_sampling->SetDescription(tr(TR_MANUAL_TEXTURE_SAMPLING_DESCRIPTION));
 }
diff --git a/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.h b/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.h
index 1148a2d..58bc9fb 100644
--- a/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.h
+++ b/Source/Core/DolphinQt/Config/Graphics/AdvancedWidget.h
@@ -62,5 +62,4 @@ private:
 
   // Experimental
   GraphicsBool* m_defer_efb_access_invalidation;
-  GraphicsBool* m_manual_texture_sampling;
 };
diff --git a/Source/Core/DolphinQt/Config/Graphics/GraphicsBool.cpp b/Source/Core/DolphinQt/Config/Graphics/GraphicsBool.cpp
index ceb459c..1584f1a 100644
--- a/Source/Core/DolphinQt/Config/Graphics/GraphicsBool.cpp
+++ b/Source/Core/DolphinQt/Config/Graphics/GraphicsBool.cpp
@@ -2,16 +2,17 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "DolphinQt/Config/Graphics/GraphicsBool.h"
+#include "DolphinQt/Config/Graphics/BalloonTip.h"
 
-#include <QEvent>
-#include <QFont>
 #include <QSignalBlocker>
 
 #include "Common/Config/Config.h"
 
-#include "DolphinQt/Config/Graphics/BalloonTip.h"
 #include "DolphinQt/Settings.h"
 
+#include <QEvent>
+#include <QFont>
+
 GraphicsBool::GraphicsBool(const QString& label, const Config::Info<bool>& setting, bool reverse)
     : ToolTipCheckBox(label), m_setting(setting), m_reverse(reverse)
 {
diff --git a/Source/Core/DolphinQt/Config/Graphics/HacksWidget.h b/Source/Core/DolphinQt/Config/Graphics/HacksWidget.h
index 490a5b4..2af4a12 100644
--- a/Source/Core/DolphinQt/Config/Graphics/HacksWidget.h
+++ b/Source/Core/DolphinQt/Config/Graphics/HacksWidget.h
@@ -26,7 +26,6 @@ private:
   GraphicsBool* m_skip_efb_cpu;
   GraphicsBool* m_ignore_format_changes;
   GraphicsBool* m_store_efb_copies;
-  GraphicsBool* m_defer_efb_copies;
 
   // Texture Cache
   QLabel* m_accuracy_label;
@@ -43,6 +42,7 @@ private:
   GraphicsBool* m_disable_bounding_box;
   GraphicsBool* m_vertex_rounding;
   GraphicsBool* m_save_texture_cache_state;
+  GraphicsBool* m_defer_efb_copies;
 
   void CreateWidgets();
   void ConnectWidgets();
diff --git a/Source/Core/DolphinQt/Config/InfoWidget.cpp b/Source/Core/DolphinQt/Config/InfoWidget.cpp
index 31c7da0..b7574dd 100644
--- a/Source/Core/DolphinQt/Config/InfoWidget.cpp
+++ b/Source/Core/DolphinQt/Config/InfoWidget.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Config/InfoWidget.h"
-
 #include <QComboBox>
 #include <QCryptographicHash>
 #include <QDir>
@@ -19,6 +17,7 @@
 #include "DiscIO/Enums.h"
 #include "DiscIO/Volume.h"
 
+#include "DolphinQt/Config/InfoWidget.h"
 #include "DolphinQt/QtUtils/DolphinFileDialog.h"
 #include "DolphinQt/QtUtils/ImageConverter.h"
 
diff --git a/Source/Core/DolphinQt/Config/Mapping/GCKeyboardEmu.cpp b/Source/Core/DolphinQt/Config/Mapping/GCKeyboardEmu.cpp
index 583025b..8f6d922 100644
--- a/Source/Core/DolphinQt/Config/Mapping/GCKeyboardEmu.cpp
+++ b/Source/Core/DolphinQt/Config/Mapping/GCKeyboardEmu.cpp
@@ -1,13 +1,13 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Config/Mapping/GCKeyboardEmu.h"
-
 #include <QFormLayout>
 #include <QGroupBox>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 
+#include "DolphinQt/Config/Mapping/GCKeyboardEmu.h"
+
 #include "InputCommon/InputConfig.h"
 
 #include "Core/HW/GCKeyboard.h"
diff --git a/Source/Core/DolphinQt/Config/Mapping/GCMicrophone.cpp b/Source/Core/DolphinQt/Config/Mapping/GCMicrophone.cpp
index de2af7f..ca07ba8 100644
--- a/Source/Core/DolphinQt/Config/Mapping/GCMicrophone.cpp
+++ b/Source/Core/DolphinQt/Config/Mapping/GCMicrophone.cpp
@@ -1,13 +1,13 @@
 // Copyright 2018 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Config/Mapping/GCMicrophone.h"
-
 #include <QFormLayout>
 #include <QGroupBox>
 #include <QHBoxLayout>
 #include <QVBoxLayout>
 
+#include "DolphinQt/Config/Mapping/GCMicrophone.h"
+
 #include "InputCommon/InputConfig.h"
 
 #include "Core/HW/GCPad.h"
diff --git a/Source/Core/DolphinQt/Config/PropertiesDialog.cpp b/Source/Core/DolphinQt/Config/PropertiesDialog.cpp
index a7589a4..47728d0 100644
--- a/Source/Core/DolphinQt/Config/PropertiesDialog.cpp
+++ b/Source/Core/DolphinQt/Config/PropertiesDialog.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Config/PropertiesDialog.h"
-
 #include <memory>
 
 #include <QDialogButtonBox>
@@ -19,6 +17,7 @@
 #include "DolphinQt/Config/GeckoCodeWidget.h"
 #include "DolphinQt/Config/InfoWidget.h"
 #include "DolphinQt/Config/PatchesWidget.h"
+#include "DolphinQt/Config/PropertiesDialog.h"
 #include "DolphinQt/Config/VerifyWidget.h"
 #include "DolphinQt/QtUtils/WrapInScrollArea.h"
 
diff --git a/Source/Core/DolphinQt/Config/SettingsWindow.cpp b/Source/Core/DolphinQt/Config/SettingsWindow.cpp
index 1883e85..7faf712 100644
--- a/Source/Core/DolphinQt/Config/SettingsWindow.cpp
+++ b/Source/Core/DolphinQt/Config/SettingsWindow.cpp
@@ -1,13 +1,12 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Config/SettingsWindow.h"
-
 #include <QDialogButtonBox>
 #include <QPushButton>
 #include <QTabWidget>
 #include <QVBoxLayout>
 
+#include "DolphinQt/Config/SettingsWindow.h"
 #include "DolphinQt/QtUtils/WrapInScrollArea.h"
 #include "DolphinQt/Resources.h"
 #include "DolphinQt/Settings.h"
diff --git a/Source/Core/DolphinQt/GameList/ListProxyModel.cpp b/Source/Core/DolphinQt/GameList/ListProxyModel.cpp
index 9681522..e01caa4 100644
--- a/Source/Core/DolphinQt/GameList/ListProxyModel.cpp
+++ b/Source/Core/DolphinQt/GameList/ListProxyModel.cpp
@@ -2,7 +2,6 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "DolphinQt/GameList/ListProxyModel.h"
-
 #include "DolphinQt/GameList/GameListModel.h"
 
 ListProxyModel::ListProxyModel(QObject* parent) : QSortFilterProxyModel(parent)
diff --git a/Source/Core/DolphinQt/MainWindow.cpp b/Source/Core/DolphinQt/MainWindow.cpp
index 7fc42cc..fed2c1f 100644
--- a/Source/Core/DolphinQt/MainWindow.cpp
+++ b/Source/Core/DolphinQt/MainWindow.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/MainWindow.h"
-
 #include <QApplication>
 #include <QCloseEvent>
 #include <QDateTime>
@@ -88,6 +86,7 @@
 #include "DolphinQt/GameList/GameList.h"
 #include "DolphinQt/Host.h"
 #include "DolphinQt/HotkeyScheduler.h"
+#include "DolphinQt/MainWindow.h"
 #include "DolphinQt/MenuBar.h"
 #include "DolphinQt/NKitWarningDialog.h"
 #include "DolphinQt/NetPlay/NetPlayBrowser.h"
diff --git a/Source/Core/DolphinQt/QtUtils/DolphinFileDialog.cpp b/Source/Core/DolphinQt/QtUtils/DolphinFileDialog.cpp
index b2d8ca2..2c2976b 100644
--- a/Source/Core/DolphinQt/QtUtils/DolphinFileDialog.cpp
+++ b/Source/Core/DolphinQt/QtUtils/DolphinFileDialog.cpp
@@ -1,7 +1,7 @@
 // Copyright 2021 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/QtUtils/DolphinFileDialog.h"
+#include "DolphinFileDialog.h"
 
 #include <QFileDialog>
 #include <QObject>
diff --git a/Source/Core/DolphinQt/QtUtils/DoubleClickEventFilter.cpp b/Source/Core/DolphinQt/QtUtils/DoubleClickEventFilter.cpp
index 1f2ac9a..1cf540f 100644
--- a/Source/Core/DolphinQt/QtUtils/DoubleClickEventFilter.cpp
+++ b/Source/Core/DolphinQt/QtUtils/DoubleClickEventFilter.cpp
@@ -1,10 +1,10 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/QtUtils/DoubleClickEventFilter.h"
-
 #include <QEvent>
 
+#include "DolphinQt/QtUtils/DoubleClickEventFilter.h"
+
 bool DoubleClickEventFilter::eventFilter(QObject* object, QEvent* event)
 {
   if (event->type() == QEvent::MouseButtonDblClick)
diff --git a/Source/Core/DolphinQt/QtUtils/FileOpenEventFilter.cpp b/Source/Core/DolphinQt/QtUtils/FileOpenEventFilter.cpp
index a0aaacd..00e9e88 100644
--- a/Source/Core/DolphinQt/QtUtils/FileOpenEventFilter.cpp
+++ b/Source/Core/DolphinQt/QtUtils/FileOpenEventFilter.cpp
@@ -1,10 +1,10 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/QtUtils/FileOpenEventFilter.h"
-
 #include <QFileOpenEvent>
 
+#include "DolphinQt/QtUtils/FileOpenEventFilter.h"
+
 FileOpenEventFilter::FileOpenEventFilter(QObject* event_source) : QObject(event_source)
 {
   event_source->installEventFilter(this);
diff --git a/Source/Core/DolphinQt/QtUtils/WindowActivationEventFilter.cpp b/Source/Core/DolphinQt/QtUtils/WindowActivationEventFilter.cpp
index 52a8a54..7d89d8a 100644
--- a/Source/Core/DolphinQt/QtUtils/WindowActivationEventFilter.cpp
+++ b/Source/Core/DolphinQt/QtUtils/WindowActivationEventFilter.cpp
@@ -1,11 +1,11 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/QtUtils/WindowActivationEventFilter.h"
-
 #include <QEvent>
 #include <QObject>
 
+#include "DolphinQt/QtUtils/WindowActivationEventFilter.h"
+
 bool WindowActivationEventFilter::eventFilter(QObject* object, QEvent* event)
 {
   if (event->type() == QEvent::WindowDeactivate)
diff --git a/Source/Core/DolphinQt/Settings/PathPane.cpp b/Source/Core/DolphinQt/Settings/PathPane.cpp
index d793fa9..2c212ad 100644
--- a/Source/Core/DolphinQt/Settings/PathPane.cpp
+++ b/Source/Core/DolphinQt/Settings/PathPane.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/Settings/PathPane.h"
-
 #include <QCheckBox>
 #include <QDir>
 #include <QGroupBox>
@@ -20,6 +18,7 @@
 
 #include "DolphinQt/QtUtils/DolphinFileDialog.h"
 #include "DolphinQt/Settings.h"
+#include "DolphinQt/Settings/PathPane.h"
 
 PathPane::PathPane(QWidget* parent) : QWidget(parent)
 {
diff --git a/Source/Core/DolphinQt/TAS/WiiTASInputWindow.cpp b/Source/Core/DolphinQt/TAS/WiiTASInputWindow.cpp
index cad896b..df84495 100644
--- a/Source/Core/DolphinQt/TAS/WiiTASInputWindow.cpp
+++ b/Source/Core/DolphinQt/TAS/WiiTASInputWindow.cpp
@@ -1,8 +1,6 @@
 // Copyright 2018 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/TAS/WiiTASInputWindow.h"
-
 #include <cmath>
 
 #include <QCheckBox>
@@ -33,6 +31,7 @@
 #include "DolphinQt/QtUtils/QueueOnObject.h"
 #include "DolphinQt/TAS/IRWidget.h"
 #include "DolphinQt/TAS/TASCheckBox.h"
+#include "DolphinQt/TAS/WiiTASInputWindow.h"
 
 #include "InputCommon/InputConfig.h"
 
diff --git a/Source/Core/DolphinQt/ToolBar.cpp b/Source/Core/DolphinQt/ToolBar.cpp
index ad79c6f..f283edb 100644
--- a/Source/Core/DolphinQt/ToolBar.cpp
+++ b/Source/Core/DolphinQt/ToolBar.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "DolphinQt/ToolBar.h"
-
 #include <algorithm>
 #include <vector>
 
@@ -14,6 +12,7 @@
 #include "DolphinQt/Host.h"
 #include "DolphinQt/Resources.h"
 #include "DolphinQt/Settings.h"
+#include "DolphinQt/ToolBar.h"
 
 static QSize ICON_SIZE(32, 32);
 
diff --git a/Source/Core/InputCommon/ControllerInterface/Android/Android.cpp b/Source/Core/InputCommon/ControllerInterface/Android/Android.cpp
index 7a7c548..5937f11 100644
--- a/Source/Core/InputCommon/ControllerInterface/Android/Android.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/Android/Android.cpp
@@ -2,7 +2,6 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "InputCommon/ControllerInterface/Android/Android.h"
-
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
 #include "InputCommon/ControllerInterface/Touch/Touchscreen.h"
 
diff --git a/Source/Core/InputCommon/ControllerInterface/DInput/DInputJoystick.cpp b/Source/Core/InputCommon/ControllerInterface/DInput/DInputJoystick.cpp
index ac72d38..5c9a694 100644
--- a/Source/Core/InputCommon/ControllerInterface/DInput/DInputJoystick.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/DInput/DInputJoystick.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/DInput/DInputJoystick.h"
-
 #include <algorithm>
 #include <limits>
 #include <mutex>
@@ -14,6 +12,7 @@
 #include "Common/Logging/Log.h"
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
 #include "InputCommon/ControllerInterface/DInput/DInput.h"
+#include "InputCommon/ControllerInterface/DInput/DInputJoystick.h"
 #include "InputCommon/ControllerInterface/DInput/XInputFilter.h"
 
 namespace ciface::DInput
diff --git a/Source/Core/InputCommon/ControllerInterface/DInput/XInputFilter.cpp b/Source/Core/InputCommon/ControllerInterface/DInput/XInputFilter.cpp
index 4379749..94ae14f 100644
--- a/Source/Core/InputCommon/ControllerInterface/DInput/XInputFilter.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/DInput/XInputFilter.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/DInput/XInputFilter.h"
-
 #include <cwchar>
 #include <unordered_set>
 #include <vector>
diff --git a/Source/Core/InputCommon/ControllerInterface/OSX/OSX.mm b/Source/Core/InputCommon/ControllerInterface/OSX/OSX.mm
index 10c30ff..e846ffb 100644
--- a/Source/Core/InputCommon/ControllerInterface/OSX/OSX.mm
+++ b/Source/Core/InputCommon/ControllerInterface/OSX/OSX.mm
@@ -1,8 +1,6 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/OSX/OSX.h"
-
 #include <thread>
 
 #include <Cocoa/Cocoa.h>
@@ -14,6 +12,7 @@
 #include "Common/Thread.h"
 
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
+#include "InputCommon/ControllerInterface/OSX/OSX.h"
 #include "InputCommon/ControllerInterface/OSX/OSXJoystick.h"
 #include "InputCommon/ControllerInterface/OSX/RunLoopStopper.h"
 
diff --git a/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.cpp b/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.cpp
index 5c71ade..a273814 100644
--- a/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/Pipes/Pipes.h"
-
 #include <algorithm>
 #include <array>
 #include <cstdlib>
@@ -19,6 +17,7 @@
 #include "Common/FileUtil.h"
 #include "Common/StringUtil.h"
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
+#include "InputCommon/ControllerInterface/Pipes/Pipes.h"
 
 namespace ciface::Pipes
 {
diff --git a/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.h b/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.h
index ab9e987..3c1516c 100644
--- a/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.h
+++ b/Source/Core/InputCommon/ControllerInterface/Pipes/Pipes.h
@@ -7,8 +7,6 @@
 #include <string>
 #include <vector>
 
-#include "InputCommon/ControllerInterface/ControllerInterface.h"
-
 namespace ciface::Pipes
 {
 // To create a piped controller input, create a named pipe in the
diff --git a/Source/Core/InputCommon/ControllerInterface/Touch/ButtonManager.cpp b/Source/Core/InputCommon/ControllerInterface/Touch/ButtonManager.cpp
index 7b15f92..8b8412c 100644
--- a/Source/Core/InputCommon/ControllerInterface/Touch/ButtonManager.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/Touch/ButtonManager.cpp
@@ -1,8 +1,6 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/Touch/ButtonManager.h"
-
 #include <array>
 #include <sstream>
 #include <string>
@@ -25,6 +23,7 @@
 
 #include "InputCommon/ControllerEmu/ControlGroup/ControlGroup.h"
 #include "InputCommon/ControllerEmu/StickGate.h"
+#include "InputCommon/ControllerInterface/Touch/ButtonManager.h"
 
 namespace ButtonManager
 {
diff --git a/Source/Core/InputCommon/ControllerInterface/Touch/Touchscreen.cpp b/Source/Core/InputCommon/ControllerInterface/Touch/Touchscreen.cpp
index a4c20b0..ca98dbe 100644
--- a/Source/Core/InputCommon/ControllerInterface/Touch/Touchscreen.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/Touch/Touchscreen.cpp
@@ -1,15 +1,14 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/Touch/Touchscreen.h"
-
-#include <sstream>
-#include <thread>
 #ifdef ANDROID
 #include <jni/AndroidCommon/IDCache.h>
 #endif
 
+#include <sstream>
+#include <thread>
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
+#include "InputCommon/ControllerInterface/Touch/Touchscreen.h"
 
 namespace ciface::Touch
 {
diff --git a/Source/Core/InputCommon/ControllerInterface/Xlib/XInput2.cpp b/Source/Core/InputCommon/ControllerInterface/Xlib/XInput2.cpp
index 1f8e107..689b4fc 100644
--- a/Source/Core/InputCommon/ControllerInterface/Xlib/XInput2.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/Xlib/XInput2.cpp
@@ -1,8 +1,6 @@
 // Copyright 2013 Max Eliaser
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/Xlib/XInput2.h"
-
 #pragma GCC diagnostic push
 #pragma GCC diagnostic ignored "-Wregister"
 #include <X11/XKBlib.h>
@@ -13,6 +11,8 @@
 
 #include <fmt/format.h>
 
+#include "InputCommon/ControllerInterface/Xlib/XInput2.h"
+
 #include "Common/StringUtil.h"
 
 // This is an input plugin using the XInput 2.0 extension to the X11 protocol,
diff --git a/Source/Core/InputCommon/ControllerInterface/evdev/evdev.cpp b/Source/Core/InputCommon/ControllerInterface/evdev/evdev.cpp
index 6df37b4..752d2e7 100644
--- a/Source/Core/InputCommon/ControllerInterface/evdev/evdev.cpp
+++ b/Source/Core/InputCommon/ControllerInterface/evdev/evdev.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/ControllerInterface/evdev/evdev.h"
-
 #include <algorithm>
 #include <cstring>
 #include <map>
@@ -22,6 +20,7 @@
 #include "Common/StringUtil.h"
 #include "Common/Thread.h"
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
+#include "InputCommon/ControllerInterface/evdev/evdev.h"
 
 namespace ciface::evdev
 {
diff --git a/Source/Core/InputCommon/GCAdapter_Android.cpp b/Source/Core/InputCommon/GCAdapter_Android.cpp
index 1e58733..f429705 100644
--- a/Source/Core/InputCommon/GCAdapter_Android.cpp
+++ b/Source/Core/InputCommon/GCAdapter_Android.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/GCAdapter.h"
-
 #include <algorithm>
 #include <array>
 #include <jni.h>
@@ -19,6 +17,7 @@
 #include "Core/HW/SI/SI_Device.h"
 #include "Core/HW/SystemTimers.h"
 
+#include "InputCommon/GCAdapter.h"
 #include "InputCommon/GCPadStatus.h"
 
 #include "jni/AndroidCommon/IDCache.h"
diff --git a/Source/Core/InputCommon/InputConfig.cpp b/Source/Core/InputCommon/InputConfig.cpp
index 5e64b60..ad044ea 100644
--- a/Source/Core/InputCommon/InputConfig.cpp
+++ b/Source/Core/InputCommon/InputConfig.cpp
@@ -1,8 +1,6 @@
 // Copyright 2010 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "InputCommon/InputConfig.h"
-
 #include <vector>
 
 #include "Common/Config/Config.h"
@@ -17,6 +15,7 @@
 #include "InputCommon/ControllerEmu/ControllerEmu.h"
 #include "InputCommon/ControllerEmu/Setting/NumericSetting.h"
 #include "InputCommon/ControllerInterface/ControllerInterface.h"
+#include "InputCommon/InputConfig.h"
 #include "InputCommon/InputProfile.h"
 
 InputConfig::InputConfig(const std::string& ini_name, const std::string& gui_name,
diff --git a/Source/Core/UICommon/CommandLineParse.cpp b/Source/Core/UICommon/CommandLineParse.cpp
index 54093f2..8d0312e 100644
--- a/Source/Core/UICommon/CommandLineParse.cpp
+++ b/Source/Core/UICommon/CommandLineParse.cpp
@@ -1,8 +1,6 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "UICommon/CommandLineParse.h"
-
 #include <list>
 #include <optional>
 #include <sstream>
@@ -15,6 +13,7 @@
 #include "Common/StringUtil.h"
 #include "Common/Version.h"
 #include "Core/Config/MainSettings.h"
+#include "UICommon/CommandLineParse.h"
 
 namespace CommandLineParse
 {
diff --git a/Source/Core/UICommon/UICommon.cpp b/Source/Core/UICommon/UICommon.cpp
index a5f0721..bcd330f 100644
--- a/Source/Core/UICommon/UICommon.cpp
+++ b/Source/Core/UICommon/UICommon.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "UICommon/UICommon.h"
-
 #include <algorithm>
 #include <clocale>
 #include <cmath>
@@ -37,6 +35,7 @@
 #include "InputCommon/GCAdapter.h"
 
 #include "UICommon/DiscordPresence.h"
+#include "UICommon/UICommon.h"
 #include "UICommon/USBUtils.h"
 
 #ifdef HAVE_X11
diff --git a/Source/Core/VideoBackends/D3D/D3DBoundingBox.cpp b/Source/Core/VideoBackends/D3D/D3DBoundingBox.cpp
index 2eb6da7..6495fcf 100644
--- a/Source/Core/VideoBackends/D3D/D3DBoundingBox.cpp
+++ b/Source/Core/VideoBackends/D3D/D3DBoundingBox.cpp
@@ -1,15 +1,13 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D/D3DBoundingBox.h"
-
 #include <algorithm>
 #include <array>
 
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
 #include "Common/MsgHandler.h"
-
+#include "VideoBackends/D3D/D3DBoundingBox.h"
 #include "VideoBackends/D3D/D3DState.h"
 #include "VideoBackends/D3DCommon/D3DCommon.h"
 
diff --git a/Source/Core/VideoBackends/D3D/D3DMain.cpp b/Source/Core/VideoBackends/D3D/D3DMain.cpp
index 4d78c49..0ff911c 100644
--- a/Source/Core/VideoBackends/D3D/D3DMain.cpp
+++ b/Source/Core/VideoBackends/D3D/D3DMain.cpp
@@ -107,9 +107,6 @@ void VideoBackend::FillBackendInfo()
   g_Config.backend_info.bSupportsSSAA = true;
   g_Config.backend_info.bSupportsShaderBinaries = true;
   g_Config.backend_info.bSupportsPipelineCacheData = false;
-  g_Config.backend_info.bSupportsCoarseDerivatives = true;
-  g_Config.backend_info.bSupportsTextureQueryLevels = true;
-  g_Config.backend_info.bSupportsLodBiasInSampler = true;
   g_Config.backend_info.bSupportsLogicOp = D3D::SupportsLogicOp(g_Config.iAdapter);
 
   g_Config.backend_info.Adapters = D3DCommon::GetAdapterNames();
diff --git a/Source/Core/VideoBackends/D3D/D3DState.cpp b/Source/Core/VideoBackends/D3D/D3DState.cpp
index 9a568ae..a1de229 100644
--- a/Source/Core/VideoBackends/D3D/D3DState.cpp
+++ b/Source/Core/VideoBackends/D3D/D3DState.cpp
@@ -1,8 +1,6 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D/D3DState.h"
-
 #include <algorithm>
 #include <array>
 
@@ -13,6 +11,7 @@
 #include "Common/MsgHandler.h"
 
 #include "VideoBackends/D3D/D3DBase.h"
+#include "VideoBackends/D3D/D3DState.h"
 #include "VideoBackends/D3D/DXTexture.h"
 #include "VideoBackends/D3DCommon/D3DCommon.h"
 #include "VideoCommon/VideoConfig.h"
@@ -305,43 +304,43 @@ StateCache::~StateCache() = default;
 ID3D11SamplerState* StateCache::Get(SamplerState state)
 {
   std::lock_guard<std::mutex> guard(m_lock);
-  auto it = m_sampler.find(state);
+  auto it = m_sampler.find(state.hex);
   if (it != m_sampler.end())
     return it->second.Get();
 
   D3D11_SAMPLER_DESC sampdc = CD3D11_SAMPLER_DESC(CD3D11_DEFAULT());
-  if (state.tm0.mipmap_filter == FilterMode::Linear)
+  if (state.mipmap_filter == SamplerState::Filter::Linear)
   {
-    if (state.tm0.min_filter == FilterMode::Linear)
-      sampdc.Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+    if (state.min_filter == SamplerState::Filter::Linear)
+      sampdc.Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                           D3D11_FILTER_MIN_MAG_MIP_LINEAR :
                           D3D11_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
     else
-      sampdc.Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      sampdc.Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                           D3D11_FILTER_MIN_POINT_MAG_MIP_LINEAR :
                           D3D11_FILTER_MIN_MAG_POINT_MIP_LINEAR;
   }
   else
   {
-    if (state.tm0.min_filter == FilterMode::Linear)
-      sampdc.Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+    if (state.min_filter == SamplerState::Filter::Linear)
+      sampdc.Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                           D3D11_FILTER_MIN_MAG_LINEAR_MIP_POINT :
                           D3D11_FILTER_MIN_LINEAR_MAG_MIP_POINT;
     else
-      sampdc.Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      sampdc.Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                           D3D11_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT :
                           D3D11_FILTER_MIN_MAG_MIP_POINT;
   }
 
   static constexpr std::array<D3D11_TEXTURE_ADDRESS_MODE, 3> address_modes = {
       {D3D11_TEXTURE_ADDRESS_CLAMP, D3D11_TEXTURE_ADDRESS_WRAP, D3D11_TEXTURE_ADDRESS_MIRROR}};
-  sampdc.AddressU = address_modes[static_cast<u32>(state.tm0.wrap_u.Value())];
-  sampdc.AddressV = address_modes[static_cast<u32>(state.tm0.wrap_v.Value())];
-  sampdc.MaxLOD = state.tm1.max_lod / 16.f;
-  sampdc.MinLOD = state.tm1.min_lod / 16.f;
-  sampdc.MipLODBias = state.tm0.lod_bias / 256.f;
+  sampdc.AddressU = address_modes[static_cast<u32>(state.wrap_u.Value())];
+  sampdc.AddressV = address_modes[static_cast<u32>(state.wrap_v.Value())];
+  sampdc.MaxLOD = state.max_lod / 16.f;
+  sampdc.MinLOD = state.min_lod / 16.f;
+  sampdc.MipLODBias = (s32)state.lod_bias / 256.f;
 
-  if (state.tm0.anisotropic_filtering)
+  if (state.anisotropic_filtering)
   {
     sampdc.Filter = D3D11_FILTER_ANISOTROPIC;
     sampdc.MaxAnisotropy = 1u << g_ActiveConfig.iMaxAnisotropy;
@@ -350,7 +349,7 @@ ID3D11SamplerState* StateCache::Get(SamplerState state)
   ComPtr<ID3D11SamplerState> res;
   HRESULT hr = D3D::device->CreateSamplerState(&sampdc, res.GetAddressOf());
   ASSERT_MSG(VIDEO, SUCCEEDED(hr), "Creating D3D sampler state failed: {}", DX11HRWrap(hr));
-  return m_sampler.emplace(state, std::move(res)).first->second.Get();
+  return m_sampler.emplace(state.hex, std::move(res)).first->second.Get();
 }
 
 ID3D11BlendState* StateCache::Get(BlendingState state)
diff --git a/Source/Core/VideoBackends/D3D/D3DState.h b/Source/Core/VideoBackends/D3D/D3DState.h
index 795e7a0..b76b85f 100644
--- a/Source/Core/VideoBackends/D3D/D3DState.h
+++ b/Source/Core/VideoBackends/D3D/D3DState.h
@@ -37,7 +37,7 @@ private:
   std::unordered_map<u32, ComPtr<ID3D11DepthStencilState>> m_depth;
   std::unordered_map<u32, ComPtr<ID3D11RasterizerState>> m_raster;
   std::unordered_map<u32, ComPtr<ID3D11BlendState>> m_blend;
-  std::unordered_map<SamplerState, ComPtr<ID3D11SamplerState>> m_sampler;
+  std::unordered_map<SamplerState::StorageType, ComPtr<ID3D11SamplerState>> m_sampler;
   std::mutex m_lock;
 };
 
diff --git a/Source/Core/VideoBackends/D3D/DXPipeline.cpp b/Source/Core/VideoBackends/D3D/DXPipeline.cpp
index 0bdfeb0..0012d38 100644
--- a/Source/Core/VideoBackends/D3D/DXPipeline.cpp
+++ b/Source/Core/VideoBackends/D3D/DXPipeline.cpp
@@ -1,8 +1,6 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D/DXPipeline.h"
-
 #include "Common/Assert.h"
 #include "Common/Logging/Log.h"
 
@@ -10,6 +8,7 @@
 #include "VideoBackends/D3D/D3DRender.h"
 #include "VideoBackends/D3D/D3DState.h"
 #include "VideoBackends/D3D/D3DVertexManager.h"
+#include "VideoBackends/D3D/DXPipeline.h"
 #include "VideoBackends/D3D/DXShader.h"
 #include "VideoBackends/D3D/DXTexture.h"
 #include "VideoCommon/VideoConfig.h"
diff --git a/Source/Core/VideoBackends/D3D/DXPipeline.h b/Source/Core/VideoBackends/D3D/DXPipeline.h
index 611f709..1dc1f9b 100644
--- a/Source/Core/VideoBackends/D3D/DXPipeline.h
+++ b/Source/Core/VideoBackends/D3D/DXPipeline.h
@@ -5,8 +5,6 @@
 
 #include <d3d11.h>
 #include <memory>
-
-#include "VideoBackends/D3D/D3DBase.h"
 #include "VideoCommon/AbstractPipeline.h"
 
 namespace DX11
diff --git a/Source/Core/VideoBackends/D3D/DXTexture.cpp b/Source/Core/VideoBackends/D3D/DXTexture.cpp
index f3e6912..c8e7e30 100644
--- a/Source/Core/VideoBackends/D3D/DXTexture.cpp
+++ b/Source/Core/VideoBackends/D3D/DXTexture.cpp
@@ -1,8 +1,6 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D/DXTexture.h"
-
 #include <algorithm>
 #include <cstddef>
 
@@ -11,6 +9,7 @@
 #include "Common/Logging/Log.h"
 
 #include "VideoBackends/D3D/D3DState.h"
+#include "VideoBackends/D3D/DXTexture.h"
 #include "VideoBackends/D3DCommon/D3DCommon.h"
 #include "VideoCommon/VideoConfig.h"
 
diff --git a/Source/Core/VideoBackends/D3D/DXTexture.h b/Source/Core/VideoBackends/D3D/DXTexture.h
index 2248d45..a49b490 100644
--- a/Source/Core/VideoBackends/D3D/DXTexture.h
+++ b/Source/Core/VideoBackends/D3D/DXTexture.h
@@ -7,10 +7,8 @@
 #include <memory>
 #include <string>
 #include <string_view>
-
 #include "Common/CommonTypes.h"
 
-#include "VideoBackends/D3D/D3DBase.h"
 #include "VideoCommon/AbstractFramebuffer.h"
 #include "VideoCommon/AbstractStagingTexture.h"
 #include "VideoCommon/AbstractTexture.h"
diff --git a/Source/Core/VideoBackends/D3D12/D3D12Renderer.cpp b/Source/Core/VideoBackends/D3D12/D3D12Renderer.cpp
index ece8f14..60ba5ed 100644
--- a/Source/Core/VideoBackends/D3D12/D3D12Renderer.cpp
+++ b/Source/Core/VideoBackends/D3D12/D3D12Renderer.cpp
@@ -1,13 +1,12 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D12/D3D12Renderer.h"
-
 #include "Common/Logging/Log.h"
 
 #include "VideoBackends/D3D12/Common.h"
 #include "VideoBackends/D3D12/D3D12BoundingBox.h"
 #include "VideoBackends/D3D12/D3D12PerfQuery.h"
+#include "VideoBackends/D3D12/D3D12Renderer.h"
 #include "VideoBackends/D3D12/D3D12SwapChain.h"
 #include "VideoBackends/D3D12/DX12Context.h"
 #include "VideoBackends/D3D12/DX12Pipeline.h"
diff --git a/Source/Core/VideoBackends/D3D12/D3D12VertexManager.cpp b/Source/Core/VideoBackends/D3D12/D3D12VertexManager.cpp
index b85e4e4..057e662 100644
--- a/Source/Core/VideoBackends/D3D12/D3D12VertexManager.cpp
+++ b/Source/Core/VideoBackends/D3D12/D3D12VertexManager.cpp
@@ -1,6 +1,8 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
+#include "Common/CommonTypes.h"
+
 #include "VideoBackends/D3D12/D3D12VertexManager.h"
 
 #include "Common/Align.h"
diff --git a/Source/Core/VideoBackends/D3D12/DX12Pipeline.cpp b/Source/Core/VideoBackends/D3D12/DX12Pipeline.cpp
index 52b73e6..cc04a58 100644
--- a/Source/Core/VideoBackends/D3D12/DX12Pipeline.cpp
+++ b/Source/Core/VideoBackends/D3D12/DX12Pipeline.cpp
@@ -1,13 +1,12 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3D12/DX12Pipeline.h"
-
 #include "Common/Assert.h"
 #include "Common/MsgHandler.h"
 
 #include "VideoBackends/D3D12/Common.h"
 #include "VideoBackends/D3D12/DX12Context.h"
+#include "VideoBackends/D3D12/DX12Pipeline.h"
 #include "VideoBackends/D3D12/DX12Shader.h"
 #include "VideoBackends/D3D12/DX12Texture.h"
 #include "VideoBackends/D3D12/DX12VertexFormat.h"
diff --git a/Source/Core/VideoBackends/D3D12/DX12Texture.cpp b/Source/Core/VideoBackends/D3D12/DX12Texture.cpp
index 31951b1..c1979c1 100644
--- a/Source/Core/VideoBackends/D3D12/DX12Texture.cpp
+++ b/Source/Core/VideoBackends/D3D12/DX12Texture.cpp
@@ -2,11 +2,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoBackends/D3D12/DX12Texture.h"
-
 #include "Common/Align.h"
 #include "Common/Assert.h"
 #include "Common/StringUtil.h"
-
 #include "VideoBackends/D3D12/Common.h"
 #include "VideoBackends/D3D12/D3D12Renderer.h"
 #include "VideoBackends/D3D12/D3D12StreamBuffer.h"
diff --git a/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.cpp b/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.cpp
index 97d0c8c..7ce35ac 100644
--- a/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.cpp
+++ b/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.cpp
@@ -2,9 +2,7 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoBackends/D3D12/DescriptorHeapManager.h"
-
 #include "Common/Assert.h"
-
 #include "VideoBackends/D3D12/DX12Context.h"
 #include "VideoCommon/VideoConfig.h"
 
@@ -87,32 +85,32 @@ SamplerHeapManager::~SamplerHeapManager() = default;
 
 static void GetD3DSamplerDesc(D3D12_SAMPLER_DESC* desc, const SamplerState& state)
 {
-  if (state.tm0.mipmap_filter == FilterMode::Linear)
+  if (state.mipmap_filter == SamplerState::Filter::Linear)
   {
-    if (state.tm0.min_filter == FilterMode::Linear)
+    if (state.min_filter == SamplerState::Filter::Linear)
     {
-      desc->Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      desc->Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                          D3D12_FILTER_MIN_MAG_MIP_LINEAR :
                          D3D12_FILTER_MIN_LINEAR_MAG_POINT_MIP_LINEAR;
     }
     else
     {
-      desc->Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      desc->Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                          D3D12_FILTER_MIN_POINT_MAG_MIP_LINEAR :
                          D3D12_FILTER_MIN_MAG_POINT_MIP_LINEAR;
     }
   }
   else
   {
-    if (state.tm0.min_filter == FilterMode::Linear)
+    if (state.min_filter == SamplerState::Filter::Linear)
     {
-      desc->Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      desc->Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                          D3D12_FILTER_MIN_MAG_LINEAR_MIP_POINT :
                          D3D12_FILTER_MIN_LINEAR_MAG_MIP_POINT;
     }
     else
     {
-      desc->Filter = (state.tm0.mag_filter == FilterMode::Linear) ?
+      desc->Filter = (state.mag_filter == SamplerState::Filter::Linear) ?
                          D3D12_FILTER_MIN_POINT_MAG_LINEAR_MIP_POINT :
                          D3D12_FILTER_MIN_MAG_MIP_POINT;
     }
@@ -121,15 +119,15 @@ static void GetD3DSamplerDesc(D3D12_SAMPLER_DESC* desc, const SamplerState& stat
   static constexpr std::array<D3D12_TEXTURE_ADDRESS_MODE, 3> address_modes = {
       {D3D12_TEXTURE_ADDRESS_MODE_CLAMP, D3D12_TEXTURE_ADDRESS_MODE_WRAP,
        D3D12_TEXTURE_ADDRESS_MODE_MIRROR}};
-  desc->AddressU = address_modes[static_cast<u32>(state.tm0.wrap_u.Value())];
-  desc->AddressV = address_modes[static_cast<u32>(state.tm0.wrap_v.Value())];
+  desc->AddressU = address_modes[static_cast<u32>(state.wrap_u.Value())];
+  desc->AddressV = address_modes[static_cast<u32>(state.wrap_v.Value())];
   desc->AddressW = D3D12_TEXTURE_ADDRESS_MODE_CLAMP;
-  desc->MaxLOD = state.tm1.max_lod / 16.f;
-  desc->MinLOD = state.tm1.min_lod / 16.f;
-  desc->MipLODBias = static_cast<s32>(state.tm0.lod_bias) / 256.f;
+  desc->MaxLOD = state.max_lod / 16.f;
+  desc->MinLOD = state.min_lod / 16.f;
+  desc->MipLODBias = static_cast<s32>(state.lod_bias) / 256.f;
   desc->ComparisonFunc = D3D12_COMPARISON_FUNC_NEVER;
 
-  if (state.tm0.anisotropic_filtering)
+  if (state.anisotropic_filtering)
   {
     desc->Filter = D3D12_FILTER_ANISOTROPIC;
     desc->MaxAnisotropy = 1u << g_ActiveConfig.iMaxAnisotropy;
@@ -138,7 +136,7 @@ static void GetD3DSamplerDesc(D3D12_SAMPLER_DESC* desc, const SamplerState& stat
 
 bool SamplerHeapManager::Lookup(const SamplerState& ss, D3D12_CPU_DESCRIPTOR_HANDLE* handle)
 {
-  const auto it = m_sampler_map.find(ss);
+  const auto it = m_sampler_map.find(ss.hex);
   if (it != m_sampler_map.end())
   {
     *handle = it->second;
@@ -160,7 +158,7 @@ bool SamplerHeapManager::Lookup(const SamplerState& ss, D3D12_CPU_DESCRIPTOR_HAN
                                                   m_current_offset * m_descriptor_increment_size};
   g_dx_context->GetDevice()->CreateSampler(&desc, new_handle);
 
-  m_sampler_map.emplace(ss, new_handle);
+  m_sampler_map.emplace(ss.hex, new_handle);
   m_current_offset++;
   *handle = new_handle;
   return true;
diff --git a/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.h b/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.h
index 7ff42c8..ce4d23b 100644
--- a/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.h
+++ b/Source/Core/VideoBackends/D3D12/DescriptorHeapManager.h
@@ -68,6 +68,6 @@ private:
 
   D3D12_CPU_DESCRIPTOR_HANDLE m_heap_base_cpu{};
 
-  std::unordered_map<SamplerState, D3D12_CPU_DESCRIPTOR_HANDLE> m_sampler_map;
+  std::unordered_map<SamplerState::StorageType, D3D12_CPU_DESCRIPTOR_HANDLE> m_sampler_map;
 };
 }  // namespace DX12
diff --git a/Source/Core/VideoBackends/D3D12/VideoBackend.cpp b/Source/Core/VideoBackends/D3D12/VideoBackend.cpp
index 9ee16c1..89dd437 100644
--- a/Source/Core/VideoBackends/D3D12/VideoBackend.cpp
+++ b/Source/Core/VideoBackends/D3D12/VideoBackend.cpp
@@ -83,9 +83,6 @@ void VideoBackend::FillBackendInfo()
   g_Config.backend_info.AAModes = DXContext::GetAAModes(g_Config.iAdapter);
   g_Config.backend_info.bSupportsShaderBinaries = true;
   g_Config.backend_info.bSupportsPipelineCacheData = true;
-  g_Config.backend_info.bSupportsCoarseDerivatives = true;
-  g_Config.backend_info.bSupportsTextureQueryLevels = true;
-  g_Config.backend_info.bSupportsLodBiasInSampler = true;
 
   // We can only check texture support once we have a device.
   if (g_dx_context)
diff --git a/Source/Core/VideoBackends/D3DCommon/D3DCommon.cpp b/Source/Core/VideoBackends/D3DCommon/D3DCommon.cpp
index 69014d8..e06c6a0 100644
--- a/Source/Core/VideoBackends/D3DCommon/D3DCommon.cpp
+++ b/Source/Core/VideoBackends/D3DCommon/D3DCommon.cpp
@@ -1,8 +1,6 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3DCommon/D3DCommon.h"
-
 #include <d3d11.h>
 #include <d3d12.h>
 #include <dxgi1_3.h>
@@ -13,7 +11,7 @@
 #include "Common/HRWrap.h"
 #include "Common/MsgHandler.h"
 #include "Common/StringUtil.h"
-
+#include "VideoBackends/D3DCommon/D3DCommon.h"
 #include "VideoCommon/TextureConfig.h"
 #include "VideoCommon/VideoConfig.h"
 
diff --git a/Source/Core/VideoBackends/D3DCommon/Shader.cpp b/Source/Core/VideoBackends/D3DCommon/Shader.cpp
index 0d7c84b..ba75fc3 100644
--- a/Source/Core/VideoBackends/D3DCommon/Shader.cpp
+++ b/Source/Core/VideoBackends/D3DCommon/Shader.cpp
@@ -1,8 +1,6 @@
 // Copyright 2019 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/D3DCommon/Shader.h"
-
 #include <fstream>
 #include <wrl/client.h>
 
@@ -14,6 +12,8 @@
 #include "Common/StringUtil.h"
 #include "Common/Version.h"
 
+#include "VideoBackends/D3DCommon/Shader.h"
+
 #include "VideoCommon/VideoBackendBase.h"
 #include "VideoCommon/VideoConfig.h"
 
diff --git a/Source/Core/VideoBackends/Null/NullBackend.cpp b/Source/Core/VideoBackends/Null/NullBackend.cpp
index 635650c..c4e4cad 100644
--- a/Source/Core/VideoBackends/Null/NullBackend.cpp
+++ b/Source/Core/VideoBackends/Null/NullBackend.cpp
@@ -56,9 +56,6 @@ void VideoBackend::InitBackendInfo()
   g_Config.backend_info.bSupportsPartialDepthCopies = false;
   g_Config.backend_info.bSupportsShaderBinaries = false;
   g_Config.backend_info.bSupportsPipelineCacheData = false;
-  g_Config.backend_info.bSupportsCoarseDerivatives = false;
-  g_Config.backend_info.bSupportsTextureQueryLevels = false;
-  g_Config.backend_info.bSupportsLodBiasInSampler = false;
 
   // aamodes: We only support 1 sample, so no MSAA
   g_Config.backend_info.Adapters.clear();
diff --git a/Source/Core/VideoBackends/OGL/OGLMain.cpp b/Source/Core/VideoBackends/OGL/OGLMain.cpp
index 4f4dc21..3ca79d5 100644
--- a/Source/Core/VideoBackends/OGL/OGLMain.cpp
+++ b/Source/Core/VideoBackends/OGL/OGLMain.cpp
@@ -33,8 +33,6 @@ Make AA apply instantly during gameplay if possible
 
 */
 
-#include "VideoBackends/OGL/VideoBackend.h"
-
 #include <memory>
 #include <string>
 #include <vector>
@@ -51,6 +49,7 @@ Make AA apply instantly during gameplay if possible
 #include "VideoBackends/OGL/OGLVertexManager.h"
 #include "VideoBackends/OGL/ProgramShaderCache.h"
 #include "VideoBackends/OGL/SamplerCache.h"
+#include "VideoBackends/OGL/VideoBackend.h"
 
 #include "VideoCommon/FramebufferManager.h"
 #include "VideoCommon/TextureCacheBase.h"
@@ -93,7 +92,6 @@ void VideoBackend::InitBackendInfo()
   g_Config.backend_info.bSupportsPartialDepthCopies = true;
   g_Config.backend_info.bSupportsShaderBinaries = false;
   g_Config.backend_info.bSupportsPipelineCacheData = false;
-  g_Config.backend_info.bSupportsLodBiasInSampler = true;
 
   // TODO: There is a bug here, if texel buffers or SSBOs/atomics are not supported the graphics
   // options will show the option when it is not supported. The only way around this would be
@@ -101,7 +99,7 @@ void VideoBackend::InitBackendInfo()
   g_Config.backend_info.bSupportsGPUTextureDecoding = true;
   g_Config.backend_info.bSupportsBBox = true;
 
-  // Overwritten in OGLRender.cpp later
+  // Overwritten in Render.cpp later
   g_Config.backend_info.bSupportsDualSourceBlend = true;
   g_Config.backend_info.bSupportsPrimitiveRestart = true;
   g_Config.backend_info.bSupportsPaletteConversion = true;
@@ -109,8 +107,6 @@ void VideoBackend::InitBackendInfo()
   g_Config.backend_info.bSupportsDepthClamp = true;
   g_Config.backend_info.bSupportsST3CTextures = false;
   g_Config.backend_info.bSupportsBPTCTextures = false;
-  g_Config.backend_info.bSupportsCoarseDerivatives = false;
-  g_Config.backend_info.bSupportsTextureQueryLevels = false;
 
   g_Config.backend_info.Adapters.clear();
 
diff --git a/Source/Core/VideoBackends/OGL/OGLPipeline.cpp b/Source/Core/VideoBackends/OGL/OGLPipeline.cpp
index b4962cf..ee45fe8 100644
--- a/Source/Core/VideoBackends/OGL/OGLPipeline.cpp
+++ b/Source/Core/VideoBackends/OGL/OGLPipeline.cpp
@@ -1,10 +1,9 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/OGL/OGLPipeline.h"
-
 #include "Common/Assert.h"
 
+#include "VideoBackends/OGL/OGLPipeline.h"
 #include "VideoBackends/OGL/OGLRender.h"
 #include "VideoBackends/OGL/OGLShader.h"
 #include "VideoBackends/OGL/OGLVertexManager.h"
diff --git a/Source/Core/VideoBackends/OGL/OGLRender.cpp b/Source/Core/VideoBackends/OGL/OGLRender.cpp
index 53ed788..81bb5e9 100644
--- a/Source/Core/VideoBackends/OGL/OGLRender.cpp
+++ b/Source/Core/VideoBackends/OGL/OGLRender.cpp
@@ -482,10 +482,6 @@ Renderer::Renderer(std::unique_ptr<GLContext> main_gl_context, float backbuffer_
       GLExtensions::Supports("GL_EXT_texture_compression_s3tc");
   g_Config.backend_info.bSupportsBPTCTextures =
       GLExtensions::Supports("GL_ARB_texture_compression_bptc");
-  g_Config.backend_info.bSupportsCoarseDerivatives =
-      GLExtensions::Supports("GL_ARB_derivative_control") || GLExtensions::Version() >= 450;
-  g_Config.backend_info.bSupportsTextureQueryLevels =
-      GLExtensions::Supports("GL_ARB_texture_query_levels") || GLExtensions::Version() >= 430;
 
   if (m_main_gl_context->IsGLES())
   {
@@ -512,9 +508,6 @@ Renderer::Renderer(std::unique_ptr<GLContext> main_gl_context, float backbuffer_
     // ARB_get_texture_sub_image (unlikely, except maybe on NVIDIA), we can use that instead.
     g_Config.backend_info.bSupportsDepthReadback = g_ogl_config.bSupportsTextureSubImage;
 
-    // GL_TEXTURE_LOD_BIAS is not supported on GLES.
-    g_Config.backend_info.bSupportsLodBiasInSampler = false;
-
     if (GLExtensions::Supports("GL_EXT_shader_framebuffer_fetch"))
     {
       g_ogl_config.SupportedFramebufferFetch = EsFbFetchType::FbFetchExt;
diff --git a/Source/Core/VideoBackends/OGL/OGLTexture.cpp b/Source/Core/VideoBackends/OGL/OGLTexture.cpp
index cf3c5f7..83c1d1b 100644
--- a/Source/Core/VideoBackends/OGL/OGLTexture.cpp
+++ b/Source/Core/VideoBackends/OGL/OGLTexture.cpp
@@ -1,12 +1,11 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/OGL/OGLTexture.h"
-
 #include "Common/Assert.h"
 #include "Common/CommonTypes.h"
 #include "Common/MsgHandler.h"
 
+#include "VideoBackends/OGL/OGLTexture.h"
 #include "VideoBackends/OGL/SamplerCache.h"
 
 namespace OGL
diff --git a/Source/Core/VideoBackends/OGL/ProgramShaderCache.cpp b/Source/Core/VideoBackends/OGL/ProgramShaderCache.cpp
index 659882d..f6c89a8 100644
--- a/Source/Core/VideoBackends/OGL/ProgramShaderCache.cpp
+++ b/Source/Core/VideoBackends/OGL/ProgramShaderCache.cpp
@@ -692,6 +692,7 @@ void ProgramShaderCache::CreateHeader()
   {
   case EsFbFetchType::FbFetchExt:
     framebuffer_fetch_string = "#extension GL_EXT_shader_framebuffer_fetch: enable\n"
+                               "#define FB_FETCH_VALUE real_ocol0\n"
                                "#define FRAGMENT_INOUT inout";
     break;
   case EsFbFetchType::FbFetchArm:
@@ -746,8 +747,6 @@ void ProgramShaderCache::CreateHeader()
       "%s\n"  // shader image load store
       "%s\n"  // shader framebuffer fetch
       "%s\n"  // shader thread shuffle
-      "%s\n"  // derivative control
-      "%s\n"  // query levels
 
       // Precision defines for GLSL ES
       "%s\n"
@@ -827,12 +826,6 @@ void ProgramShaderCache::CreateHeader()
           "#extension GL_ARB_shader_image_load_store : enable" :
           "",
       framebuffer_fetch_string.c_str(), shader_shuffle_string.c_str(),
-      g_ActiveConfig.backend_info.bSupportsCoarseDerivatives ?
-          "#extension GL_ARB_derivative_control : enable" :
-          "",
-      g_ActiveConfig.backend_info.bSupportsTextureQueryLevels ?
-          "#extension GL_ARB_texture_query_levels : enable" :
-          "",
       is_glsles ? "precision highp float;" : "", is_glsles ? "precision highp int;" : "",
       is_glsles ? "precision highp sampler2DArray;" : "",
       (is_glsles && g_ActiveConfig.backend_info.bSupportsPaletteConversion) ?
diff --git a/Source/Core/VideoBackends/OGL/SamplerCache.cpp b/Source/Core/VideoBackends/OGL/SamplerCache.cpp
index c111caa..85af444 100644
--- a/Source/Core/VideoBackends/OGL/SamplerCache.cpp
+++ b/Source/Core/VideoBackends/OGL/SamplerCache.cpp
@@ -2,11 +2,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoBackends/OGL/SamplerCache.h"
+#include "VideoBackends/OGL/OGLRender.h"
 
 #include <memory>
 
 #include "Common/CommonTypes.h"
-#include "VideoBackends/OGL/OGLRender.h"
+#include "VideoCommon/SamplerCommon.h"
 #include "VideoCommon/VideoConfig.h"
 
 namespace OGL
@@ -71,16 +72,16 @@ void SamplerCache::InvalidateBinding(u32 stage)
 void SamplerCache::SetParameters(GLuint sampler_id, const SamplerState& params)
 {
   GLenum min_filter;
-  GLenum mag_filter = (params.tm0.mag_filter == FilterMode::Near) ? GL_NEAREST : GL_LINEAR;
-  if (params.tm0.mipmap_filter == FilterMode::Linear)
+  GLenum mag_filter = (params.mag_filter == SamplerState::Filter::Point) ? GL_NEAREST : GL_LINEAR;
+  if (params.mipmap_filter == SamplerState::Filter::Linear)
   {
-    min_filter = (params.tm0.min_filter == FilterMode::Near) ? GL_NEAREST_MIPMAP_LINEAR :
-                                                               GL_LINEAR_MIPMAP_LINEAR;
+    min_filter = (params.min_filter == SamplerState::Filter::Point) ? GL_NEAREST_MIPMAP_LINEAR :
+                                                                      GL_LINEAR_MIPMAP_LINEAR;
   }
   else
   {
-    min_filter = (params.tm0.min_filter == FilterMode::Near) ? GL_NEAREST_MIPMAP_NEAREST :
-                                                               GL_LINEAR_MIPMAP_NEAREST;
+    min_filter = (params.min_filter == SamplerState::Filter::Point) ? GL_NEAREST_MIPMAP_NEAREST :
+                                                                      GL_LINEAR_MIPMAP_NEAREST;
   }
 
   glSamplerParameteri(sampler_id, GL_TEXTURE_MIN_FILTER, min_filter);
@@ -90,19 +91,17 @@ void SamplerCache::SetParameters(GLuint sampler_id, const SamplerState& params)
       {GL_CLAMP_TO_EDGE, GL_REPEAT, GL_MIRRORED_REPEAT}};
 
   glSamplerParameteri(sampler_id, GL_TEXTURE_WRAP_S,
-                      address_modes[static_cast<u32>(params.tm0.wrap_u.Value())]);
+                      address_modes[static_cast<u32>(params.wrap_u.Value())]);
   glSamplerParameteri(sampler_id, GL_TEXTURE_WRAP_T,
-                      address_modes[static_cast<u32>(params.tm0.wrap_v.Value())]);
+                      address_modes[static_cast<u32>(params.wrap_v.Value())]);
 
-  glSamplerParameterf(sampler_id, GL_TEXTURE_MIN_LOD, params.tm1.min_lod / 16.f);
-  glSamplerParameterf(sampler_id, GL_TEXTURE_MAX_LOD, params.tm1.max_lod / 16.f);
+  glSamplerParameterf(sampler_id, GL_TEXTURE_MIN_LOD, params.min_lod / 16.f);
+  glSamplerParameterf(sampler_id, GL_TEXTURE_MAX_LOD, params.max_lod / 16.f);
 
-  if (g_ActiveConfig.backend_info.bSupportsLodBiasInSampler)
-  {
-    glSamplerParameterf(sampler_id, GL_TEXTURE_LOD_BIAS, params.tm0.lod_bias / 256.f);
-  }
+  if (!static_cast<Renderer*>(g_renderer.get())->IsGLES())
+    glSamplerParameterf(sampler_id, GL_TEXTURE_LOD_BIAS, params.lod_bias / 256.f);
 
-  if (params.tm0.anisotropic_filtering && g_ogl_config.bSupportsAniso)
+  if (params.anisotropic_filtering && g_ogl_config.bSupportsAniso)
   {
     glSamplerParameterf(sampler_id, GL_TEXTURE_MAX_ANISOTROPY_EXT,
                         static_cast<float>(1 << g_ActiveConfig.iMaxAnisotropy));
diff --git a/Source/Core/VideoBackends/Software/DebugUtil.cpp b/Source/Core/VideoBackends/Software/DebugUtil.cpp
index c580461..397442f 100644
--- a/Source/Core/VideoBackends/Software/DebugUtil.cpp
+++ b/Source/Core/VideoBackends/Software/DebugUtil.cpp
@@ -52,8 +52,13 @@ void Shutdown()
 
 static void SaveTexture(const std::string& filename, u32 texmap, s32 mip)
 {
-  u32 width = bpmem.tex.GetUnit(texmap).texImage0.width + 1;
-  u32 height = bpmem.tex.GetUnit(texmap).texImage0.height + 1;
+  FourTexUnits& texUnit = bpmem.tex[(texmap >> 2) & 1];
+  u8 subTexmap = texmap & 3;
+
+  TexImage0& ti0 = texUnit.texImage0[subTexmap];
+
+  u32 width = ti0.width + 1;
+  u32 height = ti0.height + 1;
 
   auto data = std::make_unique<u8[]>(width * height * 4);
 
@@ -75,7 +80,10 @@ void GetTextureRGBA(u8* dst, u32 texmap, s32 mip, u32 width, u32 height)
 
 static s32 GetMaxTextureLod(u32 texmap)
 {
-  u8 maxLod = bpmem.tex.GetUnit(texmap).texMode1.max_lod;
+  FourTexUnits& texUnit = bpmem.tex[(texmap >> 2) & 1];
+  u8 subTexmap = texmap & 3;
+
+  u8 maxLod = texUnit.texMode1[subTexmap].max_lod;
   u8 mip = maxLod >> 4;
   u8 fract = maxLod & 0xf;
 
diff --git a/Source/Core/VideoBackends/Software/Rasterizer.cpp b/Source/Core/VideoBackends/Software/Rasterizer.cpp
index f886858..de9925d 100644
--- a/Source/Core/VideoBackends/Software/Rasterizer.cpp
+++ b/Source/Core/VideoBackends/Software/Rasterizer.cpp
@@ -163,33 +163,31 @@ static void InitSlope(Slope* slope, float f1, float f2, float f3, float DX31, fl
 
 static inline void CalculateLOD(s32* lodp, bool* linear, u32 texmap, u32 texcoord)
 {
-  auto texUnit = bpmem.tex.GetUnit(texmap);
+  const FourTexUnits& texUnit = bpmem.tex[(texmap >> 2) & 1];
+  const u8 subTexmap = texmap & 3;
 
   // LOD calculation requires data from the texture mode for bias, etc.
   // it does not seem to use the actual texture size
-  const TexMode0& tm0 = texUnit.texMode0;
-  const TexMode1& tm1 = texUnit.texMode1;
+  const TexMode0& tm0 = texUnit.texMode0[subTexmap];
+  const TexMode1& tm1 = texUnit.texMode1[subTexmap];
 
   float sDelta, tDelta;
-
-  float* uv00 = rasterBlock.Pixel[0][0].Uv[texcoord];
-  float* uv10 = rasterBlock.Pixel[1][0].Uv[texcoord];
-  float* uv01 = rasterBlock.Pixel[0][1].Uv[texcoord];
-
-  float dudx = fabsf(uv00[0] - uv10[0]);
-  float dvdx = fabsf(uv00[1] - uv10[1]);
-  float dudy = fabsf(uv00[0] - uv01[0]);
-  float dvdy = fabsf(uv00[1] - uv01[1]);
-
   if (tm0.diag_lod == LODType::Diagonal)
   {
-    sDelta = dudx + dudy;
-    tDelta = dvdx + dvdy;
+    float* uv0 = rasterBlock.Pixel[0][0].Uv[texcoord];
+    float* uv1 = rasterBlock.Pixel[1][1].Uv[texcoord];
+
+    sDelta = fabsf(uv0[0] - uv1[0]);
+    tDelta = fabsf(uv0[1] - uv1[1]);
   }
   else
   {
-    sDelta = std::max(dudx, dudy);
-    tDelta = std::max(dvdx, dvdy);
+    float* uv0 = rasterBlock.Pixel[0][0].Uv[texcoord];
+    float* uv1 = rasterBlock.Pixel[1][0].Uv[texcoord];
+    float* uv2 = rasterBlock.Pixel[0][1].Uv[texcoord];
+
+    sDelta = std::max(fabsf(uv0[0] - uv1[0]), fabsf(uv0[0] - uv2[0]));
+    tDelta = std::max(fabsf(uv0[1] - uv1[1]), fabsf(uv0[1] - uv2[1]));
   }
 
   // get LOD in s28.4
diff --git a/Source/Core/VideoBackends/Software/SWOGLWindow.cpp b/Source/Core/VideoBackends/Software/SWOGLWindow.cpp
index 387375c..0b185ae 100644
--- a/Source/Core/VideoBackends/Software/SWOGLWindow.cpp
+++ b/Source/Core/VideoBackends/Software/SWOGLWindow.cpp
@@ -1,8 +1,6 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Software/SWOGLWindow.h"
-
 #include <memory>
 
 #include "Common/GL/GLContext.h"
@@ -10,6 +8,7 @@
 #include "Common/Logging/Log.h"
 #include "Common/MsgHandler.h"
 
+#include "VideoBackends/Software/SWOGLWindow.h"
 #include "VideoBackends/Software/SWTexture.h"
 
 SWOGLWindow::SWOGLWindow() = default;
diff --git a/Source/Core/VideoBackends/Software/SWTexture.cpp b/Source/Core/VideoBackends/Software/SWTexture.cpp
index 082c263..a70f1b0 100644
--- a/Source/Core/VideoBackends/Software/SWTexture.cpp
+++ b/Source/Core/VideoBackends/Software/SWTexture.cpp
@@ -2,13 +2,12 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoBackends/Software/SWTexture.h"
+#include "VideoBackends/Software/SWRenderer.h"
 
 #include <cstring>
-
 #include "Common/Assert.h"
 
 #include "VideoBackends/Software/CopyRegion.h"
-#include "VideoBackends/Software/SWRenderer.h"
 
 namespace SW
 {
diff --git a/Source/Core/VideoBackends/Software/SWmain.cpp b/Source/Core/VideoBackends/Software/SWmain.cpp
index 654813d..a0aa8e0 100644
--- a/Source/Core/VideoBackends/Software/SWmain.cpp
+++ b/Source/Core/VideoBackends/Software/SWmain.cpp
@@ -1,8 +1,6 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Software/VideoBackend.h"
-
 #include <cstring>
 #include <memory>
 #include <string>
@@ -22,6 +20,7 @@
 #include "VideoBackends/Software/SWTexture.h"
 #include "VideoBackends/Software/SWVertexLoader.h"
 #include "VideoBackends/Software/TextureCache.h"
+#include "VideoBackends/Software/VideoBackend.h"
 
 #include "VideoCommon/FramebufferManager.h"
 #include "VideoCommon/TextureCacheBase.h"
@@ -85,9 +84,6 @@ void VideoSoftware::InitBackendInfo()
   g_Config.backend_info.bSupportsShaderBinaries = false;
   g_Config.backend_info.bSupportsPipelineCacheData = false;
   g_Config.backend_info.bSupportsBBox = true;
-  g_Config.backend_info.bSupportsCoarseDerivatives = false;
-  g_Config.backend_info.bSupportsTextureQueryLevels = false;
-  g_Config.backend_info.bSupportsLodBiasInSampler = false;
 
   // aamodes
   g_Config.backend_info.AAModes = {1};
diff --git a/Source/Core/VideoBackends/Software/SetupUnit.cpp b/Source/Core/VideoBackends/Software/SetupUnit.cpp
index 48ab2b2..2b919f4 100644
--- a/Source/Core/VideoBackends/Software/SetupUnit.cpp
+++ b/Source/Core/VideoBackends/Software/SetupUnit.cpp
@@ -1,12 +1,14 @@
 // Copyright 2009 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Software/SetupUnit.h"
-
 #include <cstring>
 
+#include "VideoBackends/Software/SetupUnit.h"
+
 #include "Common/Logging/Log.h"
+
 #include "VideoBackends/Software/Clipper.h"
+
 #include "VideoCommon/OpcodeDecoding.h"
 
 void SetupUnit::Init(OpcodeDecoder::Primitive primitive_type)
diff --git a/Source/Core/VideoBackends/Software/TextureSampler.cpp b/Source/Core/VideoBackends/Software/TextureSampler.cpp
index 0ba340c..f54002b 100644
--- a/Source/Core/VideoBackends/Software/TextureSampler.cpp
+++ b/Source/Core/VideoBackends/Software/TextureSampler.cpp
@@ -11,6 +11,7 @@
 #include "Core/HW/Memmap.h"
 
 #include "VideoCommon/BPMemory.h"
+#include "VideoCommon/SamplerCommon.h"
 #include "VideoCommon/TextureDecoder.h"
 
 #define ALLOW_MIPMAP 1
@@ -73,12 +74,12 @@ void Sample(s32 s, s32 t, s32 lod, bool linear, u8 texmap, u8* sample)
   bool mipLinear = false;
 
 #if (ALLOW_MIPMAP)
-  auto texUnit = bpmem.tex.GetUnit(texmap);
-  const TexMode0& tm0 = texUnit.texMode0;
+  const FourTexUnits& texUnit = bpmem.tex[(texmap >> 2) & 1];
+  const TexMode0& tm0 = texUnit.texMode0[texmap & 3];
 
   const s32 lodFract = lod & 0xf;
 
-  if (lod > 0 && tm0.mipmap_filter != MipMode::None)
+  if (lod > 0 && SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0))
   {
     // use mipmap
     baseMip = lod >> 4;
@@ -114,25 +115,26 @@ void Sample(s32 s, s32 t, s32 lod, bool linear, u8 texmap, u8* sample)
 
 void SampleMip(s32 s, s32 t, s32 mip, bool linear, u8 texmap, u8* sample)
 {
-  auto texUnit = bpmem.tex.GetUnit(texmap);
+  const FourTexUnits& texUnit = bpmem.tex[(texmap >> 2) & 1];
+  const u8 subTexmap = texmap & 3;
 
-  const TexMode0& tm0 = texUnit.texMode0;
-  const TexImage0& ti0 = texUnit.texImage0;
-  const TexTLUT& texTlut = texUnit.texTlut;
+  const TexMode0& tm0 = texUnit.texMode0[subTexmap];
+  const TexImage0& ti0 = texUnit.texImage0[subTexmap];
+  const TexTLUT& texTlut = texUnit.texTlut[subTexmap];
   const TextureFormat texfmt = ti0.format;
   const TLUTFormat tlutfmt = texTlut.tlut_format;
 
   const u8* imageSrc;
   const u8* imageSrcOdd = nullptr;
-  if (texUnit.texImage1.cache_manually_managed)
+  if (texUnit.texImage1[subTexmap].cache_manually_managed)
   {
-    imageSrc = &texMem[texUnit.texImage1.tmem_even * TMEM_LINE_SIZE];
+    imageSrc = &texMem[texUnit.texImage1[subTexmap].tmem_even * TMEM_LINE_SIZE];
     if (texfmt == TextureFormat::RGBA8)
-      imageSrcOdd = &texMem[texUnit.texImage2.tmem_odd * TMEM_LINE_SIZE];
+      imageSrcOdd = &texMem[texUnit.texImage2[subTexmap].tmem_odd * TMEM_LINE_SIZE];
   }
   else
   {
-    const u32 imageBase = texUnit.texImage3.image_base << 5;
+    const u32 imageBase = texUnit.texImage3[subTexmap].image_base << 5;
     imageSrc = Memory::GetPointer(imageBase);
   }
 
@@ -196,7 +198,7 @@ void SampleMip(s32 s, s32 t, s32 mip, bool linear, u8 texmap, u8* sample)
     WrapCoord(&imageSPlus1, tm0.wrap_s, image_width_minus_1 + 1);
     WrapCoord(&imageTPlus1, tm0.wrap_t, image_height_minus_1 + 1);
 
-    if (!(texfmt == TextureFormat::RGBA8 && texUnit.texImage1.cache_manually_managed))
+    if (!(texfmt == TextureFormat::RGBA8 && texUnit.texImage1[subTexmap].cache_manually_managed))
     {
       TexDecoder_DecodeTexel(sampledTex, imageSrc, imageS, imageT, image_width_minus_1, texfmt,
                              tlut, tlutfmt);
@@ -248,7 +250,7 @@ void SampleMip(s32 s, s32 t, s32 mip, bool linear, u8 texmap, u8* sample)
     WrapCoord(&imageS, tm0.wrap_s, image_width_minus_1 + 1);
     WrapCoord(&imageT, tm0.wrap_t, image_height_minus_1 + 1);
 
-    if (!(texfmt == TextureFormat::RGBA8 && texUnit.texImage1.cache_manually_managed))
+    if (!(texfmt == TextureFormat::RGBA8 && texUnit.texImage1[subTexmap].cache_manually_managed))
       TexDecoder_DecodeTexel(sample, imageSrc, imageS, imageT, image_width_minus_1, texfmt, tlut,
                              tlutfmt);
     else
diff --git a/Source/Core/VideoBackends/Vulkan/ObjectCache.cpp b/Source/Core/VideoBackends/Vulkan/ObjectCache.cpp
index fd29645..a1ccdd6 100644
--- a/Source/Core/VideoBackends/Vulkan/ObjectCache.cpp
+++ b/Source/Core/VideoBackends/Vulkan/ObjectCache.cpp
@@ -315,28 +315,28 @@ VkSampler ObjectCache::GetSampler(const SamplerState& info)
        VK_SAMPLER_ADDRESS_MODE_MIRRORED_REPEAT}};
 
   VkSamplerCreateInfo create_info = {
-      VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,              // VkStructureType         sType
-      nullptr,                                            // const void*             pNext
-      0,                                                  // VkSamplerCreateFlags    flags
-      filters[u32(info.tm0.mag_filter.Value())],          // VkFilter                magFilter
-      filters[u32(info.tm0.min_filter.Value())],          // VkFilter                minFilter
-      mipmap_modes[u32(info.tm0.mipmap_filter.Value())],  // VkSamplerMipmapMode mipmapMode
-      address_modes[u32(info.tm0.wrap_u.Value())],        // VkSamplerAddressMode    addressModeU
-      address_modes[u32(info.tm0.wrap_v.Value())],        // VkSamplerAddressMode    addressModeV
-      VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,              // VkSamplerAddressMode    addressModeW
-      info.tm0.lod_bias / 256.0f,                         // float                   mipLodBias
+      VK_STRUCTURE_TYPE_SAMPLER_CREATE_INFO,               // VkStructureType         sType
+      nullptr,                                             // const void*             pNext
+      0,                                                   // VkSamplerCreateFlags    flags
+      filters[static_cast<u32>(info.mag_filter.Value())],  // VkFilter                magFilter
+      filters[static_cast<u32>(info.min_filter.Value())],  // VkFilter                minFilter
+      mipmap_modes[static_cast<u32>(info.mipmap_filter.Value())],  // VkSamplerMipmapMode mipmapMode
+      address_modes[static_cast<u32>(info.wrap_u.Value())],  // VkSamplerAddressMode    addressModeU
+      address_modes[static_cast<u32>(info.wrap_v.Value())],  // VkSamplerAddressMode    addressModeV
+      VK_SAMPLER_ADDRESS_MODE_CLAMP_TO_EDGE,                 // VkSamplerAddressMode    addressModeW
+      info.lod_bias / 256.0f,                                // float                   mipLodBias
       VK_FALSE,                                 // VkBool32                anisotropyEnable
       0.0f,                                     // float                   maxAnisotropy
       VK_FALSE,                                 // VkBool32                compareEnable
       VK_COMPARE_OP_ALWAYS,                     // VkCompareOp             compareOp
-      info.tm1.min_lod / 16.0f,                 // float                   minLod
-      info.tm1.max_lod / 16.0f,                 // float                   maxLod
+      info.min_lod / 16.0f,                     // float                   minLod
+      info.max_lod / 16.0f,                     // float                   maxLod
       VK_BORDER_COLOR_FLOAT_TRANSPARENT_BLACK,  // VkBorderColor           borderColor
       VK_FALSE                                  // VkBool32                unnormalizedCoordinates
   };
 
   // Can we use anisotropic filtering with this sampler?
-  if (info.tm0.anisotropic_filtering && g_vulkan_context->SupportsAnisotropicFiltering())
+  if (info.anisotropic_filtering && g_vulkan_context->SupportsAnisotropicFiltering())
   {
     // Cap anisotropy to device limits.
     create_info.anisotropyEnable = VK_TRUE;
diff --git a/Source/Core/VideoBackends/Vulkan/ShaderCompiler.cpp b/Source/Core/VideoBackends/Vulkan/ShaderCompiler.cpp
index 7da5f82..ae010aa 100644
--- a/Source/Core/VideoBackends/Vulkan/ShaderCompiler.cpp
+++ b/Source/Core/VideoBackends/Vulkan/ShaderCompiler.cpp
@@ -2,6 +2,7 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoBackends/Vulkan/ShaderCompiler.h"
+#include "VideoBackends/Vulkan/VulkanContext.h"
 
 #include <cstddef>
 #include <cstdlib>
@@ -22,7 +23,6 @@
 #include "Common/StringUtil.h"
 #include "Common/Version.h"
 
-#include "VideoBackends/Vulkan/VulkanContext.h"
 #include "VideoCommon/VideoBackendBase.h"
 #include "VideoCommon/VideoConfig.h"
 
@@ -50,13 +50,9 @@ static const char SHADER_HEADER[] = R"(
   #define SAMPLER_BINDING(x) layout(set = 1, binding = x)
   #define TEXEL_BUFFER_BINDING(x) layout(set = 1, binding = (x + 8))
   #define SSBO_BINDING(x) layout(set = 2, binding = x)
-  #define INPUT_ATTACHMENT_BINDING(x, y, z) layout(set = x, binding = y, input_attachment_index = z)
   #define VARYING_LOCATION(x) layout(location = x)
   #define FORCE_EARLY_Z layout(early_fragment_tests) in
 
-  // Metal framebuffer fetch helpers.
-  #define FB_FETCH_VALUE subpassLoad(in_ocol0)
-
   // hlsl to glsl function translation
   #define API_VULKAN 1
   #define float2 vec2
diff --git a/Source/Core/VideoBackends/Vulkan/StagingBuffer.cpp b/Source/Core/VideoBackends/Vulkan/StagingBuffer.cpp
index 5030350..af0152f 100644
--- a/Source/Core/VideoBackends/Vulkan/StagingBuffer.cpp
+++ b/Source/Core/VideoBackends/Vulkan/StagingBuffer.cpp
@@ -1,14 +1,13 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/StagingBuffer.h"
-
 #include <algorithm>
 #include <cstring>
 
 #include "Common/Assert.h"
 
 #include "VideoBackends/Vulkan/CommandBufferManager.h"
+#include "VideoBackends/Vulkan/StagingBuffer.h"
 #include "VideoBackends/Vulkan/VulkanContext.h"
 
 namespace Vulkan
diff --git a/Source/Core/VideoBackends/Vulkan/VKBoundingBox.cpp b/Source/Core/VideoBackends/Vulkan/VKBoundingBox.cpp
index 3138a31..7e4b134 100644
--- a/Source/Core/VideoBackends/Vulkan/VKBoundingBox.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VKBoundingBox.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VKBoundingBox.h"
-
 #include <vector>
 
 #include "Common/Logging/Log.h"
@@ -11,6 +9,7 @@
 #include "VideoBackends/Vulkan/ObjectCache.h"
 #include "VideoBackends/Vulkan/StagingBuffer.h"
 #include "VideoBackends/Vulkan/StateTracker.h"
+#include "VideoBackends/Vulkan/VKBoundingBox.h"
 #include "VideoBackends/Vulkan/VKRenderer.h"
 #include "VideoBackends/Vulkan/VulkanContext.h"
 
diff --git a/Source/Core/VideoBackends/Vulkan/VKMain.cpp b/Source/Core/VideoBackends/Vulkan/VKMain.cpp
index 56cf93a..abe531a 100644
--- a/Source/Core/VideoBackends/Vulkan/VKMain.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VKMain.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VideoBackend.h"
-
 #include <vector>
 
 #include "Common/Logging/LogManager.h"
@@ -16,6 +14,7 @@
 #include "VideoBackends/Vulkan/VKRenderer.h"
 #include "VideoBackends/Vulkan/VKSwapChain.h"
 #include "VideoBackends/Vulkan/VKVertexManager.h"
+#include "VideoBackends/Vulkan/VideoBackend.h"
 #include "VideoBackends/Vulkan/VulkanContext.h"
 
 #include "VideoCommon/FramebufferManager.h"
diff --git a/Source/Core/VideoBackends/Vulkan/VKRenderer.cpp b/Source/Core/VideoBackends/Vulkan/VKRenderer.cpp
index db5037f..06a3f09 100644
--- a/Source/Core/VideoBackends/Vulkan/VKRenderer.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VKRenderer.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VKRenderer.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <cstdio>
@@ -24,6 +22,7 @@
 #include "VideoBackends/Vulkan/VKBoundingBox.h"
 #include "VideoBackends/Vulkan/VKPerfQuery.h"
 #include "VideoBackends/Vulkan/VKPipeline.h"
+#include "VideoBackends/Vulkan/VKRenderer.h"
 #include "VideoBackends/Vulkan/VKShader.h"
 #include "VideoBackends/Vulkan/VKStreamBuffer.h"
 #include "VideoBackends/Vulkan/VKSwapChain.h"
@@ -50,7 +49,7 @@ Renderer::Renderer(std::unique_ptr<SwapChain> swap_chain, float backbuffer_scale
 {
   UpdateActiveConfig();
   for (SamplerState& m_sampler_state : m_sampler_states)
-    m_sampler_state = RenderState::GetPointSamplerState();
+    m_sampler_state.hex = RenderState::GetPointSamplerState().hex;
 }
 
 Renderer::~Renderer() = default;
@@ -546,7 +545,7 @@ void Renderer::SetTexture(u32 index, const AbstractTexture* texture)
 void Renderer::SetSamplerState(u32 index, const SamplerState& state)
 {
   // Skip lookup if the state hasn't changed.
-  if (m_sampler_states[index] == state)
+  if (m_sampler_states[index].hex == state.hex)
     return;
 
   // Look up new state and replace in state tracker.
@@ -558,7 +557,7 @@ void Renderer::SetSamplerState(u32 index, const SamplerState& state)
   }
 
   StateTracker::GetInstance()->SetSampler(index, sampler);
-  m_sampler_states[index] = state;
+  m_sampler_states[index].hex = state.hex;
 }
 
 void Renderer::SetComputeImageTexture(AbstractTexture* texture, bool read, bool write)
@@ -589,7 +588,7 @@ void Renderer::ResetSamplerStates()
   // Invalidate all sampler states, next draw will re-initialize them.
   for (u32 i = 0; i < m_sampler_states.size(); i++)
   {
-    m_sampler_states[i] = RenderState::GetPointSamplerState();
+    m_sampler_states[i].hex = RenderState::GetPointSamplerState().hex;
     StateTracker::GetInstance()->SetSampler(i, g_object_cache->GetPointSampler());
   }
 
diff --git a/Source/Core/VideoBackends/Vulkan/VKShader.cpp b/Source/Core/VideoBackends/Vulkan/VKShader.cpp
index 650ac85..4f88ec4 100644
--- a/Source/Core/VideoBackends/Vulkan/VKShader.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VKShader.cpp
@@ -1,13 +1,12 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VKShader.h"
-
 #include "Common/Align.h"
 #include "Common/Assert.h"
 
 #include "VideoBackends/Vulkan/ObjectCache.h"
 #include "VideoBackends/Vulkan/ShaderCompiler.h"
+#include "VideoBackends/Vulkan/VKShader.h"
 #include "VideoBackends/Vulkan/VulkanContext.h"
 
 namespace Vulkan
diff --git a/Source/Core/VideoBackends/Vulkan/VKTexture.cpp b/Source/Core/VideoBackends/Vulkan/VKTexture.cpp
index b47a5d6..90d1357 100644
--- a/Source/Core/VideoBackends/Vulkan/VKTexture.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VKTexture.cpp
@@ -1,8 +1,6 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VKTexture.h"
-
 #include <algorithm>
 #include <cstddef>
 #include <cstring>
@@ -19,6 +17,7 @@
 #include "VideoBackends/Vulkan/StateTracker.h"
 #include "VideoBackends/Vulkan/VKRenderer.h"
 #include "VideoBackends/Vulkan/VKStreamBuffer.h"
+#include "VideoBackends/Vulkan/VKTexture.h"
 #include "VideoBackends/Vulkan/VulkanContext.h"
 
 namespace Vulkan
diff --git a/Source/Core/VideoBackends/Vulkan/VulkanContext.cpp b/Source/Core/VideoBackends/Vulkan/VulkanContext.cpp
index 40e5429..460180b 100644
--- a/Source/Core/VideoBackends/Vulkan/VulkanContext.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VulkanContext.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VulkanContext.h"
-
 #include <algorithm>
 #include <array>
 #include <cstring>
@@ -13,6 +11,7 @@
 #include "Common/MsgHandler.h"
 #include "Common/StringUtil.h"
 
+#include "VideoBackends/Vulkan/VulkanContext.h"
 #include "VideoCommon/DriverDetails.h"
 #include "VideoCommon/VideoCommon.h"
 
@@ -286,10 +285,7 @@ void VulkanContext::PopulateBackendInfo(VideoConfig* config)
   config->backend_info.bSupportsBPTCTextures = false;              // Dependent on features.
   config->backend_info.bSupportsLogicOp = false;                   // Dependent on features.
   config->backend_info.bSupportsLargePoints = false;               // Dependent on features.
-  config->backend_info.bSupportsFramebufferFetch = false;          // Dependent on OS and features.
-  config->backend_info.bSupportsCoarseDerivatives = true;          // Assumed support.
-  config->backend_info.bSupportsTextureQueryLevels = true;         // Assumed support.
-  config->backend_info.bSupportsLodBiasInSampler = false;          // Dependent on OS.
+  config->backend_info.bSupportsFramebufferFetch = false;          // No support.
 }
 
 void VulkanContext::PopulateBackendInfoAdapters(VideoConfig* config, const GPUList& gpu_list)
@@ -317,13 +313,6 @@ void VulkanContext::PopulateBackendInfoFeatures(VideoConfig* config, VkPhysicalD
   config->backend_info.bSupportsSSAA = (features.sampleRateShading == VK_TRUE);
   config->backend_info.bSupportsLogicOp = (features.logicOp == VK_TRUE);
 
-#ifdef __APPLE__
-  // Metal doesn't support this.
-  config->backend_info.bSupportsLodBiasInSampler = false;
-#else
-  config->backend_info.bSupportsLodBiasInSampler = true;
-#endif
-
   // Disable geometry shader when shaderTessellationAndGeometryPointSize is not supported.
   // Seems this is needed for gl_Layer.
   if (!features.shaderTessellationAndGeometryPointSize)
@@ -348,15 +337,6 @@ void VulkanContext::PopulateBackendInfoFeatures(VideoConfig* config, VkPhysicalD
                                               properties.limits.pointSizeRange[0] <= 1.0f &&
                                               properties.limits.pointSizeRange[1] >= 16;
 
-  std::string device_name = properties.deviceName;
-  u32 vendor_id = properties.vendorID;
-
-  // Only Apple family GPUs support framebuffer fetch.
-  if (vendor_id == 0x106B || device_name.find("Apple") != std::string::npos)
-  {
-    config->backend_info.bSupportsFramebufferFetch = true;
-  }
-
   // Our usage of primitive restart appears to be broken on AMD's binary drivers.
   // Seems to be fine on GCN Gen 1-2, unconfirmed on GCN Gen 3, causes driver resets on GCN Gen 4.
   if (DriverDetails::HasBug(DriverDetails::BUG_PRIMITIVE_RESTART))
diff --git a/Source/Core/VideoBackends/Vulkan/VulkanLoader.cpp b/Source/Core/VideoBackends/Vulkan/VulkanLoader.cpp
index 6b1f688..7c94da0 100644
--- a/Source/Core/VideoBackends/Vulkan/VulkanLoader.cpp
+++ b/Source/Core/VideoBackends/Vulkan/VulkanLoader.cpp
@@ -1,8 +1,6 @@
 // Copyright 2016 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoBackends/Vulkan/VulkanLoader.h"
-
 #include <atomic>
 #include <cstdarg>
 #include <cstdlib>
@@ -12,6 +10,8 @@
 #include "Common/FileUtil.h"
 #include "Common/StringUtil.h"
 
+#include "VideoBackends/Vulkan/VulkanLoader.h"
+
 #define VULKAN_MODULE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_INSTANCE_ENTRY_POINT(name, required) PFN_##name name;
 #define VULKAN_DEVICE_ENTRY_POINT(name, required) PFN_##name name;
diff --git a/Source/Core/VideoCommon/AbstractStagingTexture.cpp b/Source/Core/VideoCommon/AbstractStagingTexture.cpp
index ef7e33d..002ecd7 100644
--- a/Source/Core/VideoCommon/AbstractStagingTexture.cpp
+++ b/Source/Core/VideoCommon/AbstractStagingTexture.cpp
@@ -1,13 +1,12 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/AbstractStagingTexture.h"
-
 #include <algorithm>
 #include <cstring>
 
 #include "Common/Assert.h"
 #include "Common/MsgHandler.h"
+#include "VideoCommon/AbstractStagingTexture.h"
 #include "VideoCommon/AbstractTexture.h"
 
 AbstractStagingTexture::AbstractStagingTexture(StagingTextureType type, const TextureConfig& c)
diff --git a/Source/Core/VideoCommon/AbstractTexture.cpp b/Source/Core/VideoCommon/AbstractTexture.cpp
index fb34e24..9b67c80 100644
--- a/Source/Core/VideoCommon/AbstractTexture.cpp
+++ b/Source/Core/VideoCommon/AbstractTexture.cpp
@@ -1,14 +1,13 @@
 // Copyright 2017 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/AbstractTexture.h"
-
 #include <algorithm>
 
 #include "Common/Assert.h"
 #include "Common/Image.h"
 #include "Common/MsgHandler.h"
 #include "VideoCommon/AbstractStagingTexture.h"
+#include "VideoCommon/AbstractTexture.h"
 #include "VideoCommon/RenderBase.h"
 
 AbstractTexture::AbstractTexture(const TextureConfig& c) : m_config(c)
diff --git a/Source/Core/VideoCommon/AsyncRequests.cpp b/Source/Core/VideoCommon/AsyncRequests.cpp
index f8306dd..10f5b37 100644
--- a/Source/Core/VideoCommon/AsyncRequests.cpp
+++ b/Source/Core/VideoCommon/AsyncRequests.cpp
@@ -1,10 +1,9 @@
 // Copyright 2015 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/AsyncRequests.h"
-
 #include <mutex>
 
+#include "VideoCommon/AsyncRequests.h"
 #include "VideoCommon/Fifo.h"
 #include "VideoCommon/RenderBase.h"
 #include "VideoCommon/Statistics.h"
diff --git a/Source/Core/VideoCommon/BPMemory.h b/Source/Core/VideoCommon/BPMemory.h
index 0d21166..b046aa4 100644
--- a/Source/Core/VideoCommon/BPMemory.h
+++ b/Source/Core/VideoCommon/BPMemory.h
@@ -1113,6 +1113,18 @@ struct fmt::formatter<ZTex2>
   }
 };
 
+struct FourTexUnits
+{
+  TexMode0 texMode0[4];
+  TexMode1 texMode1[4];
+  TexImage0 texImage0[4];
+  TexImage1 texImage1[4];
+  TexImage2 texImage2[4];
+  TexImage3 texImage3[4];
+  TexTLUT texTlut[4];
+  u32 unknown[4];
+};
+
 // Geometry/other structs
 enum class CullMode : u32
 {
@@ -2133,160 +2145,6 @@ struct BPS_TmemConfig
   u32 texinvalidate;
 };
 
-union AllTexUnits;
-
-// The addressing of the texture units is a bit non-obvious.
-// This struct abstracts the complexity away.
-union TexUnitAddress
-{
-  enum class Register : u32
-  {
-    SETMODE0 = 0,
-    SETMODE1 = 1,
-    SETIMAGE0 = 2,
-    SETIMAGE1 = 3,
-    SETIMAGE2 = 4,
-    SETIMAGE3 = 5,
-    SETTLUT = 6,
-    UNKNOWN = 7,
-  };
-
-  BitField<0, 2, u32> UnitIdLow;
-  BitField<2, 3, Register> Reg;
-  BitField<5, 1, u32> UnitIdHigh;
-
-  BitField<0, 6, u32> FullAddress;
-  u32 hex;
-
-  TexUnitAddress() : hex(0) {}
-  TexUnitAddress(u32 unit_id, Register reg = Register::SETMODE0) : hex(0)
-  {
-    UnitIdLow = unit_id & 3;
-    UnitIdHigh = unit_id >> 2;
-    Reg = reg;
-  }
-
-  static TexUnitAddress FromBPAddress(u32 Address)
-  {
-    TexUnitAddress Val;
-    // Clear upper two bits (which should always be 0x80)
-    Val.FullAddress = Address & 0x3f;
-    return Val;
-  }
-
-  u32 GetUnitID() const { return UnitIdLow | (UnitIdHigh << 2); }
-
-private:
-  friend AllTexUnits;
-
-  size_t GetOffset() const { return FullAddress; }
-  size_t GetBPAddress() const { return FullAddress | 0x80; }
-
-  static constexpr size_t ComputeOffset(u32 unit_id)
-  {
-    // FIXME: Would be nice to construct a TexUnitAddress and get its offset,
-    // but that doesn't seem to be possible in c++17
-
-    // So we manually re-implement the calculation
-    return (unit_id & 3) | ((unit_id & 4) << 3);
-  }
-};
-static_assert(sizeof(TexUnitAddress) == sizeof(u32));
-
-// A view of the registers of a single TexUnit
-struct TexUnit
-{
-  TexMode0 texMode0;
-  u32 : 32;  // doing u32 : 96 is legal according to the standard, but msvc
-  u32 : 32;  // doesn't like it. So we stack multiple lines of u32 : 32;
-  u32 : 32;
-  TexMode1 texMode1;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  TexImage0 texImage0;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  TexImage1 texImage1;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  TexImage2 texImage2;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  TexImage3 texImage3;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  TexTLUT texTlut;
-  u32 : 32;
-  u32 : 32;
-  u32 : 32;
-  u32 unknown;
-};
-static_assert(sizeof(TexUnit) == sizeof(u32) * 4 * 7 + sizeof(u32));
-
-union AllTexUnits
-{
-  std::array<u32, 8 * 8> AllRegisters;
-
-  const TexUnit& GetUnit(u32 UnitId) const
-  {
-    auto address = TexUnitAddress(UnitId);
-    const u32* ptr = &AllRegisters[address.GetOffset()];
-    return *reinterpret_cast<const TexUnit*>(ptr);
-  }
-
-private:
-  // For debuggers since GetUnit can be optimised out in release builds
-  template <u32 UnitId>
-  struct TexUnitPadding
-  {
-    static_assert(UnitId != 0, "Can't use 0 as sizeof(std::array<u32, 0>) != 0");
-    std::array<u32, TexUnitAddress::ComputeOffset(UnitId)> pad;
-  };
-
-  TexUnit tex0;
-  struct
-  {
-    TexUnitPadding<1> pad1;
-    TexUnit tex1;
-  };
-  struct
-  {
-    TexUnitPadding<2> pad2;
-    TexUnit tex2;
-  };
-  struct
-  {
-    TexUnitPadding<3> pad3;
-    TexUnit tex3;
-  };
-  struct
-  {
-    TexUnitPadding<4> pad4;
-    TexUnit tex4;
-  };
-  struct
-  {
-    TexUnitPadding<5> pad5;
-    TexUnit tex5;
-  };
-  struct
-  {
-    TexUnitPadding<6> pad6;
-    TexUnit tex6;
-  };
-  struct
-  {
-    TexUnitPadding<7> pad7;
-    TexUnit tex7;
-  };
-};
-static_assert(sizeof(AllTexUnits) == 8 * 8 * sizeof(u32));
-
 // All of BP memory
 
 struct BPCmd
@@ -2351,7 +2209,7 @@ struct BPMemory
   FieldMode fieldmode;                // 68
   u32 unknown10[7];                   // 69-6F
   u32 unknown11[16];                  // 70-7F
-  AllTexUnits tex;                    // 80-bf
+  FourTexUnits tex[2];                // 80-bf
   TevStageCombiner combiners[16];     // 0xC0-0xDF
   TevReg tevregs[4];                  // 0xE0
   FogRangeParams fogRange;            // 0xE8
diff --git a/Source/Core/VideoCommon/BPStructs.cpp b/Source/Core/VideoCommon/BPStructs.cpp
index 503ef61..09193cb 100644
--- a/Source/Core/VideoCommon/BPStructs.cpp
+++ b/Source/Core/VideoCommon/BPStructs.cpp
@@ -32,7 +32,6 @@
 #include "VideoCommon/PixelEngine.h"
 #include "VideoCommon/PixelShaderManager.h"
 #include "VideoCommon/RenderBase.h"
-#include "VideoCommon/TMEM.h"
 #include "VideoCommon/TextureCacheBase.h"
 #include "VideoCommon/TextureDecoder.h"
 #include "VideoCommon/VertexShaderManager.h"
@@ -353,7 +352,7 @@ static void BPWritten(const BPCmd& bp, int cycles_into_future)
     if (OpcodeDecoder::g_record_fifo_data)
       FifoRecorder::GetInstance().UseMemory(addr, tlutXferCount, MemoryUpdate::TMEM);
 
-    TMEM::InvalidateAll();
+    TextureCacheBase::InvalidateAllBindPoints();
 
     return;
   }
@@ -459,7 +458,8 @@ static void BPWritten(const BPCmd& bp, int cycles_into_future)
   }
     return;
   case BPMEM_TEXINVALIDATE:
-    TMEM::Invalidate(bp.newvalue);
+    // TODO: Needs some restructuring in TextureCacheBase.
+    TextureCacheBase::InvalidateAllBindPoints();
     return;
 
   case BPMEM_ZCOMPARE:  // Set the Z-Compare and EFB pixel format
@@ -567,7 +567,7 @@ static void BPWritten(const BPCmd& bp, int cycles_into_future)
       if (OpcodeDecoder::g_record_fifo_data)
         FifoRecorder::GetInstance().UseMemory(src_addr, bytes_read, MemoryUpdate::TMEM);
 
-      TMEM::InvalidateAll();
+      TextureCacheBase::InvalidateAllBindPoints();
     }
     return;
 
@@ -645,48 +645,48 @@ static void BPWritten(const BPCmd& bp, int cycles_into_future)
       GeometryShaderManager::SetTexCoordChanged((bp.address - BPMEM_SU_SSIZE) >> 1);
     }
     return;
-  }
-
-  if ((bp.address & 0xc0) == 0x80)
-  {
-    auto tex_address = TexUnitAddress::FromBPAddress(bp.address);
-
-    switch (tex_address.Reg)
-    {
-    // ------------------------
-    // BPMEM_TX_SETMODE0 - (Texture lookup and filtering mode) LOD/BIAS Clamp, MaxAnsio, LODBIAS,
-    // DiagLoad, Min Filter, Mag Filter, Wrap T, S
-    // BPMEM_TX_SETMODE1 - (LOD Stuff) - Max LOD, Min LOD
-    // ------------------------
-    case TexUnitAddress::Register::SETMODE0:
-    case TexUnitAddress::Register::SETMODE1:
-      TMEM::ConfigurationChanged(tex_address, bp.newvalue);
-      return;
+  // ------------------------
+  // BPMEM_TX_SETMODE0 - (Texture lookup and filtering mode) LOD/BIAS Clamp, MaxAnsio, LODBIAS,
+  // DiagLoad, Min Filter, Mag Filter, Wrap T, S
+  // BPMEM_TX_SETMODE1 - (LOD Stuff) - Max LOD, Min LOD
+  // ------------------------
+  case BPMEM_TX_SETMODE0:  // (0x90 for linear)
+  case BPMEM_TX_SETMODE0_4:
+    TextureCacheBase::InvalidateAllBindPoints();
+    return;
 
-    // --------------------------------------------
-    // BPMEM_TX_SETIMAGE0 - Texture width, height, format
-    // BPMEM_TX_SETIMAGE1 - even LOD address in TMEM - Image Type, Cache Height, Cache Width,
-    //                      TMEM Offset
-    // BPMEM_TX_SETIMAGE2 - odd LOD address in TMEM - Cache Height, Cache Width, TMEM Offset
-    // BPMEM_TX_SETIMAGE3 - Address of Texture in main memory
-    // --------------------------------------------
-    case TexUnitAddress::Register::SETIMAGE0:
-    case TexUnitAddress::Register::SETIMAGE1:
-    case TexUnitAddress::Register::SETIMAGE2:
-    case TexUnitAddress::Register::SETIMAGE3:
-      TMEM::ConfigurationChanged(tex_address, bp.newvalue);
-      return;
+  case BPMEM_TX_SETMODE1:
+  case BPMEM_TX_SETMODE1_4:
+    TextureCacheBase::InvalidateAllBindPoints();
+    return;
+  // --------------------------------------------
+  // BPMEM_TX_SETIMAGE0 - Texture width, height, format
+  // BPMEM_TX_SETIMAGE1 - even LOD address in TMEM - Image Type, Cache Height, Cache Width, TMEM
+  // Offset
+  // BPMEM_TX_SETIMAGE2 - odd LOD address in TMEM - Cache Height, Cache Width, TMEM Offset
+  // BPMEM_TX_SETIMAGE3 - Address of Texture in main memory
+  // --------------------------------------------
+  case BPMEM_TX_SETIMAGE0:
+  case BPMEM_TX_SETIMAGE0_4:
+  case BPMEM_TX_SETIMAGE1:
+  case BPMEM_TX_SETIMAGE1_4:
+  case BPMEM_TX_SETIMAGE2:
+  case BPMEM_TX_SETIMAGE2_4:
+  case BPMEM_TX_SETIMAGE3:
+  case BPMEM_TX_SETIMAGE3_4:
+    TextureCacheBase::InvalidateAllBindPoints();
+    return;
+  // -------------------------------
+  // Set a TLUT
+  // BPMEM_TX_SETTLUT - Format, TMEM Offset (offset of TLUT from start of TMEM high bank > > 5)
+  // -------------------------------
+  case BPMEM_TX_SETTLUT:
+  case BPMEM_TX_SETTLUT_4:
+    TextureCacheBase::InvalidateAllBindPoints();
+    return;
 
-    // -------------------------------
-    // Set a TLUT
-    // BPMEM_TX_SETTLUT - Format, TMEM Offset (offset of TLUT from start of TMEM high bank > > 5)
-    // -------------------------------
-    case TexUnitAddress::Register::SETTLUT:
-      TMEM::ConfigurationChanged(tex_address, bp.newvalue);
-      return;
-    case TexUnitAddress::Register::UNKNOWN:
-      break;  // Not handled
-    }
+  default:
+    break;
   }
 
   switch (bp.address & 0xF0)
diff --git a/Source/Core/VideoCommon/CMakeLists.txt b/Source/Core/VideoCommon/CMakeLists.txt
index 3504bc6..cf08716 100644
--- a/Source/Core/VideoCommon/CMakeLists.txt
+++ b/Source/Core/VideoCommon/CMakeLists.txt
@@ -70,6 +70,7 @@ add_library(videocommon
   RenderBase.h
   RenderState.cpp
   RenderState.h
+  SamplerCommon.h
   ShaderCache.cpp
   ShaderCache.h
   ShaderGenCommon.cpp
@@ -87,10 +88,6 @@ add_library(videocommon
   TextureDecoder.h
   TextureDecoder_Common.cpp
   TextureDecoder_Util.h
-  TextureInfo.cpp
-  TextureInfo.h
-  TMEM.cpp
-  TMEM.h
   UberShaderCommon.cpp
   UberShaderCommon.h
   UberShaderPixel.cpp
@@ -171,12 +168,12 @@ if(FFmpeg_FOUND)
     FFmpeg::swresample
     FFmpeg::swscale
   )
-  if(APPLE)
+  if(APPLE) 
     target_link_libraries(videocommon PRIVATE
       ${COREMEDIA_LIBRARY}
       ${VIDEOTOOLBOX_LIBRARY}
       ${COREVIDEO_LIBRARY}
-      ${AUDIOTOOLBOX_LIBRARY}
+      ${AUDIOTOOLBOX_LIBRARY}    
     )
   endif()
 endif()
diff --git a/Source/Core/VideoCommon/CommandProcessor.cpp b/Source/Core/VideoCommon/CommandProcessor.cpp
index c80469f..e197215 100644
--- a/Source/Core/VideoCommon/CommandProcessor.cpp
+++ b/Source/Core/VideoCommon/CommandProcessor.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/CommandProcessor.h"
-
 #include <atomic>
 #include <cstring>
 #include <fmt/format.h>
@@ -17,6 +15,7 @@
 #include "Core/HW/GPFifo.h"
 #include "Core/HW/MMIO.h"
 #include "Core/HW/ProcessorInterface.h"
+#include "VideoCommon/CommandProcessor.h"
 #include "Core/System.h"
 #include "VideoCommon/Fifo.h"
 
diff --git a/Source/Core/VideoCommon/ConstantManager.h b/Source/Core/VideoCommon/ConstantManager.h
index 5335af9..fe80767 100644
--- a/Source/Core/VideoCommon/ConstantManager.h
+++ b/Source/Core/VideoCommon/ConstantManager.h
@@ -15,14 +15,13 @@ using int4 = std::array<s32, 4>;
 enum class DstBlendFactor : u32;
 enum class SrcBlendFactor : u32;
 enum class ZTexOp : u32;
-enum class LogicOp : u32;
 
 struct PixelShaderConstants
 {
   std::array<int4, 4> colors;
   std::array<int4, 4> kcolors;
   int4 alpha;
-  std::array<uint4, 8> texdims;
+  std::array<float4, 8> texdims;
   std::array<int4, 2> zbias;
   std::array<int4, 2> indtexscale;
   std::array<int4, 6> indtexmtx;
@@ -33,7 +32,7 @@ struct PixelShaderConstants
   float4 zslope;
   std::array<float, 2> efbscale;  // .xy
 
-  // Constants from here onwards are only used in ubershaders, other than pack2.
+  // Constants from here onwards are only used in ubershaders.
   u32 genmode;                  // .z
   u32 alphaTest;                // .w
   u32 fogParam3;                // .x
@@ -45,7 +44,7 @@ struct PixelShaderConstants
   u32 dither;                   // .z (bool)
   u32 bounding_box;             // .w (bool)
   std::array<uint4, 16> pack1;  // .xy - combiners, .z - tevind, .w - iref
-  std::array<uint4, 8> pack2;   // .x - tevorder, .y - tevksel, .z/.w - SamplerState tm0/tm1
+  std::array<uint4, 8> pack2;   // .x - tevorder, .y - tevksel
   std::array<int4, 32> konst;   // .rgba
   // The following are used in ubershaders when using shader_framebuffer_fetch blending
   u32 blend_enable;
@@ -55,9 +54,6 @@ struct PixelShaderConstants
   DstBlendFactor blend_dst_factor_alpha;
   u32 blend_subtract;
   u32 blend_subtract_alpha;
-  // For shader_framebuffer_fetch logic ops:
-  u32 logic_op_enable;  // bool
-  LogicOp logic_op_mode;
 };
 
 struct VertexShaderConstants
diff --git a/Source/Core/VideoCommon/DriverDetails.cpp b/Source/Core/VideoCommon/DriverDetails.cpp
index 0852820..f12318d 100644
--- a/Source/Core/VideoCommon/DriverDetails.cpp
+++ b/Source/Core/VideoCommon/DriverDetails.cpp
@@ -1,11 +1,10 @@
 // Copyright 2013 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/DriverDetails.h"
-
 #include <map>
 
 #include "Common/Logging/LogManager.h"
+#include "VideoCommon/DriverDetails.h"
 
 namespace DriverDetails
 {
diff --git a/Source/Core/VideoCommon/FPSCounter.cpp b/Source/Core/VideoCommon/FPSCounter.cpp
index 4d71a7c..efc351f 100644
--- a/Source/Core/VideoCommon/FPSCounter.cpp
+++ b/Source/Core/VideoCommon/FPSCounter.cpp
@@ -1,8 +1,6 @@
 // Copyright 2012 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/FPSCounter.h"
-
 #include <fstream>
 #include <iomanip>
 
@@ -10,6 +8,7 @@
 #include "Common/FileUtil.h"
 #include "Common/Timer.h"
 #include "Core/Core.h"
+#include "VideoCommon/FPSCounter.h"
 #include "VideoCommon/VideoConfig.h"
 
 static constexpr u64 FPS_REFRESH_INTERVAL = 250000;
diff --git a/Source/Core/VideoCommon/GXPipelineTypes.h b/Source/Core/VideoCommon/GXPipelineTypes.h
index ca3fb89..231bdde 100644
--- a/Source/Core/VideoCommon/GXPipelineTypes.h
+++ b/Source/Core/VideoCommon/GXPipelineTypes.h
@@ -19,7 +19,7 @@ namespace VideoCommon
 // As pipelines encompass both shader UIDs and render states, changes to either of these should
 // also increment the pipeline UID version. Incrementing the UID version will cause all UID
 // caches to be invalidated.
-constexpr u32 GX_PIPELINE_UID_VERSION = 4;  // Last changed in PR 10215
+constexpr u32 GX_PIPELINE_UID_VERSION = 3;  // Last changed in PR 9532
 
 struct GXPipelineUid
 {
diff --git a/Source/Core/VideoCommon/GeometryShaderManager.cpp b/Source/Core/VideoCommon/GeometryShaderManager.cpp
index f488ed7..3afeb1d 100644
--- a/Source/Core/VideoCommon/GeometryShaderManager.cpp
+++ b/Source/Core/VideoCommon/GeometryShaderManager.cpp
@@ -1,13 +1,12 @@
 // Copyright 2014 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/GeometryShaderManager.h"
-
 #include <cstring>
 
 #include "Common/ChunkFile.h"
 #include "Common/CommonTypes.h"
 #include "VideoCommon/BPMemory.h"
+#include "VideoCommon/GeometryShaderManager.h"
 #include "VideoCommon/VideoConfig.h"
 #include "VideoCommon/XFMemory.h"
 
diff --git a/Source/Core/VideoCommon/HiresTextures.cpp b/Source/Core/VideoCommon/HiresTextures.cpp
index 85c9cfc..e6fe108 100644
--- a/Source/Core/VideoCommon/HiresTextures.cpp
+++ b/Source/Core/VideoCommon/HiresTextures.cpp
@@ -213,36 +213,78 @@ void HiresTexture::Prefetch()
                   10000);
 }
 
-std::string HiresTexture::GenBaseName(TextureInfo& texture_info, bool dump)
+std::string HiresTexture::GenBaseName(const u8* texture, size_t texture_size, const u8* tlut,
+                                      size_t tlut_size, u32 width, u32 height, TextureFormat format,
+                                      bool has_mipmaps, bool dump)
 {
   if (!dump && s_textureMap.empty())
     return "";
 
-  const auto texture_name_details = texture_info.CalculateTextureName();
+  // checking for min/max on paletted textures
+  u32 min = 0xffff;
+  u32 max = 0;
+  switch (tlut_size)
+  {
+  case 0:
+    break;
+  case 16 * 2:
+    for (size_t i = 0; i < texture_size; i++)
+    {
+      const u32 low_nibble = texture[i] & 0xf;
+      const u32 high_nibble = texture[i] >> 4;
 
-  // look for an exact match first
-  const std::string full_name = texture_name_details.GetFullName();
-  if (dump || s_textureMap.find(full_name) != s_textureMap.end())
-    return full_name;
+      min = std::min({min, low_nibble, high_nibble});
+      max = std::max({max, low_nibble, high_nibble});
+    }
+    break;
+  case 256 * 2:
+  {
+    for (size_t i = 0; i < texture_size; i++)
+    {
+      const u32 texture_byte = texture[i];
+
+      min = std::min(min, texture_byte);
+      max = std::max(max, texture_byte);
+    }
+    break;
+  }
+  case 16384 * 2:
+    for (size_t i = 0; i < texture_size; i += sizeof(u16))
+    {
+      const u32 texture_halfword = Common::swap16(texture[i]) & 0x3fff;
 
-  // else try and find a wildcard
+      min = std::min(min, texture_halfword);
+      max = std::max(max, texture_halfword);
+    }
+    break;
+  }
+  if (tlut_size > 0)
+  {
+    tlut_size = 2 * (max + 1 - min);
+    tlut += 2 * min;
+  }
+
+  const u64 tex_hash = XXH64(texture, texture_size, 0);
+  const u64 tlut_hash = tlut_size ? XXH64(tlut, tlut_size, 0) : 0;
+
+  const std::string base_name = fmt::format("{}{}x{}{}_{:016x}", s_format_prefix, width, height,
+                                            has_mipmaps ? "_m" : "", tex_hash);
+  const std::string tlut_name = tlut_size ? fmt::format("_{:016x}", tlut_hash) : "";
+  const std::string format_name = fmt::format("_{}", static_cast<int>(format));
+  const std::string full_name = base_name + tlut_name + format_name;
+
+  // try to match a wildcard template
   if (!dump)
   {
-    // Single wildcard ignoring the tlut hash
-    const std::string texture_name_single_wildcard_tlut =
-        fmt::format("{}_{}_$_{}", texture_name_details.base_name, texture_name_details.texture_name,
-                    texture_name_details.format_name);
-    if (s_textureMap.find(texture_name_single_wildcard_tlut) != s_textureMap.end())
-      return texture_name_single_wildcard_tlut;
-
-    // Single wildcard ignoring the texture hash
-    const std::string texture_name_single_wildcard_tex =
-        fmt::format("{}_${}_{}", texture_name_details.base_name, texture_name_details.tlut_name,
-                    texture_name_details.format_name);
-    if (s_textureMap.find(texture_name_single_wildcard_tex) != s_textureMap.end())
-      return texture_name_single_wildcard_tex;
+    const std::string texture_name = fmt::format("{}_${}", base_name, format_name);
+    if (s_textureMap.find(texture_name) != s_textureMap.end())
+      return texture_name;
   }
 
+  // else generate the complete texture
+  if (dump || s_textureMap.find(full_name) != s_textureMap.end())
+    return full_name;
+
   return "";
 }
 
@@ -261,9 +303,13 @@ u32 HiresTexture::CalculateMipCount(u32 width, u32 height)
   return mip_count;
 }
 
-std::shared_ptr<HiresTexture> HiresTexture::Search(TextureInfo& texture_info)
+std::shared_ptr<HiresTexture> HiresTexture::Search(const u8* texture, size_t texture_size,
+                                                   const u8* tlut, size_t tlut_size, u32 width,
+                                                   u32 height, TextureFormat format,
+                                                   bool has_mipmaps)
 {
-  const std::string base_filename = GenBaseName(texture_info);
+  std::string base_filename =
+      GenBaseName(texture, texture_size, tlut, tlut_size, width, height, format, has_mipmaps);
 
   std::lock_guard<std::mutex> lk(s_textureCacheMutex);
 
@@ -273,8 +319,7 @@ std::shared_ptr<HiresTexture> HiresTexture::Search(TextureInfo& texture_info)
     return iter->second;
   }
 
-  std::shared_ptr<HiresTexture> ptr(
-      Load(base_filename, texture_info.GetRawWidth(), texture_info.GetRawHeight()));
+  std::shared_ptr<HiresTexture> ptr(Load(base_filename, width, height));
 
   if (ptr && g_ActiveConfig.bCacheHiresTextures)
   {
diff --git a/Source/Core/VideoCommon/HiresTextures.h b/Source/Core/VideoCommon/HiresTextures.h
index 78e4046..21e6e2d 100644
--- a/Source/Core/VideoCommon/HiresTextures.h
+++ b/Source/Core/VideoCommon/HiresTextures.h
@@ -10,7 +10,6 @@
 
 #include "Common/CommonTypes.h"
 #include "VideoCommon/TextureConfig.h"
-#include "VideoCommon/TextureInfo.h"
 
 enum class TextureFormat;
 
@@ -25,9 +24,13 @@ public:
   static void Clear();
   static void Shutdown();
 
-  static std::shared_ptr<HiresTexture> Search(TextureInfo& texture_info);
+  static std::shared_ptr<HiresTexture> Search(const u8* texture, size_t texture_size,
+                                              const u8* tlut, size_t tlut_size, u32 width,
+                                              u32 height, TextureFormat format, bool has_mipmaps);
 
-  static std::string GenBaseName(TextureInfo& texture_info, bool dump = false);
+  static std::string GenBaseName(const u8* texture, size_t texture_size, const u8* tlut,
+                                 size_t tlut_size, u32 width, u32 height, TextureFormat format,
+                                 bool has_mipmaps, bool dump = false);
 
   static u32 CalculateMipCount(u32 width, u32 height);
 
diff --git a/Source/Core/VideoCommon/PixelShaderGen.cpp b/Source/Core/VideoCommon/PixelShaderGen.cpp
index 673c97e..b517012 100644
--- a/Source/Core/VideoCommon/PixelShaderGen.cpp
+++ b/Source/Core/VideoCommon/PixelShaderGen.cpp
@@ -333,9 +333,6 @@ PixelShaderUid GetPixelShaderUid()
     uid_data->blend_subtract_alpha = state.subtractAlpha;
   }
 
-  uid_data->logic_op_enable = state.logicopenable;
-  uid_data->logic_op_mode = u32(state.logicmode.Value());
-
   return out;
 }
 
@@ -386,7 +383,7 @@ void WritePixelShaderCommonHeader(ShaderCode& out, APIType api_type,
     // Declare samplers
     out.Write("SamplerState samp[8] : register(s0);\n"
               "\n"
-              "Texture2DArray tex[8] : register(t0);\n");
+              "Texture2DArray Tex[8] : register(t0);\n");
   }
   out.Write("\n");
 
@@ -398,7 +395,7 @@ void WritePixelShaderCommonHeader(ShaderCode& out, APIType api_type,
   out.Write("\tint4 " I_COLORS "[4];\n"
             "\tint4 " I_KCOLORS "[4];\n"
             "\tint4 " I_ALPHA ";\n"
-            "\tint4 " I_TEXDIMS "[8];\n"
+            "\tfloat4 " I_TEXDIMS "[8];\n"
             "\tint4 " I_ZBIAS "[2];\n"
             "\tint4 " I_INDTEXSCALE "[2];\n"
             "\tint4 " I_INDTEXMTX "[6];\n"
@@ -419,7 +416,7 @@ void WritePixelShaderCommonHeader(ShaderCode& out, APIType api_type,
             "\tbool  bpmem_dither;\n"
             "\tbool  bpmem_bounding_box;\n"
             "\tuint4 bpmem_pack1[16];\n"  // .xy - combiners, .z - tevind
-            "\tuint4 bpmem_pack2[8];\n"   // .x - tevorder, .y - tevksel, .zw - SamplerState tm0/tm1
+            "\tuint4 bpmem_pack2[8];\n"   // .x - tevorder, .y - tevksel
             "\tint4  konstLookup[32];\n"
             "\tbool  blend_enable;\n"
             "\tuint  blend_src_factor;\n"
@@ -428,16 +425,12 @@ void WritePixelShaderCommonHeader(ShaderCode& out, APIType api_type,
             "\tuint  blend_dst_factor_alpha;\n"
             "\tbool  blend_subtract;\n"
             "\tbool  blend_subtract_alpha;\n"
-            "\tbool  logic_op_enable;\n"
-            "\tuint  logic_op_mode;\n"
             "}};\n\n");
   out.Write("#define bpmem_combiners(i) (bpmem_pack1[(i)].xy)\n"
             "#define bpmem_tevind(i) (bpmem_pack1[(i)].z)\n"
             "#define bpmem_iref(i) (bpmem_pack1[(i)].w)\n"
             "#define bpmem_tevorder(i) (bpmem_pack2[(i)].x)\n"
-            "#define bpmem_tevksel(i) (bpmem_pack2[(i)].y)\n"
-            "#define samp_texmode0(i) (bpmem_pack2[(i)].z)\n"
-            "#define samp_texmode1(i) (bpmem_pack2[(i)].w)\n\n");
+            "#define bpmem_tevksel(i) (bpmem_pack2[(i)].y)\n\n");
 
   if (host_config.per_pixel_lighting)
   {
@@ -543,320 +536,17 @@ void UpdateBoundingBox(float2 rawpos) {{
 )",
               fmt::arg("efb_height", EFB_HEIGHT), fmt::arg("efb_scale", I_EFBSCALE));
   }
-
-  if (host_config.manual_texture_sampling)
-  {
-    if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-    {
-      out.Write(R"(
-int4 readTexture(in sampler2DArray tex, uint u, uint v, int layer, int lod) {{
-  return iround(texelFetch(tex, int3(u, v, layer), lod) * 255.0);
-}}
-
-int4 readTextureLinear(in sampler2DArray tex, uint2 uv1, uint2 uv2, int layer, int lod, int2 frac_uv) {{)");
-    }
-    else if (api_type == APIType::D3D)
-    {
-      out.Write(R"(
-int4 readTexture(in Texture2DArray tex, uint u, uint v, int layer, int lod) {{
-  return iround(tex.Load(int4(u, v, layer, lod)) * 255.0);
-}}
-
-int4 readTextureLinear(in Texture2DArray tex, uint2 uv1, uint2 uv2, int layer, int lod, int2 frac_uv) {{)");
-    }
-
-    out.Write(R"(
-  int4 result =
-    readTexture(tex, uv1.x, uv1.y, layer, lod) * (128 - frac_uv.x) * (128 - frac_uv.y) +
-    readTexture(tex, uv2.x, uv1.y, layer, lod) * (      frac_uv.x) * (128 - frac_uv.y) +
-    readTexture(tex, uv1.x, uv2.y, layer, lod) * (128 - frac_uv.x) * (      frac_uv.y) +
-    readTexture(tex, uv2.x, uv2.y, layer, lod) * (      frac_uv.x) * (      frac_uv.y);
-  return result >> 14;
-}}
-)");
-
-    if (host_config.manual_texture_sampling_custom_texture_sizes)
-    {
-      // This is slower, and doesn't result in the same odd behavior that happens on console when
-      // wrapping with non-power-of-2 sizes, but it's fine for custom textures to have non-console
-      // behavior.
-      out.Write(R"(
-// Both GLSL and HLSL produce undefined values when the modulo operator (%) is used with a negative
-// dividend and a positive divisor.  We want a positive value such that SafeModulo(-1, 3) is 2.
-int SafeModulo(int dividend, int divisor) {{
-  if (dividend >= 0) {{
-    return dividend % divisor;
-  }} else {{
-    // This works because ~x is the same as -x - 1.
-    // `~x % 5` over -5 to -1 gives 4, 3, 2, 1, 0.  `4 - (~x % 5)` gives 0, 1, 2, 3, 4.
-    return (divisor - 1) - (~dividend % divisor);
-  }}
-}}
-
-uint WrapCoord(int coord, uint wrap, int size) {{
-  switch (wrap) {{
-    case {:s}:
-    default: // confirmed that clamp is used for invalid (3) via hardware test
-      return uint(clamp(coord, 0, size - 1));
-    case {:s}:
-      return uint(SafeModulo(coord, size));  // coord % size
-    case {:s}:
-      if (SafeModulo(coord, 2 * size) >= size) {{  // coord % (2 * size)
-        coord = ~coord;
-      }}
-      return uint(SafeModulo(coord, size));  // coord % size
-  }}
-}}
-)",
-                WrapMode::Clamp, WrapMode::Repeat, WrapMode::Mirror);
-    }
-    else
-    {
-      out.Write(R"(
-uint WrapCoord(int coord, uint wrap, int size) {{
-  switch (wrap) {{
-    case {:s}:
-    default: // confirmed that clamp is used for invalid (3) via hardware test
-      return uint(clamp(coord, 0, size - 1));
-    case {:s}:
-      return uint(coord & (size - 1));
-    case {:s}:
-      if ((coord & size) != 0) {{
-        coord = ~coord;
-      }}
-      return uint(coord & (size - 1));
-  }}
-}}
-)",
-                WrapMode::Clamp, WrapMode::Repeat, WrapMode::Mirror);
-    }
-  }
-
-  if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-  {
-    out.Write("\nint4 sampleTexture(uint texmap, in sampler2DArray tex, int2 uv, int layer) {{\n");
-  }
-  else if (api_type == APIType::D3D)
-  {
-    out.Write("\nint4 sampleTexture(uint texmap, in Texture2DArray tex, in SamplerState tex_samp, "
-              "int2 uv, int layer) {{\n");
-  }
-
-  if (!host_config.manual_texture_sampling)
-  {
-    out.Write("  float size_s = float(" I_TEXDIMS "[texmap].x * 128);\n"
-              "  float size_t = float(" I_TEXDIMS "[texmap].y * 128);\n"
-              "  float3 coords = float3(float(uv.x) / size_s, float(uv.y) / size_t, layer);\n");
-    if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-    {
-      if (!host_config.backend_sampler_lod_bias)
-      {
-        out.Write("  uint texmode0 = samp_texmode0(texmap);\n"
-                  "  float lod_bias = float({}) / 256.0f;\n"
-                  "  return iround(255.0 * texture(tex, coords, lod_bias));\n",
-                  BitfieldExtract<&SamplerState::TM0::lod_bias>("texmode0"));
-      }
-      else
-      {
-        out.Write("  return iround(255.0 * texture(tex, coords));\n");
-      }
-
-      out.Write("}}\n");
-    }
-    else if (api_type == APIType::D3D)
-    {
-      out.Write("  return iround(255.0 * tex.Sample(tex_samp, coords));\n}}\n");
-    }
-  }
-  else
-  {
-    out.Write(R"(
-  uint texmode0 = samp_texmode0(texmap);
-  uint texmode1 = samp_texmode1(texmap);
-
-  uint wrap_s = {};
-  uint wrap_t = {};
-  bool mag_linear = {} != 0u;
-  bool mipmap_linear = {} != 0u;
-  bool min_linear = {} != 0u;
-  bool diag_lod = {} != 0u;
-  int lod_bias = {};
-  // uint max_aniso = TODO;
-  bool lod_clamp = {} != 0u;
-  int min_lod = int({});
-  int max_lod = int({});
-)",
-              BitfieldExtract<&SamplerState::TM0::wrap_u>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::wrap_v>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::mag_filter>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::mipmap_filter>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::min_filter>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::diag_lod>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::lod_bias>("texmode0"),
-              // BitfieldExtract<&SamplerState::TM0::max_aniso>("texmode0"),
-              BitfieldExtract<&SamplerState::TM0::lod_clamp>("texmode0"),
-              BitfieldExtract<&SamplerState::TM1::min_lod>("texmode1"),
-              BitfieldExtract<&SamplerState::TM1::max_lod>("texmode1"));
-
-    if (host_config.manual_texture_sampling_custom_texture_sizes)
-    {
-      out.Write(R"(
-  int native_size_s = )" I_TEXDIMS R"([texmap].x;
-  int native_size_t = )" I_TEXDIMS R"([texmap].y;
-)");
-
-      if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-      {
-        out.Write(R"(
-  int3 size = textureSize(tex, 0);
-  int size_s = size.x;
-  int size_t = size.y;
-)");
-        if (g_ActiveConfig.backend_info.bSupportsTextureQueryLevels)
-        {
-          out.Write("  int number_of_levels = textureQueryLevels(tex);\n");
-        }
-        else
-        {
-          out.Write("  int number_of_levels = 256;  // textureQueryLevels is not supported\n");
-          ERROR_LOG_FMT(VIDEO, "textureQueryLevels is not supported!  Odd graphical results may "
-                               "occur if custom textures are in use!");
-        }
-      }
-      else if (api_type == APIType::D3D)
-      {
-        ASSERT(g_ActiveConfig.backend_info.bSupportsTextureQueryLevels);
-        out.Write(R"(
-  int size_s, size_t, layers, number_of_levels;
-  tex.GetDimensions(0, size_s, size_t, layers, number_of_levels);
-)");
-      }
-
-      out.Write(R"(
-  // Prevent out-of-bounds LOD values when using custom textures
-  max_lod = min(max_lod, (number_of_levels - 1) << 4);
-  // Rescale uv to account for the new texture size
-  uv.x = (uv.x * size_s) / native_size_s;
-  uv.y = (uv.y * size_t) / native_size_t;
-)");
-    }
-    else
-    {
-      out.Write(R"(
-  int size_s = )" I_TEXDIMS R"([texmap].x;
-  int size_t = )" I_TEXDIMS R"([texmap].y;
-)");
-    }
-
-    if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-    {
-      if (g_ActiveConfig.backend_info.bSupportsCoarseDerivatives)
-      {
-        // The software renderer uses the equivalent of coarse derivatives, so use them here for
-        // consistency.  This hasn't been hardware tested.
-        // Note that bSupportsCoarseDerivatives being false only means dFdxCoarse and dFdxFine don't
-        // exist.  The GPU may still implement dFdx using coarse derivatives; we just don't have the
-        // ability to specifically require it.
-        out.Write(R"(
-  float2 uv_delta_x = abs(dFdxCoarse(float2(uv)));
-  float2 uv_delta_y = abs(dFdyCoarse(float2(uv)));
-)");
-      }
-      else
-      {
-        out.Write(R"(
-  float2 uv_delta_x = abs(dFdx(float2(uv)));
-  float2 uv_delta_y = abs(dFdy(float2(uv)));
-)");
-      }
-    }
-    else if (api_type == APIType::D3D)
-    {
-      ASSERT(g_ActiveConfig.backend_info.bSupportsCoarseDerivatives);
-      out.Write(R"(
-  float2 uv_delta_x = abs(ddx_coarse(float2(uv)));
-  float2 uv_delta_y = abs(ddy_coarse(float2(uv)));
-)");
-    }
-
-    // TODO: LOD bias is normally S2.5 (Dolphin uses S7.8 for arbitrary mipmap detection and higher
-    // IRs), but (at least per the software renderer) actual LOD is S28.4.  How does this work?
-    // Also, note that we can make some assumptions due to use of a SamplerState version of the BP
-    // configuration, which tidies things compared to whatever nonsense games can put in.
-    out.Write(R"(
-  float2 uv_delta = diag_lod ? uv_delta_x + uv_delta_y : max(uv_delta_x, uv_delta_y);
-  float max_delta = max(uv_delta.x / 128.0, uv_delta.y / 128.0);
-  // log2(x) is undefined if x <= 0, but in practice it seems log2(0) is -infinity, which becomes INT_MIN.
-  // If lod_bias is negative, adding it to INT_MIN causes an underflow, resulting in a large positive value.
-  // Hardware testing indicates that min_lod should be used when the derivative is 0.
-  int lod = max_delta == 0.0 ? min_lod : int(floor(log2(max_delta) * 16.0)) + (lod_bias >> 4);
-
-  bool is_linear = (lod > 0) ? min_linear : mag_linear;
-  lod = clamp(lod, min_lod, max_lod);
-  int base_lod = lod >> 4;
-  int frac_lod = lod & 15;
-  if (!mipmap_linear && frac_lod >= 8) {{
-    // Round to nearest LOD in point mode
-    base_lod++;
-  }}
-
-  if (is_linear) {{
-    uint2 texuv1 = uint2(
-        WrapCoord(((uv.x >> base_lod) - 64) >> 7, wrap_s, size_s >> base_lod),
-        WrapCoord(((uv.y >> base_lod) - 64) >> 7, wrap_t, size_t >> base_lod));
-    uint2 texuv2 = uint2(
-        WrapCoord(((uv.x >> base_lod) + 64) >> 7, wrap_s, size_s >> base_lod),
-        WrapCoord(((uv.y >> base_lod) + 64) >> 7, wrap_t, size_t >> base_lod));
-    int2 frac_uv = int2(((uv.x >> base_lod) - 64) & 0x7f, ((uv.y >> base_lod) - 64) & 0x7f);
-
-    int4 result = readTextureLinear(tex, texuv1, texuv2, layer, base_lod, frac_uv);
-
-    if (frac_lod != 0 && mipmap_linear) {{
-      texuv1 = uint2(
-          WrapCoord(((uv.x >> (base_lod + 1)) - 64) >> 7, wrap_s, size_s >> (base_lod + 1)),
-          WrapCoord(((uv.y >> (base_lod + 1)) - 64) >> 7, wrap_t, size_t >> (base_lod + 1)));
-      texuv2 = uint2(
-          WrapCoord(((uv.x >> (base_lod + 1)) + 64) >> 7, wrap_s, size_s >> (base_lod + 1)),
-          WrapCoord(((uv.y >> (base_lod + 1)) + 64) >> 7, wrap_t, size_t >> (base_lod + 1)));
-      frac_uv = int2(((uv.x >> (base_lod + 1)) - 64) & 0x7f, ((uv.y >> (base_lod + 1)) - 64) & 0x7f);
-
-      result *= 16 - frac_lod;
-      result += readTextureLinear(tex, texuv1, texuv2, layer, base_lod + 1, frac_uv) * frac_lod;
-      result >>= 4;
-    }}
-
-    return result;
-  }} else {{
-    uint2 texuv = uint2(
-        WrapCoord(uv.x >> (7 + base_lod), wrap_s, size_s >> base_lod),
-        WrapCoord(uv.y >> (7 + base_lod), wrap_t, size_t >> base_lod));
-
-    int4 result = readTexture(tex, texuv.x, texuv.y, layer, base_lod);
-
-    if (frac_lod != 0 && mipmap_linear) {{
-      texuv = uint2(
-          WrapCoord(uv.x >> (7 + base_lod + 1), wrap_s, size_s >> (base_lod + 1)),
-          WrapCoord(uv.y >> (7 + base_lod + 1), wrap_t, size_t >> (base_lod + 1)));
-
-      result *= 16 - frac_lod;
-      result += readTexture(tex, texuv.x, texuv.y, layer, base_lod + 1) * frac_lod;
-      result >>= 4;
-    }}
-    return result;
-  }}
-}}
-)");
-  }
 }
 
 static void WriteStage(ShaderCode& out, const pixel_shader_uid_data* uid_data, int n,
                        APIType api_type, bool stereo);
 static void WriteTevRegular(ShaderCode& out, std::string_view components, TevBias bias, TevOp op,
                             bool clamp, TevScale scale, bool alpha);
+static void SampleTexture(ShaderCode& out, std::string_view texcoords, std::string_view texswap,
+                          int texmap, bool stereo, APIType api_type);
 static void WriteAlphaTest(ShaderCode& out, const pixel_shader_uid_data* uid_data, APIType api_type,
                            bool per_pixel_depth, bool use_dual_source);
 static void WriteFog(ShaderCode& out, const pixel_shader_uid_data* uid_data);
-static void WriteLogicOp(ShaderCode& out, const pixel_shader_uid_data* uid_data);
 static void WriteColor(ShaderCode& out, APIType api_type, const pixel_shader_uid_data* uid_data,
                        bool use_dual_source);
 static void WriteBlend(ShaderCode& out, const pixel_shader_uid_data* uid_data);
@@ -877,20 +567,8 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
             uid_data->genMode_numtexgens, uid_data->genMode_numindstages);
 
   // Stuff that is shared between ubershaders and pixelgen.
-  WriteBitfieldExtractHeader(out, api_type, host_config);
   WritePixelShaderCommonHeader(out, api_type, host_config, uid_data->bounding_box);
 
-  if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-  {
-    out.Write("\n#define sampleTextureWrapper(texmap, uv, layer) "
-              "sampleTexture(texmap, samp[texmap], uv, layer)\n");
-  }
-  else if (api_type == APIType::D3D)
-  {
-    out.Write("\n#define sampleTextureWrapper(texmap, uv, layer) "
-              "sampleTexture(texmap, tex[texmap], samp[texmap], uv, layer)\n");
-  }
-
   if (uid_data->forced_early_z && g_ActiveConfig.backend_info.bSupportsEarlyZ)
   {
     // Zcomploc (aka early_ztest) is a way to control whether depth test is done before
@@ -945,58 +623,40 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
        uid_data->useDstAlpha);
   const bool use_shader_blend =
       !use_dual_source && (uid_data->useDstAlpha && host_config.backend_shader_framebuffer_fetch);
-  const bool use_shader_logic_op =
-      !host_config.backend_logic_op && host_config.backend_shader_framebuffer_fetch;
 
   if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
   {
-    bool use_framebuffer_fetch = use_shader_blend || use_shader_logic_op;
-
-#ifdef __APPLE__
-    // Framebuffer fetch is only supported by Metal, so ensure that we're running Vulkan (MoltenVK)
-    // if we want to use it.
-    if (api_type == APIType::Vulkan)
+    if (use_dual_source)
     {
-      if (use_dual_source)
+      if (DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION))
+      {
+        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n"
+                  "FRAGMENT_OUTPUT_LOCATION(1) out vec4 ocol1;\n");
+      }
+      else
       {
         out.Write("FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0) out vec4 ocol0;\n"
                   "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 1) out vec4 ocol1;\n");
       }
-      else if (use_shader_blend)
+    }
+    else if (use_shader_blend)
+    {
+      // QComm's Adreno driver doesn't seem to like using the framebuffer_fetch value as an
+      // intermediate value with multiple reads & modifications, so pull out the "real" output value
+      // and use a temporary for calculations, then set the output value once at the end of the
+      // shader
+      if (DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION))
       {
-        // Metal doesn't support a single unified variable for both input and output, so we declare
-        // the output separately. The input will be defined later below.
-        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 real_ocol0;\n");
+        out.Write("FRAGMENT_OUTPUT_LOCATION(0) FRAGMENT_INOUT vec4 real_ocol0;\n");
       }
       else
       {
-        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n");
-      }
-
-      if (use_framebuffer_fetch)
-      {
-        // Subpass inputs will be converted to framebuffer fetch by SPIRV-Cross.
-        out.Write("INPUT_ATTACHMENT_BINDING(0, 0, 0) uniform subpassInput in_ocol0;\n");
+        out.Write("FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0) FRAGMENT_INOUT vec4 real_ocol0;\n");
       }
     }
     else
-#endif
     {
-      bool has_broken_decoration =
-          DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION);
-
-      out.Write("{} {} vec4 {};\n",
-                has_broken_decoration ? "FRAGMENT_OUTPUT_LOCATION(0)" :
-                                        "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0)",
-                use_framebuffer_fetch ? "FRAGMENT_INOUT" : "out",
-                use_shader_blend ? "real_ocol0" : "ocol0");
-
-      if (use_dual_source)
-      {
-        out.Write("{} out vec4 ocol1;\n", has_broken_decoration ?
-                                              "FRAGMENT_OUTPUT_LOCATION(1)" :
-                                              "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 1)");
-      }
+      out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n");
     }
 
     if (uid_data->per_pixel_depth)
@@ -1042,28 +702,11 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
 
     out.Write("void main()\n{{\n");
     out.Write("\tfloat4 rawpos = gl_FragCoord;\n");
-
-    if (use_framebuffer_fetch)
-    {
-      // Store off a copy of the initial framebuffer value.
-      //
-      // If FB_FETCH_VALUE isn't defined (i.e. no special keyword for fetching from the
-      // framebuffer), we read from real_ocol0 or ocol0, depending if shader blending is enabled.
-      out.Write("#ifdef FB_FETCH_VALUE\n"
-                "\tfloat4 initial_ocol0 = FB_FETCH_VALUE;\n"
-                "#else\n"
-                "\tfloat4 initial_ocol0 = {};\n"
-                "#endif\n",
-                use_shader_blend ? "real_ocol0" : "ocol0");
-    }
-
     if (use_shader_blend)
     {
-      // QComm's Adreno driver doesn't seem to like using the framebuffer_fetch value as an
-      // intermediate value with multiple reads & modifications, so we pull out the "real" output
-      // value above and use a temporary for calculations, then set the output value once at the
-      // end of the shader if we are using shader blending.
-      out.Write("\tfloat4 ocol0;\n"
+      // Store off a copy of the initial fb value for blending
+      out.Write("\tfloat4 initial_ocol0 = FB_FETCH_VALUE;\n"
+                "\tfloat4 ocol0;\n"
                 "\tfloat4 ocol1;\n");
     }
   }
@@ -1113,8 +756,6 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
       out.Write(",\n  in uint layer : SV_RenderTargetArrayIndex\n");
     out.Write("        ) {{\n");
   }
-  if (!stereo)
-    out.Write("\tint layer = 0;\n");
 
   out.Write("\tint4 c0 = " I_COLORS "[1], c1 = " I_COLORS "[2], c2 = " I_COLORS
             "[3], prev = " I_COLORS "[0];\n"
@@ -1172,7 +813,7 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
     {
       out.Write("\tint2 fixpoint_uv{} = int2(", i);
       out.Write("(tex{}.z == 0.0 ? tex{}.xy : tex{}.xy / tex{}.z)", i, i, i, i);
-      out.Write(" * float2(" I_TEXDIMS "[{}].zw * 128));\n", i);
+      out.Write(" * " I_TEXDIMS "[{}].zw);\n", i);
       // TODO: S24 overflows here?
     }
   }
@@ -1195,8 +836,8 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
       out.Write("\ttempcoord = fixpoint_uv{} >> " I_INDTEXSCALE "[{}].{};\n", texcoord, i / 2,
                 (i & 1) ? "zw" : "xy");
 
-      out.Write("\tint3 iindtex{0} = sampleTextureWrapper({1}u, tempcoord, layer).abg;\n", i,
-                texmap);
+      out.Write("\tint3 iindtex{} = ", i);
+      SampleTexture(out, "float2(tempcoord)", "abg", texmap, stereo, api_type);
     }
   }
 
@@ -1314,9 +955,6 @@ ShaderCode GeneratePixelShaderCode(APIType api_type, const ShaderHostConfig& hos
 
   WriteFog(out, uid_data);
 
-  if (use_shader_logic_op)
-    WriteLogicOp(out, uid_data);
-
   // Write the color and alpha values to the framebuffer
   // If using shader blend, we still use the separate alpha
   WriteColor(out, api_type, uid_data, use_dual_source || use_shader_blend);
@@ -1605,8 +1243,8 @@ static void WriteStage(ShaderCode& out, const pixel_shader_uid_data* uid_data, i
         '\0',
     };
 
-    out.Write("\ttextemp = sampleTextureWrapper({0}u, tevcoord.xy, layer).{1};\n",
-              stage.tevorders_texmap, texswap);
+    out.Write("\ttextemp = ");
+    SampleTexture(out, "float2(tevcoord.xy)", texswap, stage.tevorders_texmap, stereo, api_type);
   }
   else if (uid_data->genMode_numtexgens == 0)
   {
@@ -1789,6 +1427,24 @@ static void WriteTevRegular(ShaderCode& out, std::string_view components, TevBia
   out.Write("){}", tev_scale_table_right[scale]);
 }
 
+static void SampleTexture(ShaderCode& out, std::string_view texcoords, std::string_view texswap,
+                          int texmap, bool stereo, APIType api_type)
+{
+  out.SetConstantsUsed(C_TEXDIMS + texmap, C_TEXDIMS + texmap);
+
+  if (api_type == APIType::D3D)
+  {
+    out.Write("iround(255.0 * Tex[{}].Sample(samp[{}], float3({}.xy * " I_TEXDIMS
+              "[{}].xy, {}))).{};\n",
+              texmap, texmap, texcoords, texmap, stereo ? "layer" : "0.0", texswap);
+  }
+  else
+  {
+    out.Write("iround(255.0 * texture(samp[{}], float3({}.xy * " I_TEXDIMS "[{}].xy, {}))).{};\n",
+              texmap, texcoords, texmap, stereo ? "layer" : "0.0", texswap);
+  }
+}
+
 constexpr Common::EnumMap<const char*, CompareMode::Always> tev_alpha_funcs_table{
     "(false)",         // CompareMode::Never
     "(prev.a <  {})",  // CompareMode::Less
@@ -1933,34 +1589,6 @@ static void WriteFog(ShaderCode& out, const pixel_shader_uid_data* uid_data)
   out.Write("\tprev.rgb = (prev.rgb * (256 - ifog) + " I_FOGCOLOR ".rgb * ifog) >> 8;\n");
 }
 
-static void WriteLogicOp(ShaderCode& out, const pixel_shader_uid_data* uid_data)
-{
-  if (uid_data->logic_op_enable)
-  {
-    static constexpr std::array<const char*, 16> logic_op_mode{
-        "int4(0, 0, 0, 0)",          // CLEAR
-        "prev & fb_value",           // AND
-        "prev & ~fb_value",          // AND_REVERSE
-        "prev",                      // COPY
-        "~prev & fb_value",          // AND_INVERTED
-        "fb_value",                  // NOOP
-        "prev ^ fb_value",           // XOR
-        "prev | fb_value",           // OR
-        "~(prev | fb_value)",        // NOR
-        "~(prev ^ fb_value)",        // EQUIV
-        "~fb_value",                 // INVERT
-        "prev | ~fb_value",          // OR_REVERSE
-        "~prev",                     // COPY_INVERTED
-        "~prev | fb_value",          // OR_INVERTED
-        "~(prev & fb_value)",        // NAND
-        "int4(255, 255, 255, 255)",  // SET
-    };
-
-    out.Write("\tint4 fb_value = iround(initial_ocol0 * 255.0);\n");
-    out.Write("\tprev = {};\n", logic_op_mode[uid_data->logic_op_mode]);
-  }
-}
-
 static void WriteColor(ShaderCode& out, APIType api_type, const pixel_shader_uid_data* uid_data,
                        bool use_dual_source)
 {
diff --git a/Source/Core/VideoCommon/PixelShaderGen.h b/Source/Core/VideoCommon/PixelShaderGen.h
index 6a7a638..adf9960 100644
--- a/Source/Core/VideoCommon/PixelShaderGen.h
+++ b/Source/Core/VideoCommon/PixelShaderGen.h
@@ -59,8 +59,6 @@ struct pixel_shader_uid_data
   DstBlendFactor blend_dst_factor_alpha : 3;  // Only used with shader_framebuffer_fetch blend
   u32 blend_subtract : 1;                     // Only used with shader_framebuffer_fetch blend
   u32 blend_subtract_alpha : 1;               // Only used with shader_framebuffer_fetch blend
-  u32 logic_op_enable : 1;                    // Only used with shader_framebuffer_fetch logic ops
-  u32 logic_op_mode : 4;                      // Only used with shader_framebuffer_fetch logic ops
 
   u32 texMtxInfo_n_projection : 8;  // 8x1 bit
   u32 tevindref_bi0 : 3;
diff --git a/Source/Core/VideoCommon/PixelShaderManager.cpp b/Source/Core/VideoCommon/PixelShaderManager.cpp
index 675bcce..436db9d 100644
--- a/Source/Core/VideoCommon/PixelShaderManager.cpp
+++ b/Source/Core/VideoCommon/PixelShaderManager.cpp
@@ -273,22 +273,16 @@ void PixelShaderManager::SetDestAlphaChanged()
 
 void PixelShaderManager::SetTexDims(int texmapid, u32 width, u32 height)
 {
+  float rwidth = 1.0f / (width * 128.0f);
+  float rheight = 1.0f / (height * 128.0f);
+
   // TODO: move this check out to callee. There we could just call this function on texture changes
   // or better, use textureSize() in glsl
-  if (constants.texdims[texmapid][0] != width || constants.texdims[texmapid][1] != height)
-    dirty = true;
-
-  constants.texdims[texmapid][0] = width;
-  constants.texdims[texmapid][1] = height;
-}
-
-void PixelShaderManager::SetSamplerState(int texmapid, u32 tm0, u32 tm1)
-{
-  if (constants.pack2[texmapid][2] != tm0 || constants.pack2[texmapid][3] != tm1)
+  if (constants.texdims[texmapid][0] != rwidth || constants.texdims[texmapid][1] != rheight)
     dirty = true;
 
-  constants.pack2[texmapid][2] = tm0;
-  constants.pack2[texmapid][3] = tm1;
+  constants.texdims[texmapid][0] = rwidth;
+  constants.texdims[texmapid][1] = rheight;
 }
 
 void PixelShaderManager::SetZTextureBias()
@@ -388,8 +382,8 @@ void PixelShaderManager::SetZTextureOpChanged()
 void PixelShaderManager::SetTexCoordChanged(u8 texmapid)
 {
   TCoordInfo& tc = bpmem.texcoords[texmapid];
-  constants.texdims[texmapid][2] = tc.s.scale_minus_1 + 1;
-  constants.texdims[texmapid][3] = tc.t.scale_minus_1 + 1;
+  constants.texdims[texmapid][2] = (float)(tc.s.scale_minus_1 + 1) * 128.0f;
+  constants.texdims[texmapid][3] = (float)(tc.t.scale_minus_1 + 1) * 128.0f;
   dirty = true;
 }
 
@@ -510,16 +504,6 @@ void PixelShaderManager::SetBlendModeChanged()
     constants.blend_subtract_alpha = state.subtractAlpha;
     dirty = true;
   }
-  if (constants.logic_op_enable != state.logicopenable)
-  {
-    constants.logic_op_enable = state.logicopenable;
-    dirty = true;
-  }
-  if (constants.logic_op_mode != state.logicmode)
-  {
-    constants.logic_op_mode = state.logicmode;
-    dirty = true;
-  }
   s_bDestAlphaDirty = true;
 }
 
diff --git a/Source/Core/VideoCommon/PixelShaderManager.h b/Source/Core/VideoCommon/PixelShaderManager.h
index 6145049..4d13017 100644
--- a/Source/Core/VideoCommon/PixelShaderManager.h
+++ b/Source/Core/VideoCommon/PixelShaderManager.h
@@ -30,7 +30,6 @@ public:
   static void SetAlphaTestChanged();
   static void SetDestAlphaChanged();
   static void SetTexDims(int texmapid, u32 width, u32 height);
-  static void SetSamplerState(int texmapid, u32 tm0, u32 tm1);
   static void SetZTextureBias();
   static void SetViewportChanged();
   static void SetEfbScaleChanged(float scalex, float scaley);
diff --git a/Source/Core/VideoCommon/RenderState.cpp b/Source/Core/VideoCommon/RenderState.cpp
index 15559ae..291aa9c 100644
--- a/Source/Core/VideoCommon/RenderState.cpp
+++ b/Source/Core/VideoCommon/RenderState.cpp
@@ -2,10 +2,9 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoCommon/RenderState.h"
-
 #include <algorithm>
 #include <array>
-
+#include "VideoCommon/SamplerCommon.h"
 #include "VideoCommon/TextureConfig.h"
 
 void RasterizationState::Generate(const BPMemory& bp, PrimitiveType primitive_type)
@@ -18,6 +17,18 @@ void RasterizationState::Generate(const BPMemory& bp, PrimitiveType primitive_ty
     cullmode = CullMode::None;
 }
 
+RasterizationState& RasterizationState::operator=(const RasterizationState& rhs)
+{
+  hex = rhs.hex;
+  return *this;
+}
+
+FramebufferState& FramebufferState::operator=(const FramebufferState& rhs)
+{
+  hex = rhs.hex;
+  return *this;
+}
+
 void DepthState::Generate(const BPMemory& bp)
 {
   testenable = bp.zmode.testenable.Value();
@@ -25,6 +36,12 @@ void DepthState::Generate(const BPMemory& bp)
   func = bp.zmode.func.Value();
 }
 
+DepthState& DepthState::operator=(const DepthState& rhs)
+{
+  hex = rhs.hex;
+  return *this;
+}
+
 // If the framebuffer format has no alpha channel, it is assumed to
 // ONE on blending. As the backends may emulate this framebuffer
 // configuration with an alpha channel, we just drop all references
@@ -199,45 +216,42 @@ void BlendingState::ApproximateLogicOpWithBlending()
   dstfactor = approximations[u32(logicmode.Value())].dstfactor;
 }
 
+BlendingState& BlendingState::operator=(const BlendingState& rhs)
+{
+  hex = rhs.hex;
+  return *this;
+}
+
 void SamplerState::Generate(const BPMemory& bp, u32 index)
 {
-  auto tex = bp.tex.GetUnit(index);
-  const TexMode0& bp_tm0 = tex.texMode0;
-  const TexMode1& bp_tm1 = tex.texMode1;
+  const FourTexUnits& tex = bpmem.tex[index / 4];
+  const TexMode0& tm0 = tex.texMode0[index % 4];
+  const TexMode1& tm1 = tex.texMode1[index % 4];
 
   // GX can configure the mip filter to none. However, D3D and Vulkan can't express this in their
   // sampler states. Therefore, we set the min/max LOD to zero if this option is used.
-  tm0.min_filter = bp_tm0.min_filter;
-  tm0.mipmap_filter =
-      bp_tm0.mipmap_filter == MipMode::Linear ? FilterMode::Linear : FilterMode::Near;
-  tm0.mag_filter = bp_tm0.mag_filter;
+  min_filter = tm0.min_filter == FilterMode::Linear ? Filter::Linear : Filter::Point;
+  mipmap_filter = tm0.mipmap_filter == MipMode::Linear ? Filter::Linear : Filter::Point;
+  mag_filter = tm0.mag_filter == FilterMode::Linear ? Filter::Linear : Filter::Point;
 
   // If mipmaps are disabled, clamp min/max lod
-  if (bp_tm0.mipmap_filter == MipMode::None)
-  {
-    tm1.max_lod = 0;
-    tm1.min_lod = 0;
-    tm0.lod_bias = 0;
-  }
-  else
-  {
-    // NOTE: When comparing, max is checked first, then min; if max is less than min, max wins
-    tm1.max_lod = bp_tm1.max_lod.Value();
-    tm1.min_lod = std::min(tm1.max_lod.Value(), bp_tm1.min_lod.Value());
-    tm0.lod_bias = bp_tm0.lod_bias * (256 / 32);
-  }
+  max_lod = SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0) ? tm1.max_lod.Value() : 0;
+  min_lod = std::min(max_lod.Value(), static_cast<u64>(tm1.min_lod));
+  lod_bias = SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0) ? tm0.lod_bias * (256 / 32) : 0;
 
-  // Wrap modes
+  // Address modes
   // Hardware testing indicates that wrap_mode set to 3 behaves the same as clamp.
-  auto filter_invalid_wrap = [](WrapMode mode) {
-    return (mode <= WrapMode::Mirror) ? mode : WrapMode::Clamp;
-  };
-  tm0.wrap_u = filter_invalid_wrap(bp_tm0.wrap_s);
-  tm0.wrap_v = filter_invalid_wrap(bp_tm0.wrap_t);
+  static constexpr std::array<AddressMode, 4> address_modes = {
+      {AddressMode::Clamp, AddressMode::Repeat, AddressMode::MirroredRepeat, AddressMode::Clamp}};
+  wrap_u = address_modes[u32(tm0.wrap_s.Value())];
+  wrap_v = address_modes[u32(tm0.wrap_t.Value())];
+  anisotropic_filtering = 0;
+}
 
-  tm0.diag_lod = bp_tm0.diag_lod;
-  tm0.anisotropic_filtering = false;  // TODO: Respect BP anisotropic filtering mode
-  tm0.lod_clamp = bp_tm0.lod_clamp;   // TODO: What does this do?
+SamplerState& SamplerState::operator=(const SamplerState& rhs)
+{
+  hex = rhs.hex;
+  return *this;
 }
 
 namespace RenderState
@@ -330,42 +344,37 @@ BlendingState GetNoColorWriteBlendState()
 SamplerState GetInvalidSamplerState()
 {
   SamplerState state;
-  state.tm0.hex = 0xFFFFFFFF;
-  state.tm1.hex = 0xFFFFFFFF;
+  state.hex = UINT64_C(0xFFFFFFFFFFFFFFFF);
   return state;
 }
 
 SamplerState GetPointSamplerState()
 {
   SamplerState state = {};
-  state.tm0.min_filter = FilterMode::Near;
-  state.tm0.mag_filter = FilterMode::Near;
-  state.tm0.mipmap_filter = FilterMode::Near;
-  state.tm0.wrap_u = WrapMode::Clamp;
-  state.tm0.wrap_v = WrapMode::Clamp;
-  state.tm1.min_lod = 0;
-  state.tm1.max_lod = 255;
-  state.tm0.lod_bias = 0;
-  state.tm0.anisotropic_filtering = false;
-  state.tm0.diag_lod = LODType::Edge;
-  state.tm0.lod_clamp = false;
+  state.min_filter = SamplerState::Filter::Point;
+  state.mag_filter = SamplerState::Filter::Point;
+  state.mipmap_filter = SamplerState::Filter::Point;
+  state.wrap_u = SamplerState::AddressMode::Clamp;
+  state.wrap_v = SamplerState::AddressMode::Clamp;
+  state.min_lod = 0;
+  state.max_lod = 255;
+  state.lod_bias = 0;
+  state.anisotropic_filtering = false;
   return state;
 }
 
 SamplerState GetLinearSamplerState()
 {
   SamplerState state = {};
-  state.tm0.min_filter = FilterMode::Linear;
-  state.tm0.mag_filter = FilterMode::Linear;
-  state.tm0.mipmap_filter = FilterMode::Linear;
-  state.tm0.wrap_u = WrapMode::Clamp;
-  state.tm0.wrap_v = WrapMode::Clamp;
-  state.tm1.min_lod = 0;
-  state.tm1.max_lod = 255;
-  state.tm0.lod_bias = 0;
-  state.tm0.anisotropic_filtering = false;
-  state.tm0.diag_lod = LODType::Edge;
-  state.tm0.lod_clamp = false;
+  state.min_filter = SamplerState::Filter::Linear;
+  state.mag_filter = SamplerState::Filter::Linear;
+  state.mipmap_filter = SamplerState::Filter::Linear;
+  state.wrap_u = SamplerState::AddressMode::Clamp;
+  state.wrap_v = SamplerState::AddressMode::Clamp;
+  state.min_lod = 0;
+  state.max_lod = 255;
+  state.lod_bias = 0;
+  state.anisotropic_filtering = false;
   return state;
 }
 
diff --git a/Source/Core/VideoCommon/RenderState.h b/Source/Core/VideoCommon/RenderState.h
index 6fca2ef..192b0c8 100644
--- a/Source/Core/VideoCommon/RenderState.h
+++ b/Source/Core/VideoCommon/RenderState.h
@@ -22,24 +22,11 @@ union RasterizationState
 {
   void Generate(const BPMemory& bp, PrimitiveType primitive_type);
 
-  RasterizationState() = default;
-  RasterizationState(const RasterizationState&) = default;
-  RasterizationState& operator=(const RasterizationState& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
-  RasterizationState(RasterizationState&&) = default;
-  RasterizationState& operator=(RasterizationState&& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
+  RasterizationState& operator=(const RasterizationState& rhs);
 
   bool operator==(const RasterizationState& rhs) const { return hex == rhs.hex; }
-  bool operator!=(const RasterizationState& rhs) const { return !operator==(rhs); }
+  bool operator!=(const RasterizationState& rhs) const { return hex != rhs.hex; }
   bool operator<(const RasterizationState& rhs) const { return hex < rhs.hex; }
-
   BitField<0, 2, CullMode> cullmode;
   BitField<3, 2, PrimitiveType> primitive;
 
@@ -48,28 +35,15 @@ union RasterizationState
 
 union FramebufferState
 {
-  FramebufferState() = default;
-  FramebufferState(const FramebufferState&) = default;
-  FramebufferState& operator=(const FramebufferState& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
-  FramebufferState(FramebufferState&&) = default;
-  FramebufferState& operator=(FramebufferState&& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
-
-  bool operator==(const FramebufferState& rhs) const { return hex == rhs.hex; }
-  bool operator!=(const FramebufferState& rhs) const { return !operator==(rhs); }
-
   BitField<0, 8, AbstractTextureFormat> color_texture_format;
   BitField<8, 8, AbstractTextureFormat> depth_texture_format;
   BitField<16, 8, u32> samples;
   BitField<24, 1, u32> per_sample_shading;
 
+  bool operator==(const FramebufferState& rhs) const { return hex == rhs.hex; }
+  bool operator!=(const FramebufferState& rhs) const { return hex != rhs.hex; }
+  FramebufferState& operator=(const FramebufferState& rhs);
+
   u32 hex;
 };
 
@@ -77,24 +51,11 @@ union DepthState
 {
   void Generate(const BPMemory& bp);
 
-  DepthState() = default;
-  DepthState(const DepthState&) = default;
-  DepthState& operator=(const DepthState& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
-  DepthState(DepthState&&) = default;
-  DepthState& operator=(DepthState&& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
+  DepthState& operator=(const DepthState& rhs);
 
   bool operator==(const DepthState& rhs) const { return hex == rhs.hex; }
-  bool operator!=(const DepthState& rhs) const { return !operator==(rhs); }
+  bool operator!=(const DepthState& rhs) const { return hex != rhs.hex; }
   bool operator<(const DepthState& rhs) const { return hex < rhs.hex; }
-
   BitField<0, 1, u32> testenable;
   BitField<1, 1, u32> updateenable;
   BitField<2, 3, CompareMode> func;
@@ -110,24 +71,11 @@ union BlendingState
   // Will not be bit-correct, and in some cases not even remotely in the same ballpark.
   void ApproximateLogicOpWithBlending();
 
-  BlendingState() = default;
-  BlendingState(const BlendingState&) = default;
-  BlendingState& operator=(const BlendingState& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
-  BlendingState(BlendingState&&) = default;
-  BlendingState& operator=(BlendingState&& rhs)
-  {
-    hex = rhs.hex;
-    return *this;
-  }
+  BlendingState& operator=(const BlendingState& rhs);
 
   bool operator==(const BlendingState& rhs) const { return hex == rhs.hex; }
-  bool operator!=(const BlendingState& rhs) const { return !operator==(rhs); }
+  bool operator!=(const BlendingState& rhs) const { return hex != rhs.hex; }
   bool operator<(const BlendingState& rhs) const { return hex < rhs.hex; }
-
   BitField<0, 1, u32> blendenable;
   BitField<1, 1, u32> logicopenable;
   BitField<2, 1, u32> dstalpha;
@@ -145,73 +93,42 @@ union BlendingState
   u32 hex;
 };
 
-struct SamplerState
+union SamplerState
 {
-  void Generate(const BPMemory& bp, u32 index);
-
-  SamplerState() = default;
-  SamplerState(const SamplerState&) = default;
-  SamplerState& operator=(const SamplerState& rhs)
-  {
-    tm0.hex = rhs.tm0.hex;
-    tm1.hex = rhs.tm1.hex;
-    return *this;
-  }
-  SamplerState(SamplerState&&) = default;
-  SamplerState& operator=(SamplerState&& rhs)
-  {
-    tm0.hex = rhs.tm0.hex;
-    tm1.hex = rhs.tm1.hex;
-    return *this;
-  }
-
-  bool operator==(const SamplerState& rhs) const { return Hex() == rhs.Hex(); }
-  bool operator!=(const SamplerState& rhs) const { return !operator==(rhs); }
-  bool operator<(const SamplerState& rhs) const { return Hex() < rhs.Hex(); }
+  using StorageType = u64;
 
-  constexpr u64 Hex() const { return tm0.hex | (static_cast<u64>(tm1.hex) << 32); }
-
-  // Based on BPMemory TexMode0/TexMode1, but with slightly higher precision and some
-  // simplifications
-  union TM0
+  enum class Filter : StorageType
   {
-    // BP's mipmap_filter can be None, but that is represented here by setting min_lod and max_lod
-    // to 0
-    BitField<0, 1, FilterMode> min_filter;
-    BitField<1, 1, FilterMode> mag_filter;
-    BitField<2, 1, FilterMode> mipmap_filter;
-    // Guaranteed to be valid values (i.e. not 3)
-    BitField<3, 2, WrapMode> wrap_u;
-    BitField<5, 2, WrapMode> wrap_v;
-    BitField<7, 1, LODType> diag_lod;
-    BitField<8, 16, s32> lod_bias;         // multiplied by 256, higher precision than normal
-    BitField<24, 1, bool, u32> lod_clamp;  // TODO: This isn't currently implemented
-    BitField<25, 1, bool, u32> anisotropic_filtering;  // TODO: This doesn't use the BP one yet
-    u32 hex;
+    Point,
+    Linear
   };
-  union TM1
+
+  enum class AddressMode : StorageType
   {
-    // Min is guaranteed to be less than or equal to max
-    BitField<0, 8, u32> min_lod;  // multiplied by 16
-    BitField<8, 8, u32> max_lod;  // multiplied by 16
-    u32 hex;
+    Clamp,
+    Repeat,
+    MirroredRepeat
   };
 
-  TM0 tm0;
-  TM1 tm1;
-};
+  void Generate(const BPMemory& bp, u32 index);
 
-namespace std
-{
-template <>
-struct hash<SamplerState>
-{
-  std::size_t operator()(SamplerState const& state) const noexcept
-  {
-    return std::hash<u64>{}(state.Hex());
-  }
+  SamplerState& operator=(const SamplerState& rhs);
+
+  bool operator==(const SamplerState& rhs) const { return hex == rhs.hex; }
+  bool operator!=(const SamplerState& rhs) const { return hex != rhs.hex; }
+  bool operator<(const SamplerState& rhs) const { return hex < rhs.hex; }
+  BitField<0, 1, Filter> min_filter;
+  BitField<1, 1, Filter> mag_filter;
+  BitField<2, 1, Filter> mipmap_filter;
+  BitField<3, 2, AddressMode> wrap_u;
+  BitField<5, 2, AddressMode> wrap_v;
+  BitField<7, 16, s64> lod_bias;  // multiplied by 256
+  BitField<23, 8, u64> min_lod;   // multiplied by 16
+  BitField<31, 8, u64> max_lod;   // multiplied by 16
+  BitField<39, 1, u64> anisotropic_filtering;
+
+  StorageType hex;
 };
-}  // namespace std
 
 namespace RenderState
 {
diff --git a/Source/Core/VideoCommon/SamplerCommon.h b/Source/Core/VideoCommon/SamplerCommon.h
new file mode 100644
index 0000000..2b09393
--- /dev/null
+++ b/Source/Core/VideoCommon/SamplerCommon.h
@@ -0,0 +1,27 @@
+// Copyright 2016 Dolphin Emulator Project
+// SPDX-License-Identifier: GPL-2.0-or-later
+
+#pragma once
+
+namespace SamplerCommon
+{
+// Helper for checking if a BPMemory TexMode0 register is set to Point
+// Filtering modes. This is used to decide whether Anisotropic enhancements
+// are (mostly) safe in the VideoBackends.
+// If both the minification and magnification filters are set to POINT modes
+// then applying anisotropic filtering is equivalent to forced filtering. Point
+// mode textures are usually some sort of 2D UI billboard which will end up
+// misaligned from the correct pixels when filtered anisotropically.
+template <class T>
+constexpr bool IsBpTexMode0PointFiltering(const T& tm0)
+{
+  return tm0.min_filter == FilterMode::Near && tm0.mag_filter == FilterMode::Near;
+}
+
+// Check if the minification filter has mipmap based filtering modes enabled.
+template <class T>
+constexpr bool AreBpTexMode0MipmapsEnabled(const T& tm0)
+{
+  return tm0.mipmap_filter != MipMode::None;
+}
+}  // namespace SamplerCommon
diff --git a/Source/Core/VideoCommon/ShaderCache.cpp b/Source/Core/VideoCommon/ShaderCache.cpp
index eada4c9..494db47 100644
--- a/Source/Core/VideoCommon/ShaderCache.cpp
+++ b/Source/Core/VideoCommon/ShaderCache.cpp
@@ -588,9 +588,7 @@ AbstractPipelineConfig ShaderCache::GetGXPipelineConfig(
   config.blending_state = blending_state;
   config.framebuffer_state = g_framebuffer_manager->GetEFBFramebufferState();
 
-  // We can use framebuffer fetch to emulate logic ops in the fragment shader.
-  if (config.blending_state.logicopenable && !g_ActiveConfig.backend_info.bSupportsLogicOp &&
-      !g_ActiveConfig.backend_info.bSupportsFramebufferFetch)
+  if (config.blending_state.logicopenable && !g_ActiveConfig.backend_info.bSupportsLogicOp)
   {
     WARN_LOG_FMT(VIDEO,
                  "Approximating logic op with blending, this will produce incorrect rendering.");
diff --git a/Source/Core/VideoCommon/ShaderGenCommon.cpp b/Source/Core/VideoCommon/ShaderGenCommon.cpp
index 0a965e6..c5cd3ef 100644
--- a/Source/Core/VideoCommon/ShaderGenCommon.cpp
+++ b/Source/Core/VideoCommon/ShaderGenCommon.cpp
@@ -39,10 +39,6 @@ ShaderHostConfig ShaderHostConfig::GetCurrent()
   bits.backend_logic_op = g_ActiveConfig.backend_info.bSupportsLogicOp;
   bits.backend_palette_conversion = g_ActiveConfig.backend_info.bSupportsPaletteConversion;
   bits.enable_validation_layer = g_ActiveConfig.bEnableValidationLayer;
-  bits.manual_texture_sampling = !g_ActiveConfig.bFastTextureSampling;
-  bits.manual_texture_sampling_custom_texture_sizes =
-      g_ActiveConfig.ManualTextureSamplingWithHiResTextures();
-  bits.backend_sampler_lod_bias = g_ActiveConfig.backend_info.bSupportsLodBiasInSampler;
   return bits;
 }
 
@@ -109,30 +105,6 @@ void WriteIsNanHeader(ShaderCode& out, APIType api_type)
   }
 }
 
-void WriteBitfieldExtractHeader(ShaderCode& out, APIType api_type,
-                                const ShaderHostConfig& host_config)
-{
-  // ==============================================
-  //  BitfieldExtract for APIs which don't have it
-  // ==============================================
-  if (!host_config.backend_bitfield)
-  {
-    out.Write("uint bitfieldExtract(uint val, int off, int size) {{\n"
-              "  // This built-in function is only supported in OpenGL 4.0+ and ES 3.1+\n"
-              "  // Microsoft's HLSL compiler automatically optimises this to a bitfield extract "
-              "instruction.\n"
-              "  uint mask = uint((1 << size) - 1);\n"
-              "  return uint(val >> off) & mask;\n"
-              "}}\n\n");
-    out.Write("int bitfieldExtract(int val, int off, int size) {{\n"
-              "  // This built-in function is only supported in OpenGL 4.0+ and ES 3.1+\n"
-              "  // Microsoft's HLSL compiler automatically optimises this to a bitfield extract "
-              "instruction.\n"
-              "  return ((val << (32 - size - off)) >> (32 - size));\n"
-              "}}\n\n");
-  }
-}
-
 static void DefineOutputMember(ShaderCode& object, APIType api_type, std::string_view qualifier,
                                std::string_view type, std::string_view name, int var_index,
                                std::string_view semantic = {}, int semantic_index = -1)
diff --git a/Source/Core/VideoCommon/ShaderGenCommon.h b/Source/Core/VideoCommon/ShaderGenCommon.h
index edbd931..28688cc 100644
--- a/Source/Core/VideoCommon/ShaderGenCommon.h
+++ b/Source/Core/VideoCommon/ShaderGenCommon.h
@@ -15,7 +15,6 @@
 #include "Common/CommonTypes.h"
 #include "Common/EnumMap.h"
 #include "Common/StringUtil.h"
-#include "Common/TypeUtils.h"
 
 #include "VideoCommon/VideoCommon.h"
 
@@ -170,9 +169,6 @@ union ShaderHostConfig
   BitField<21, 1, bool, u32> backend_logic_op;
   BitField<22, 1, bool, u32> backend_palette_conversion;
   BitField<23, 1, bool, u32> enable_validation_layer;
-  BitField<24, 1, bool, u32> manual_texture_sampling;
-  BitField<25, 1, bool, u32> manual_texture_sampling_custom_texture_sizes;
-  BitField<26, 1, bool, u32> backend_sampler_lod_bias;
 
   static ShaderHostConfig GetCurrent();
 };
@@ -182,8 +178,6 @@ std::string GetDiskShaderCacheFileName(APIType api_type, const char* type, bool
                                        bool include_host_config, bool include_api = true);
 
 void WriteIsNanHeader(ShaderCode& out, APIType api_type);
-void WriteBitfieldExtractHeader(ShaderCode& out, APIType api_type,
-                                const ShaderHostConfig& host_config);
 
 void GenerateVSOutputMembers(ShaderCode& object, APIType api_type, u32 texgens,
                              const ShaderHostConfig& host_config, std::string_view qualifier);
@@ -202,16 +196,6 @@ void AssignVSOutputMembers(ShaderCode& object, std::string_view a, std::string_v
 const char* GetInterpolationQualifier(bool msaa, bool ssaa, bool in_glsl_interface_block = false,
                                       bool in = false);
 
-// bitfieldExtract generator for BitField types
-template <auto ptr_to_bitfield_member>
-std::string BitfieldExtract(std::string_view source)
-{
-  using BitFieldT = Common::MemberType<ptr_to_bitfield_member>;
-  return fmt::format("bitfieldExtract({}({}), {}, {})", BitFieldT::IsSigned() ? "int" : "uint",
-                     source, static_cast<u32>(BitFieldT::StartBit()),
-                     static_cast<u32>(BitFieldT::NumBits()));
-}
-
 template <auto last_member, typename = decltype(last_member)>
 void WriteSwitch(ShaderCode& out, APIType ApiType, std::string_view variable,
                  const Common::EnumMap<std::string_view, last_member>& values, int indent,
diff --git a/Source/Core/VideoCommon/TMEM.cpp b/Source/Core/VideoCommon/TMEM.cpp
deleted file mode 100644
index 8b5404a..0000000
--- a/Source/Core/VideoCommon/TMEM.cpp
+++ /dev/null
@@ -1,290 +0,0 @@
-// Copyright 2019 Dolphin Emulator Project
-// Licensed under GPLv2+
-// Refer to the license.txt file included.
-
-#include "VideoCommon/TMEM.h"
-
-#include <array>
-
-#include "Common/ChunkFile.h"
-#include "VideoCommon/BPMemory.h"
-
-////////////////////////////////////////////////////////////////////////////////////////////////////
-//
-// TMEM emulation tracks which textures should be cached in TMEM on a real console.
-// There are two good reasons to do this:
-//
-// 1. Some games deliberately avoid invalidating a texture, overwrite it with an EFB copy,
-//    and then expect the original texture to still be found in TMEM for another draw call.
-//    Spyro: A Hero's Tail is known for using such overwritten textures.
-//    However, other games like:
-//      * Sonic Riders
-//      * Metal Arms: Glitch in the System
-//      * Godzilla: Destroy All Monsters Melee
-//      * NHL Slapshot
-//      * Tak and the Power of Juju
-//      * Night at the Museum: Battle of the Smithsonian
-//      * 428: Fsa Sareta Shibuya de
-//    are known to (accidentally or deliberately) avoid invalidating and then expect the pattern
-//    of the draw and the fact that the whole texture doesn't fit in TMEM to self-invalidate the
-//    texture. These are usually full-screen efb copies.
-//    So we must track the size of the textures as an heuristic to see if they will self-invalidate
-//    or not.
-//
-// 2. It actually improves Dolphin's performance in safer texture hashing modes, by reducing the
-//    amount of times a texture needs to be hashed when reused in subsequent draws.
-//
-// As a side-effect, TMEM emulation also tracks if the texture unit configuration has changed at
-// all, which Dolphin's TextureCache takes advantage of.
-//
-////////////////////////////////////////////////////////////////////////////////////////////////////
-//
-// Checking if a texture fits in TMEM or not is complicated by the fact that Flipper's TMEM is quite
-// configurable.
-// Each of the eight texture units has two banks (even and odd) that can be pointed at any offset
-// and set to any size. It is completely valid to have overlapping banks, and performance can be
-// improved by overlapping the caches of texture units that are drawing the same textures.
-//
-// For trilinear textures, the even/odd banks contain the even/odd LODs of the texture. TMEM has two
-// banks of 512KB each, covering the upper and lower halves of TMEM's address space. The two banks
-// be accessed simultaneously, allowing a trilinear texture sample to be completed at the same cost
-// as a bilinear sample, assuming the even and odd banks are mapped onto different banks.
-//
-// 32bit textures are actually stored as two 16bit textures in separate banks, allowing a bilinear
-// sample of a 32bit texture at the same cost as a 16bit bilinear/trilinear sample. A trilinear
-// sample of a 32bit texture costs more.
-//
-// TODO: I'm not sure if it's valid for a texture unit's even and odd banks to overlap. There might
-//       actually be a hard requirement for even and odd banks to live in different banks of TMEM.
-//
-// Note: This is still very much a heuristic.
-//       Actually knowing if a texture is partially or fully cached within TMEM would require
-//       extensive software rasterization, or sampler feedback from a hardware backend.
-//
-////////////////////////////////////////////////////////////////////////////////////////////////////
-
-namespace TMEM
-{
-struct TextureUnitState
-{
-  enum class State
-  {
-    // Cache is invalid. Configuration has changed
-    INVALID,
-
-    // Valid, but not cached due to either being too big, or overlapping with another texture unit
-    VALID,
-
-    // Texture unit has cached all of the previous draw
-    CACHED,
-  };
-
-  struct BankConfig
-  {
-    u32 width = 0;
-    u32 height = 0;
-    u32 base = 0;
-    u32 size = 0;
-    bool Overlaps(const BankConfig& other) const;
-  };
-
-  BankConfig even = {};
-  BankConfig odd = {};
-  State state = State::INVALID;
-
-  bool Overlaps(const TextureUnitState& other) const;
-};
-
-static u32 CalculateUnitSize(TextureUnitState::BankConfig bank_config);
-
-static std::array<TextureUnitState, 8> s_unit;
-
-// On TMEM configuration changed:
-// 1. invalidate stage.
-
-void ConfigurationChanged(TexUnitAddress bp_addr, u32 config)
-{
-  TextureUnitState& unit_state = s_unit[bp_addr.GetUnitID()];
-
-  // If anything has changed, we can't assume existing state is still valid.
-  unit_state.state = TextureUnitState::State::INVALID;
-
-  // Note: BPStructs has already filtered out NOP changes before calling us
-  switch (bp_addr.Reg)
-  {
-  case TexUnitAddress::Register::SETIMAGE1:
-  {
-    // Image Type and Even bank's Cache Height, Cache Width, TMEM Offset
-    TexImage1 even = {.hex = config};
-    unit_state.even = {even.cache_width, even.cache_height, even.tmem_even << 5, 0};
-    break;
-  }
-  case TexUnitAddress::Register::SETIMAGE2:
-  {
-    // Odd bank's Cache Height, Cache Width, TMEM Offset
-    TexImage2 odd = {.hex = config};
-    unit_state.odd = {odd.cache_width, odd.cache_height, odd.tmem_odd << 5, 0};
-    break;
-  }
-  default:
-    // Something else has changed
-    return;
-  }
-}
-
-void InvalidateAll()
-{
-  for (auto& unit : s_unit)
-  {
-    unit.state = TextureUnitState::State::INVALID;
-  }
-}
-
-// On invalidate cache:
-// 1. invalidate all texture units.
-
-void Invalidate([[maybe_unused]] u32 param)
-{
-  // The exact arguments of Invalidate commands is currently unknown.
-  // It appears to contain the TMEM address and a size.
-
-  // For simplicity, we will just invalidate everything
-  InvalidateAll();
-}
-
-// On bind:
-// 1. use mipmapping/32bit status to calculate final sizes
-// 2. if texture size is small enough to fit in region mark as cached.
-//    otherwise, mark as valid
-
-void Bind(u32 unit, int width, int height, bool is_mipmapped, bool is_32_bit)
-{
-  TextureUnitState& unit_state = s_unit[unit];
-
-  // All textures use the even bank.
-  // It holds the level 0 mipmap (and other even mipmap LODs, if mipmapping is enabled)
-  unit_state.even.size = CalculateUnitSize(unit_state.even);
-
-  bool fits = (width * height * 32U) <= unit_state.even.size;
-
-  if (is_mipmapped || is_32_bit)
-  {
-    // And the odd bank is enabled when either mipmapping is enabled or the texture is 32 bit
-    // It holds the Alpha and Red channels of 32 bit textures or the odd layers of a mipmapped
-    // texture
-    unit_state.odd.size = CalculateUnitSize(unit_state.odd);
-
-    fits = fits && (width * height * 32U) <= unit_state.odd.size;
-  }
-  else
-  {
-    unit_state.odd.size = 0;
-  }
-
-  if (is_mipmapped)
-  {
-    // TODO: This is what games appear to expect from hardware. But seems odd, as it doesn't line up
-    //       with how much extra memory is required for mipmapping, just 33% more.
-    //       Hardware testing is required to see exactly what gets used.
-
-    // When mipmapping is enabled, the even bank is doubled in size
-    // The extended region holds the remaining even mipmap layers
-    unit_state.even.size *= 2;
-
-    if (is_32_bit)
-    {
-      // When a 32bit texture is mipmapped, the odd bank is also doubled in size
-      unit_state.odd.size *= 2;
-    }
-  }
-
-  unit_state.state = fits ? TextureUnitState::State::CACHED : TextureUnitState::State::VALID;
-}
-
-static u32 CalculateUnitSize(TextureUnitState::BankConfig bank_config)
-{
-  u32 width = bank_config.width;
-  u32 height = bank_config.height;
-
-  // These are the only cache sizes supported by the sdk
-  if (width == height)
-  {
-    switch (width)
-    {
-    case 3:  // 32KB
-      return 32 * 1024;
-    case 4:  // 128KB
-      return 128 * 1024;
-    case 5:  // 512KB
-      return 512 * 1024;
-    default:
-      break;
-    }
-  }
-
-  // However, the registers allow a much larger amount of configurablity.
-  // Maybe other sizes are broken?
-  // Until hardware tests are done, this is a guess at the size algorithm
-
-  return 512 * (1 << width) * (1 << height);
-}
-
-bool TextureUnitState::BankConfig::Overlaps(const BankConfig& other) const
-{
-  if (size == 0 || other.size == 0)
-    return false;
-  return (base <= other.base && (base + size) > other.base) ||
-         (other.base <= base && (other.base + other.size) > base);
-}
-
-bool TextureUnitState::Overlaps(const TextureUnitState& other) const
-{
-  if (state == TextureUnitState::State::INVALID || other.state == TextureUnitState::State::INVALID)
-    return false;
-  return even.Overlaps(other.even) || even.Overlaps(other.odd) || odd.Overlaps(other.even) ||
-         odd.Overlaps(other.odd);
-}
-
-// Scans though active texture units checks for overlaps.
-void FinalizeBinds(BitSet32 used_textures)
-{
-  for (u32 i : used_textures)
-  {
-    if (s_unit[i].even.Overlaps(s_unit[i].odd))
-    {  // Self-overlap
-      s_unit[i].state = TextureUnitState::State::VALID;
-    }
-    for (size_t j = 0; j < s_unit.size(); j++)
-    {
-      if (j != i && s_unit[i].Overlaps(s_unit[j]))
-      {
-        // There is an overlap, downgrade both from CACHED
-        // (for there to be an overlap, both must have started as valid or cached)
-        s_unit[i].state = TextureUnitState::State::VALID;
-        s_unit[j].state = TextureUnitState::State::VALID;
-      }
-    }
-  }
-}
-
-bool IsCached(u32 unit)
-{
-  return s_unit[unit].state == TextureUnitState::State::CACHED;
-}
-
-bool IsValid(u32 unit)
-{
-  return s_unit[unit].state != TextureUnitState::State::INVALID;
-}
-
-void Init()
-{
-  s_unit.fill({});
-}
-
-void DoState(PointerWrap& p)
-{
-  p.DoArray(s_unit);
-}
-
-}  // namespace TMEM
diff --git a/Source/Core/VideoCommon/TMEM.h b/Source/Core/VideoCommon/TMEM.h
deleted file mode 100644
index 6a1eff4..0000000
--- a/Source/Core/VideoCommon/TMEM.h
+++ /dev/null
@@ -1,26 +0,0 @@
-// Copyright 2019 Dolphin Emulator Project
-// Licensed under GPLv2+
-// Refer to the license.txt file included.
-
-#pragma once
-
-#include "Common/BitSet.h"
-#include "Common/ChunkFile.h"
-#include "Common/CommonTypes.h"
-
-#include "VideoCommon/BPMemory.h"
-
-namespace TMEM
-{
-void InvalidateAll();
-void Invalidate(u32 param);
-void ConfigurationChanged(TexUnitAddress bp_addr, u32 config);
-void Bind(u32 unit, int num_blocks_width, int num_blocks_height, bool is_mipmapped, bool is_32_bit);
-void FinalizeBinds(BitSet32 used_textures);
-bool IsCached(u32 unit);
-bool IsValid(u32 unit);
-
-void Init();
-void DoState(PointerWrap& p);
-
-}  // namespace TMEM
diff --git a/Source/Core/VideoCommon/TextureCacheBase.cpp b/Source/Core/VideoCommon/TextureCacheBase.cpp
index efe6a38..cef3168 100644
--- a/Source/Core/VideoCommon/TextureCacheBase.cpp
+++ b/Source/Core/VideoCommon/TextureCacheBase.cpp
@@ -40,9 +40,9 @@
 #include "VideoCommon/OpcodeDecoding.h"
 #include "VideoCommon/PixelShaderManager.h"
 #include "VideoCommon/RenderBase.h"
+#include "VideoCommon/SamplerCommon.h"
 #include "VideoCommon/ShaderCache.h"
 #include "VideoCommon/Statistics.h"
-#include "VideoCommon/TMEM.h"
 #include "VideoCommon/TextureConversionShader.h"
 #include "VideoCommon/TextureConverterShaderGen.h"
 #include "VideoCommon/TextureDecoder.h"
@@ -57,6 +57,8 @@ static const int TEXTURE_POOL_KILL_THRESHOLD = 3;
 
 std::unique_ptr<TextureCacheBase> g_texture_cache;
 
+std::bitset<8> TextureCacheBase::valid_bind_points;
+
 TextureCacheBase::TCacheEntry::TCacheEntry(std::unique_ptr<AbstractTexture> tex,
                                            std::unique_ptr<AbstractFramebuffer> fb)
     : texture(std::move(tex)), framebuffer(std::move(fb))
@@ -93,7 +95,7 @@ TextureCacheBase::TextureCacheBase()
 
   Common::SetHash64Function();
 
-  TMEM::InvalidateAll();
+  InvalidateAllBindPoints();
 }
 
 TextureCacheBase::~TextureCacheBase()
@@ -121,7 +123,7 @@ bool TextureCacheBase::Initialize()
 void TextureCacheBase::Invalidate()
 {
   FlushEFBCopies();
-  TMEM::InvalidateAll();
+  InvalidateAllBindPoints();
 
   bound_textures.fill(nullptr);
   for (auto& tex : textures_by_address)
@@ -258,7 +260,7 @@ void TextureCacheBase::SetBackupConfig(const VideoConfig& config)
 }
 
 TextureCacheBase::TCacheEntry*
-TextureCacheBase::ApplyPaletteToEntry(TCacheEntry* entry, const u8* palette, TLUTFormat tlutfmt)
+TextureCacheBase::ApplyPaletteToEntry(TCacheEntry* entry, u8* palette, TLUTFormat tlutfmt)
 {
   DEBUG_ASSERT(g_ActiveConfig.backend_info.bSupportsPaletteConversion);
 
@@ -756,7 +758,7 @@ void TextureCacheBase::TCacheEntry::DoState(PointerWrap& p)
 }
 
 TextureCacheBase::TCacheEntry*
-TextureCacheBase::DoPartialTextureUpdates(TCacheEntry* entry_to_update, const u8* palette,
+TextureCacheBase::DoPartialTextureUpdates(TCacheEntry* entry_to_update, u8* palette,
                                           TLUTFormat tlutfmt)
 {
   // If the flag may_have_overlapping_textures is cleared, there are no overlapping EFB copies,
@@ -965,22 +967,16 @@ void TextureCacheBase::DumpTexture(TCacheEntry* entry, std::string basename, uns
   entry->texture->Save(filename, level);
 }
 
-// Helper for checking if a BPMemory TexMode0 register is set to Point
-// Filtering modes. This is used to decide whether Anisotropic enhancements
-// are (mostly) safe in the VideoBackends.
-// If both the minification and magnification filters are set to POINT modes
-// then applying anisotropic filtering is equivalent to forced filtering. Point
-// mode textures are usually some sort of 2D UI billboard which will end up
-// misaligned from the correct pixels when filtered anisotropically.
-static bool IsAnisostropicEnhancementSafe(const TexMode0& tm0)
+static u32 CalculateLevelSize(u32 level_0_size, u32 level)
 {
-  return !(tm0.min_filter == FilterMode::Near && tm0.mag_filter == FilterMode::Near);
+  return std::max(level_0_size >> level, 1u);
 }
 
 static void SetSamplerState(u32 index, float custom_tex_scale, bool custom_tex,
                             bool has_arbitrary_mips)
 {
-  const TexMode0& tm0 = bpmem.tex.GetUnit(index).texMode0;
+  const FourTexUnits& tex = bpmem.tex[index / 4];
+  const TexMode0& tm0 = tex.texMode0[index % 4];
 
   SamplerState state = {};
   state.Generate(bpmem, index);
@@ -988,18 +984,19 @@ static void SetSamplerState(u32 index, float custom_tex_scale, bool custom_tex,
   // Force texture filtering config option.
   if (g_ActiveConfig.bForceFiltering)
   {
-    state.tm0.min_filter = FilterMode::Linear;
-    state.tm0.mag_filter = FilterMode::Linear;
-    state.tm0.mipmap_filter =
-        tm0.mipmap_filter != MipMode::None ? FilterMode::Linear : FilterMode::Near;
+    state.min_filter = SamplerState::Filter::Linear;
+    state.mag_filter = SamplerState::Filter::Linear;
+    state.mipmap_filter = SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0) ?
+                              SamplerState::Filter::Linear :
+                              SamplerState::Filter::Point;
   }
 
   // Custom textures may have a greater number of mips
   if (custom_tex)
-    state.tm1.max_lod = 255;
+    state.max_lod = 255;
 
   // Anisotropic filtering option.
-  if (g_ActiveConfig.iMaxAnisotropy != 0 && IsAnisostropicEnhancementSafe(tm0))
+  if (g_ActiveConfig.iMaxAnisotropy != 0 && !SamplerCommon::IsBpTexMode0PointFiltering(tm0))
   {
     // https://www.opengl.org/registry/specs/EXT/texture_filter_anisotropic.txt
     // For predictable results on all hardware/drivers, only use one of:
@@ -1008,40 +1005,39 @@ static void SetSamplerState(u32 index, float custom_tex_scale, bool custom_tex,
     // Letting the game set other combinations will have varying arbitrary results;
     // possibly being interpreted as equal to bilinear/trilinear, implicitly
     // disabling anisotropy, or changing the anisotropic algorithm employed.
-    state.tm0.min_filter = FilterMode::Linear;
-    state.tm0.mag_filter = FilterMode::Linear;
-    if (tm0.mipmap_filter != MipMode::None)
-      state.tm0.mipmap_filter = FilterMode::Linear;
-    state.tm0.anisotropic_filtering = true;
+    state.min_filter = SamplerState::Filter::Linear;
+    state.mag_filter = SamplerState::Filter::Linear;
+    if (SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0))
+      state.mipmap_filter = SamplerState::Filter::Linear;
+    state.anisotropic_filtering = 1;
   }
   else
   {
-    state.tm0.anisotropic_filtering = false;
+    state.anisotropic_filtering = 0;
   }
 
-  if (has_arbitrary_mips && tm0.mipmap_filter != MipMode::None)
+  if (has_arbitrary_mips && SamplerCommon::AreBpTexMode0MipmapsEnabled(tm0))
   {
     // Apply a secondary bias calculated from the IR scale to pull inwards mipmaps
     // that have arbitrary contents, eg. are used for fog effects where the
     // distance they kick in at is important to preserve at any resolution.
     // Correct this with the upscaling factor of custom textures.
-    s32 lod_offset = std::log2(g_renderer->GetEFBScale() / custom_tex_scale) * 256.f;
-    state.tm0.lod_bias = std::clamp<s32>(state.tm0.lod_bias + lod_offset, -32768, 32767);
+    s64 lod_offset = std::log2(g_renderer->GetEFBScale() / custom_tex_scale) * 256.f;
+    state.lod_bias = std::clamp<s64>(state.lod_bias + lod_offset, -32768, 32767);
 
     // Anisotropic also pushes mips farther away so it cannot be used either
-    state.tm0.anisotropic_filtering = false;
+    state.anisotropic_filtering = 0;
   }
 
   g_renderer->SetSamplerState(index, state);
-  PixelShaderManager::SetSamplerState(index, state.tm0.hex, state.tm1.hex);
 }
 
-void TextureCacheBase::BindTextures(BitSet32 used_textures)
+void TextureCacheBase::BindTextures()
 {
   for (u32 i = 0; i < bound_textures.size(); i++)
   {
     const TCacheEntry* tentry = bound_textures[i];
-    if (used_textures[i] && tentry)
+    if (IsValidBindPoint(i) && tentry)
     {
       g_renderer->SetTexture(i, tentry->texture.get());
       PixelShaderManager::SetTexDims(i, tentry->native_width, tentry->native_height);
@@ -1050,8 +1046,6 @@ void TextureCacheBase::BindTextures(BitSet32 used_textures)
       SetSamplerState(i, custom_tex_scale, tentry->is_custom_tex, tentry->has_arbitrary_mips);
     }
   }
-
-  TMEM::FinalizeBinds(used_textures);
 }
 
 class ArbitraryMipmapDetector
@@ -1202,27 +1196,28 @@ private:
 TextureCacheBase::TCacheEntry* TextureCacheBase::Load(const u32 stage)
 {
   // if this stage was not invalidated by changes to texture registers, keep the current texture
-  if (TMEM::IsValid(stage) && bound_textures[stage])
+  if (IsValidBindPoint(stage) && bound_textures[stage])
   {
-    TCacheEntry* entry = bound_textures[stage];
-    // If the TMEM configuration is such that this texture is more or less guaranteed to still
-    // be in TMEM, then we know we can reuse the old entry without even hashing the memory
-    if (TMEM::IsCached(stage))
-    {
-      return entry;
-    }
-
-    // Otherwise, hash the backing memory and check it's unchanged.
-    // FIXME: this doesn't correctly handle textures from tmem.
-    if (!entry->tmem_only && entry->base_hash == entry->CalculateHash())
-    {
-      return entry;
-    }
+    return bound_textures[stage];
   }
 
-  TextureInfo texture_info = TextureInfo::FromStage(stage);
+  const FourTexUnits& tex = bpmem.tex[stage >> 2];
+  const u32 id = stage & 3;
+  const u32 address = (tex.texImage3[id].image_base /* & 0x1FFFFF*/) << 5;
+  u32 width = tex.texImage0[id].width + 1;
+  u32 height = tex.texImage0[id].height + 1;
+  const TextureFormat texformat = tex.texImage0[id].format;
+  const u32 tlutaddr = tex.texTlut[id].tmem_offset << 9;
+  const TLUTFormat tlutfmt = tex.texTlut[id].tlut_format;
+  const bool use_mipmaps = SamplerCommon::AreBpTexMode0MipmapsEnabled(tex.texMode0[id]);
+  u32 tex_levels = use_mipmaps ? ((tex.texMode1[id].max_lod + 0xf) / 0x10 + 1) : 1;
+  const bool from_tmem = tex.texImage1[id].cache_manually_managed != 0;
+  const u32 tmem_address_even = from_tmem ? tex.texImage1[id].tmem_even * TMEM_LINE_SIZE : 0;
+  const u32 tmem_address_odd = from_tmem ? tex.texImage2[id].tmem_odd * TMEM_LINE_SIZE : 0;
 
-  auto entry = GetTexture(g_ActiveConfig.iSafeTextureCache_ColorSamples, texture_info);
+  auto entry = GetTexture(address, width, height, texformat,
+                          g_ActiveConfig.iSafeTextureCache_ColorSamples, tlutaddr, tlutfmt,
+                          use_mipmaps, tex_levels, from_tmem, tmem_address_even, tmem_address_odd);
 
   if (!entry)
     return nullptr;
@@ -1232,65 +1227,92 @@ TextureCacheBase::TCacheEntry* TextureCacheBase::Load(const u32 stage)
 
   // We need to keep track of invalided textures until they have actually been replaced or
   // re-loaded
-  TMEM::Bind(stage, entry->NumBlocksX(), entry->NumBlocksY(), entry->GetNumLevels() > 1,
-             entry->format == TextureFormat::RGBA8);
+  valid_bind_points.set(stage);
 
   return entry;
 }
 
 TextureCacheBase::TCacheEntry*
-TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, TextureInfo& texture_info)
+TextureCacheBase::GetTexture(u32 address, u32 width, u32 height, const TextureFormat texformat,
+                             const int textureCacheSafetyColorSampleSize, u32 tlutaddr,
+                             TLUTFormat tlutfmt, bool use_mipmaps, u32 tex_levels, bool from_tmem,
+                             u32 tmem_address_even, u32 tmem_address_odd)
 {
-  u32 expanded_width = texture_info.GetExpandedWidth();
-  u32 expanded_height = texture_info.GetExpandedHeight();
+  // TexelSizeInNibbles(format) * width * height / 16;
+  const unsigned int bsw = TexDecoder_GetBlockWidthInTexels(texformat);
+  const unsigned int bsh = TexDecoder_GetBlockHeightInTexels(texformat);
 
-  u32 width = texture_info.GetRawWidth();
-  u32 height = texture_info.GetRawHeight();
+  unsigned int expandedWidth = Common::AlignUp(width, bsw);
+  unsigned int expandedHeight = Common::AlignUp(height, bsh);
+  const unsigned int nativeW = width;
+  const unsigned int nativeH = height;
 
   // Hash assigned to texcache entry (also used to generate filenames used for texture dumping and
   // custom texture lookup)
   u64 base_hash = TEXHASH_INVALID;
   u64 full_hash = TEXHASH_INVALID;
 
-  TextureAndTLUTFormat full_format(texture_info.GetTextureFormat(), texture_info.GetTlutFormat());
+  TextureAndTLUTFormat full_format(texformat, tlutfmt);
+
+  const bool isPaletteTexture = IsColorIndexed(texformat);
 
   // Reject invalid tlut format.
-  if (texture_info.GetPaletteSize() && !IsValidTLUTFormat(texture_info.GetTlutFormat()))
+  if (isPaletteTexture && !IsValidTLUTFormat(tlutfmt))
     return nullptr;
 
-  u32 bytes_per_block = (texture_info.GetBlockWidth() * texture_info.GetBlockHeight() *
-                         TexDecoder_GetTexelSizeInNibbles(texture_info.GetTextureFormat())) /
-                        2;
+  const u32 texture_size =
+      TexDecoder_GetTextureSizeInBytes(expandedWidth, expandedHeight, texformat);
+  u32 bytes_per_block = (bsw * bsh * TexDecoder_GetTexelSizeInNibbles(texformat)) / 2;
+  u32 additional_mips_size = 0;  // not including level 0, which is texture_size
+
+  // GPUs don't like when the specified mipmap count would require more than one 1x1-sized LOD in
+  // the mipmap chain
+  // e.g. 64x64 with 7 LODs would have the mipmap chain 64x64,32x32,16x16,8x8,4x4,2x2,1x1,0x0, so we
+  // limit the mipmap count to 6 there
+  tex_levels = std::min<u32>(IntLog2(std::max(width, height)) + 1, tex_levels);
+
+  for (u32 level = 1; level != tex_levels; ++level)
+  {
+    // We still need to calculate the original size of the mips
+    const u32 expanded_mip_width = Common::AlignUp(CalculateLevelSize(width, level), bsw);
+    const u32 expanded_mip_height = Common::AlignUp(CalculateLevelSize(height, level), bsh);
+
+    additional_mips_size +=
+        TexDecoder_GetTextureSizeInBytes(expanded_mip_width, expanded_mip_height, texformat);
+  }
 
   // TODO: the texture cache lookup is based on address, but a texture from tmem has no reason
   //       to have a unique and valid address. This could result in a regular texture and a tmem
   //       texture aliasing onto the same texture cache entry.
-  if (!texture_info.GetData())
+  const u8* src_data;
+  if (from_tmem)
+    src_data = &texMem[tmem_address_even];
+  else
+    src_data = Memory::GetPointer(address);
+
+  if (!src_data)
   {
-    ERROR_LOG_FMT(VIDEO, "Trying to use an invalid texture address {:#010x}",
-                  texture_info.GetRawAddress());
+    ERROR_LOG_FMT(VIDEO, "Trying to use an invalid texture address {:#010x}", address);
     return nullptr;
   }
 
   // If we are recording a FifoLog, keep track of what memory we read. FifoRecorder does
   // its own memory modification tracking independent of the texture hashing below.
-  if (OpcodeDecoder::g_record_fifo_data && !texture_info.IsFromTmem())
+  if (OpcodeDecoder::g_record_fifo_data && !from_tmem)
   {
-    FifoRecorder::GetInstance().UseMemory(
-        texture_info.GetRawAddress(), texture_info.GetFullLevelSize(), MemoryUpdate::TEXTURE_MAP);
+    FifoRecorder::GetInstance().UseMemory(address, texture_size + additional_mips_size,
+                                          MemoryUpdate::TEXTURE_MAP);
   }
 
   // TODO: This doesn't hash GB tiles for preloaded RGBA8 textures (instead, it's hashing more data
   // from the low tmem bank than it should)
-  base_hash = Common::GetHash64(texture_info.GetData(), texture_info.GetTextureSize(),
-                                textureCacheSafetyColorSampleSize);
+  base_hash = Common::GetHash64(src_data, texture_size, textureCacheSafetyColorSampleSize);
   u32 palette_size = 0;
-  if (texture_info.GetPaletteSize())
+  if (isPaletteTexture)
   {
-    palette_size = *texture_info.GetPaletteSize();
-    full_hash =
-        base_hash ^ Common::GetHash64(texture_info.GetTlutAddress(), *texture_info.GetPaletteSize(),
-                                      textureCacheSafetyColorSampleSize);
+    palette_size = TexDecoder_GetPaletteSize(texformat);
+    full_hash = base_hash ^ Common::GetHash64(&texMem[tlutaddr], palette_size,
+                                              textureCacheSafetyColorSampleSize);
   }
   else
   {
@@ -1324,7 +1346,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   //
   // For efb copies, the entry created in CopyRenderTargetToTexture always has to be used, or else
   // it was done in vain.
-  auto iter_range = textures_by_address.equal_range(texture_info.GetRawAddress());
+  auto iter_range = textures_by_address.equal_range(address);
   TexAddrCache::iterator iter = iter_range.first;
   TexAddrCache::iterator oldest_entry = iter;
   int temp_frameCount = 0x7fffffff;
@@ -1349,14 +1371,13 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
 
     // Do not load strided EFB copies, they are not meant to be used directly.
     // Also do not directly load EFB copies, which were partly overwritten.
-    if (entry->IsEfbCopy() && entry->native_width == texture_info.GetRawWidth() &&
-        entry->native_height == texture_info.GetRawHeight() &&
+    if (entry->IsEfbCopy() && entry->native_width == nativeW && entry->native_height == nativeH &&
         entry->memory_stride == entry->BytesPerRow() && !entry->may_have_overlapping_textures)
     {
       // EFB copies have slightly different rules as EFB copy formats have different
       // meanings from texture formats.
       if ((base_hash == entry->hash &&
-           (!texture_info.GetPaletteSize() || g_Config.backend_info.bSupportsPaletteConversion)) ||
+           (!isPaletteTexture || g_Config.backend_info.bSupportsPaletteConversion)) ||
           IsPlayingBackFifologWithBrokenEFBCopies)
       {
         // The texture format in VRAM must match the format that the copy was created with. Some
@@ -1365,10 +1386,10 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
         // GPU (e.g. IA4 and I8 or RGB565 and RGBA5). The only known game which reinteprets texels
         // in this manner is Spiderman Shattered Dimensions, where it creates a copy in B8 format,
         // and sets it up as a IA4 texture.
-        if (!IsCompatibleTextureFormat(entry->format.texfmt, texture_info.GetTextureFormat()))
+        if (!IsCompatibleTextureFormat(entry->format.texfmt, texformat))
         {
           // Can we reinterpret this in VRAM?
-          if (CanReinterpretTextureOnGPU(entry->format.texfmt, texture_info.GetTextureFormat()))
+          if (CanReinterpretTextureOnGPU(entry->format.texfmt, texformat))
           {
             // Delay the conversion until afterwards, it's possible this texture has already been
             // converted.
@@ -1391,7 +1412,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
 
         // TODO: We should check width/height/levels for EFB copies. I'm not sure what effect
         // checking width/height/levels would have.
-        if (!texture_info.GetPaletteSize() || !g_Config.backend_info.bSupportsPaletteConversion)
+        if (!isPaletteTexture || !g_Config.backend_info.bSupportsPaletteConversion)
           return entry;
 
         // Note that we found an unconverted EFB copy, then continue.  We'll
@@ -1414,12 +1435,10 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
     {
       // For normal textures, all texture parameters need to match
       if (!entry->IsEfbCopy() && entry->hash == full_hash && entry->format == full_format &&
-          entry->native_levels >= texture_info.GetLevelCount() &&
-          entry->native_width == texture_info.GetRawWidth() &&
-          entry->native_height == texture_info.GetRawHeight())
+          entry->native_levels >= tex_levels && entry->native_width == nativeW &&
+          entry->native_height == nativeH)
       {
-        entry = DoPartialTextureUpdates(iter->second, texture_info.GetTlutAddress(),
-                                        texture_info.GetTlutFormat());
+        entry = DoPartialTextureUpdates(iter->second, &texMem[tlutaddr], tlutfmt);
         entry->texture->FinishedRendering();
         return entry;
       }
@@ -1433,7 +1452,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
     // Also skip XFB copies, we might need to still scan them out
     // or load them as regular textures later.
     if (entry->frameCount != FRAMECOUNT_INVALID && entry->frameCount < temp_frameCount &&
-        !entry->IsCopy() && !(texture_info.GetPaletteSize() && entry->base_hash == base_hash))
+        !entry->IsCopy() && !(isPaletteTexture && entry->base_hash == base_hash))
     {
       temp_frameCount = entry->frameCount;
       oldest_entry = iter;
@@ -1443,13 +1462,11 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
 
   if (unreinterpreted_copy != textures_by_address.end())
   {
-    TCacheEntry* decoded_entry =
-        ReinterpretEntry(unreinterpreted_copy->second, texture_info.GetTextureFormat());
+    TCacheEntry* decoded_entry = ReinterpretEntry(unreinterpreted_copy->second, texformat);
 
     // It's possible to combine reinterpreted textures + palettes.
     if (unreinterpreted_copy == unconverted_copy && decoded_entry)
-      decoded_entry = ApplyPaletteToEntry(decoded_entry, texture_info.GetTlutAddress(),
-                                          texture_info.GetTlutFormat());
+      decoded_entry = ApplyPaletteToEntry(decoded_entry, &texMem[tlutaddr], tlutfmt);
 
     if (decoded_entry)
       return decoded_entry;
@@ -1457,8 +1474,8 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
 
   if (unconverted_copy != textures_by_address.end())
   {
-    TCacheEntry* decoded_entry = ApplyPaletteToEntry(
-        unconverted_copy->second, texture_info.GetTlutAddress(), texture_info.GetTlutFormat());
+    TCacheEntry* decoded_entry =
+        ApplyPaletteToEntry(unconverted_copy->second, &texMem[tlutaddr], tlutfmt);
 
     if (decoded_entry)
     {
@@ -1473,8 +1490,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   // Example: Tales of Symphonia (GC) uses over 500 small textures in menus, but only around 70
   // different ones
   if (textureCacheSafetyColorSampleSize == 0 ||
-      std::max(texture_info.GetTextureSize(), palette_size) <=
-          (u32)textureCacheSafetyColorSampleSize * 8)
+      std::max(texture_size, palette_size) <= (u32)textureCacheSafetyColorSampleSize * 8)
   {
     auto hash_range = textures_by_hash.equal_range(full_hash);
     TexHashCache::iterator hash_iter = hash_range.first;
@@ -1482,12 +1498,10 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
     {
       TCacheEntry* entry = hash_iter->second;
       // All parameters, except the address, need to match here
-      if (entry->format == full_format && entry->native_levels >= texture_info.GetLevelCount() &&
-          entry->native_width == texture_info.GetRawWidth() &&
-          entry->native_height == texture_info.GetRawHeight())
+      if (entry->format == full_format && entry->native_levels >= tex_levels &&
+          entry->native_width == nativeW && entry->native_height == nativeH)
       {
-        entry = DoPartialTextureUpdates(hash_iter->second, texture_info.GetTlutAddress(),
-                                        texture_info.GetTlutFormat());
+        entry = DoPartialTextureUpdates(hash_iter->second, &texMem[tlutaddr], tlutfmt);
         entry->texture->FinishedRendering();
         return entry;
       }
@@ -1505,7 +1519,8 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   std::shared_ptr<HiresTexture> hires_tex;
   if (g_ActiveConfig.bHiresTextures)
   {
-    hires_tex = HiresTexture::Search(texture_info);
+    hires_tex = HiresTexture::Search(src_data, texture_size, &texMem[tlutaddr], palette_size, width,
+                                     height, texformat, use_mipmaps);
 
     if (hires_tex)
     {
@@ -1515,22 +1530,21 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
         width = level.width;
         height = level.height;
       }
-      expanded_width = level.width;
-      expanded_height = level.height;
+      expandedWidth = level.width;
+      expandedHeight = level.height;
     }
   }
 
   // how many levels the allocated texture shall have
-  const u32 texLevels = hires_tex ? (u32)hires_tex->m_levels.size() : texture_info.GetLevelCount();
+  const u32 texLevels = hires_tex ? (u32)hires_tex->m_levels.size() : tex_levels;
 
   // We can decode on the GPU if it is a supported format and the flag is enabled.
-  // Currently we don't decode RGBA8 textures from TMEM, as that would require copying from both
+  // Currently we don't decode RGBA8 textures from Tmem, as that would require copying from both
   // banks, and if we're doing an copy we may as well just do the whole thing on the CPU, since
   // there's no conversion between formats. In the future this could be extended with a separate
   // shader, however.
-  const bool decode_on_gpu =
-      !hires_tex && g_ActiveConfig.UseGPUTextureDecoding() &&
-      !(texture_info.IsFromTmem() && texture_info.GetTextureFormat() == TextureFormat::RGBA8);
+  const bool decode_on_gpu = !hires_tex && g_ActiveConfig.UseGPUTextureDecoding() &&
+                             !(from_tmem && texformat == TextureFormat::RGBA8);
 
   // create the entry/texture
   const TextureConfig config(width, height, texLevels, 1, 1,
@@ -1540,6 +1554,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
     return nullptr;
 
   ArbitraryMipmapDetector arbitrary_mip_detector;
+  const u8* tlut = &texMem[tlutaddr];
   if (hires_tex)
   {
     const auto& level = hires_tex->m_levels[0];
@@ -1553,13 +1568,11 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   if (!hires_tex)
   {
     if (!decode_on_gpu ||
-        !DecodeTextureOnGPU(entry, 0, texture_info.GetData(), texture_info.GetTextureSize(),
-                            texture_info.GetTextureFormat(), width, height, expanded_width,
-                            expanded_height,
-                            bytes_per_block * (expanded_width / texture_info.GetBlockWidth()),
-                            texture_info.GetTlutAddress(), texture_info.GetTlutFormat()))
+        !DecodeTextureOnGPU(entry, 0, src_data, texture_size, texformat, width, height,
+                            expandedWidth, expandedHeight, bytes_per_block * (expandedWidth / bsw),
+                            tlut, tlutfmt))
     {
-      size_t decoded_texture_size = expanded_width * sizeof(u32) * expanded_height;
+      size_t decoded_texture_size = expandedWidth * sizeof(u32) * expandedHeight;
 
       // Allocate memory for all levels at once
       size_t total_texture_size = decoded_texture_size;
@@ -1568,7 +1581,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
       size_t mip_downsample_buffer_size = decoded_texture_size * 5 / 16;
 
       size_t prev_level_size = decoded_texture_size;
-      for (u32 i = 1; i < texture_info.GetLevelCount(); ++i)
+      for (u32 i = 1; i < tex_levels; ++i)
       {
         prev_level_size /= 4;
         total_texture_size += prev_level_size;
@@ -1579,39 +1592,35 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
 
       CheckTempSize(total_texture_size);
       dst_buffer = temp;
-      if (!(texture_info.GetTextureFormat() == TextureFormat::RGBA8 && texture_info.IsFromTmem()))
+      if (!(texformat == TextureFormat::RGBA8 && from_tmem))
       {
-        TexDecoder_Decode(dst_buffer, texture_info.GetData(), expanded_width, expanded_height,
-                          texture_info.GetTextureFormat(), texture_info.GetTlutAddress(),
-                          texture_info.GetTlutFormat());
+        TexDecoder_Decode(dst_buffer, src_data, expandedWidth, expandedHeight, texformat, tlut,
+                          tlutfmt);
       }
       else
       {
-        TexDecoder_DecodeRGBA8FromTmem(dst_buffer, texture_info.GetData(),
-                                       texture_info.GetTmemOddAddress(), expanded_width,
-                                       expanded_height);
+        u8* src_data_gb = &texMem[tmem_address_odd];
+        TexDecoder_DecodeRGBA8FromTmem(dst_buffer, src_data, src_data_gb, expandedWidth,
+                                       expandedHeight);
       }
 
-      entry->texture->Load(0, width, height, expanded_width, dst_buffer, decoded_texture_size);
+      entry->texture->Load(0, width, height, expandedWidth, dst_buffer, decoded_texture_size);
 
-      arbitrary_mip_detector.AddLevel(width, height, expanded_width, dst_buffer);
+      arbitrary_mip_detector.AddLevel(width, height, expandedWidth, dst_buffer);
 
       dst_buffer += decoded_texture_size;
     }
   }
 
-  iter = textures_by_address.emplace(texture_info.GetRawAddress(), entry);
+  iter = textures_by_address.emplace(address, entry);
   if (textureCacheSafetyColorSampleSize == 0 ||
-      std::max(texture_info.GetTextureSize(), palette_size) <=
-          (u32)textureCacheSafetyColorSampleSize * 8)
+      std::max(texture_size, palette_size) <= (u32)textureCacheSafetyColorSampleSize * 8)
   {
     entry->textures_by_hash_iter = textures_by_hash.emplace(full_hash, entry);
   }
 
-  entry->SetGeneralParameters(texture_info.GetRawAddress(), texture_info.GetTextureSize(),
-                              full_format, false);
-  entry->SetDimensions(texture_info.GetRawWidth(), texture_info.GetRawHeight(),
-                       texture_info.GetLevelCount());
+  entry->SetGeneralParameters(address, texture_size, full_format, false);
+  entry->SetDimensions(nativeW, nativeH, tex_levels);
   entry->SetHashes(base_hash, full_hash);
   entry->is_custom_tex = hires_tex != nullptr;
   entry->memory_stride = entry->BytesPerRow();
@@ -1620,7 +1629,8 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   std::string basename;
   if (g_ActiveConfig.bDumpTextures && !hires_tex)
   {
-    basename = HiresTexture::GenBaseName(texture_info, true);
+    basename = HiresTexture::GenBaseName(src_data, texture_size, &texMem[tlutaddr], palette_size,
+                                         width, height, texformat, use_mipmaps, true);
   }
 
   if (hires_tex)
@@ -1634,34 +1644,46 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   }
   else
   {
+    // load mips - TODO: Loading mipmaps from tmem is untested!
+    src_data += texture_size;
+
+    const u8* ptr_even = nullptr;
+    const u8* ptr_odd = nullptr;
+    if (from_tmem)
+    {
+      ptr_even = &texMem[tmem_address_even + texture_size];
+      ptr_odd = &texMem[tmem_address_odd];
+    }
+
     for (u32 level = 1; level != texLevels; ++level)
     {
-      auto mip_level = texture_info.GetMipMapLevel(level - 1);
-      if (!mip_level)
-        continue;
+      const u32 mip_width = CalculateLevelSize(width, level);
+      const u32 mip_height = CalculateLevelSize(height, level);
+      const u32 expanded_mip_width = Common::AlignUp(mip_width, bsw);
+      const u32 expanded_mip_height = Common::AlignUp(mip_height, bsh);
+
+      const u8*& mip_src_data = from_tmem ? ((level % 2) ? ptr_odd : ptr_even) : src_data;
+      const u32 mip_size =
+          TexDecoder_GetTextureSizeInBytes(expanded_mip_width, expanded_mip_height, texformat);
 
       if (!decode_on_gpu ||
-          !DecodeTextureOnGPU(
-              entry, level, mip_level->GetData(), mip_level->GetTextureSize(),
-              texture_info.GetTextureFormat(), mip_level->GetRawWidth(), mip_level->GetRawHeight(),
-              mip_level->GetExpandedWidth(), mip_level->GetExpandedHeight(),
-              bytes_per_block * (mip_level->GetExpandedWidth() / texture_info.GetBlockWidth()),
-              texture_info.GetTlutAddress(), texture_info.GetTlutFormat()))
+          !DecodeTextureOnGPU(entry, level, mip_src_data, mip_size, texformat, mip_width,
+                              mip_height, expanded_mip_width, expanded_mip_height,
+                              bytes_per_block * (expanded_mip_width / bsw), tlut, tlutfmt))
       {
         // No need to call CheckTempSize here, as the whole buffer is preallocated at the beginning
-        const u32 decoded_mip_size =
-            mip_level->GetExpandedWidth() * sizeof(u32) * mip_level->GetExpandedHeight();
-        TexDecoder_Decode(dst_buffer, mip_level->GetData(), mip_level->GetExpandedWidth(),
-                          mip_level->GetExpandedHeight(), texture_info.GetTextureFormat(),
-                          texture_info.GetTlutAddress(), texture_info.GetTlutFormat());
-        entry->texture->Load(level, mip_level->GetRawWidth(), mip_level->GetRawHeight(),
-                             mip_level->GetExpandedWidth(), dst_buffer, decoded_mip_size);
+        const u32 decoded_mip_size = expanded_mip_width * sizeof(u32) * expanded_mip_height;
+        TexDecoder_Decode(dst_buffer, mip_src_data, expanded_mip_width, expanded_mip_height,
+                          texformat, tlut, tlutfmt);
+        entry->texture->Load(level, mip_width, mip_height, expanded_mip_width, dst_buffer,
+                             decoded_mip_size);
 
-        arbitrary_mip_detector.AddLevel(mip_level->GetRawWidth(), mip_level->GetRawHeight(),
-                                        mip_level->GetExpandedWidth(), dst_buffer);
+        arbitrary_mip_detector.AddLevel(mip_width, mip_height, expanded_mip_width, dst_buffer);
 
         dst_buffer += decoded_mip_size;
       }
+
+      mip_src_data += mip_size;
     }
   }
 
@@ -1679,8 +1701,7 @@ TextureCacheBase::GetTexture(const int textureCacheSafetyColorSampleSize, Textur
   INCSTAT(g_stats.num_textures_uploaded);
   SETSTAT(g_stats.num_textures_alive, static_cast<int>(textures_by_address.size()));
 
-  entry = DoPartialTextureUpdates(iter->second, texture_info.GetTlutAddress(),
-                                  texture_info.GetTlutFormat());
+  entry = DoPartialTextureUpdates(iter->second, &texMem[tlutaddr], tlutfmt);
 
   // This should only be needed if the texture was updated, or used GPU decoding.
   entry->texture->FinishedRendering();
@@ -2551,21 +2572,13 @@ TextureCacheBase::InvalidateTexture(TexAddrCache::iterator iter, bool discard_pe
 
   for (size_t i = 0; i < bound_textures.size(); ++i)
   {
-    if (bound_textures[i] == entry)
+    // If the entry is currently bound and not invalidated, keep it, but mark it as invalidated.
+    // This way it can still be used via tmem cache emulation, but nothing else.
+    // Spyro: A Hero's Tail is known for using such overwritten textures.
+    if (bound_textures[i] == entry && IsValidBindPoint(static_cast<u32>(i)))
     {
-      if (TMEM::IsCached(static_cast<u32>(i)))
-      {
-        // If the entry is currently bound and tmem has it recorded as cached, keep it, but mark it
-        // as invalidated. This way it can still be used via tmem cache emulation, but nothing else.
-        // Spyro: A Hero's Tail is known for using such overwritten textures.
-        bound_textures[i]->tmem_only = true;
-        return ++iter;
-      }
-      else
-      {
-        // Otherwise, delete the reference to it from bound_textures
-        bound_textures[i] = nullptr;
-      }
+      bound_textures[i]->tmem_only = true;
+      return ++iter;
     }
   }
 
@@ -2841,21 +2854,18 @@ bool TextureCacheBase::DecodeTextureOnGPU(TCacheEntry* entry, u32 dst_level, con
 }
 
 u32 TextureCacheBase::TCacheEntry::BytesPerRow() const
-{
-  // RGBA takes two cache lines per block; all others take one
-  const u32 bytes_per_block = format == TextureFormat::RGBA8 ? 64 : 32;
-
-  return NumBlocksX() * bytes_per_block;
-}
-
-u32 TextureCacheBase::TCacheEntry::NumBlocksX() const
 {
   const u32 blockW = TexDecoder_GetBlockWidthInTexels(format.texfmt);
 
   // Round up source height to multiple of block size
   const u32 actualWidth = Common::AlignUp(native_width, blockW);
 
-  return actualWidth / blockW;
+  const u32 numBlocksX = actualWidth / blockW;
+
+  // RGBA takes two cache lines per block; all others take one
+  const u32 bytes_per_block = format == TextureFormat::RGBA8 ? 64 : 32;
+
+  return numBlocksX * bytes_per_block;
 }
 
 u32 TextureCacheBase::TCacheEntry::NumBlocksY() const
@@ -2912,8 +2922,6 @@ u64 TextureCacheBase::TCacheEntry::CalculateHash() const
 {
   const u32 bytes_per_row = BytesPerRow();
   const u32 hash_sample_size = HashSampleSize();
-
-  // FIXME: textures from tmem won't get the correct hash.
   u8* ptr = Memory::GetPointer(addr);
   if (memory_stride == bytes_per_row)
   {
diff --git a/Source/Core/VideoCommon/TextureCacheBase.h b/Source/Core/VideoCommon/TextureCacheBase.h
index daf7e29..b9d7290 100644
--- a/Source/Core/VideoCommon/TextureCacheBase.h
+++ b/Source/Core/VideoCommon/TextureCacheBase.h
@@ -15,14 +15,12 @@
 #include <unordered_set>
 #include <vector>
 
-#include "Common/BitSet.h"
 #include "Common/CommonTypes.h"
 #include "Common/MathUtil.h"
 #include "VideoCommon/AbstractTexture.h"
 #include "VideoCommon/BPMemory.h"
 #include "VideoCommon/TextureConfig.h"
 #include "VideoCommon/TextureDecoder.h"
-#include "VideoCommon/TextureInfo.h"
 
 class AbstractFramebuffer;
 class AbstractStagingTexture;
@@ -196,7 +194,6 @@ public:
 
     bool IsEfbCopy() const { return is_efb_copy; }
     bool IsCopy() const { return is_xfb_copy || is_efb_copy; }
-    u32 NumBlocksX() const;
     u32 NumBlocksY() const;
     u32 BytesPerRow() const;
 
@@ -236,11 +233,17 @@ public:
   void Invalidate();
 
   TCacheEntry* Load(const u32 stage);
-  TCacheEntry* GetTexture(const int textureCacheSafetyColorSampleSize, TextureInfo& texture_info);
+  static void InvalidateAllBindPoints() { valid_bind_points.reset(); }
+  static bool IsValidBindPoint(u32 i) { return valid_bind_points.test(i); }
+  TCacheEntry* GetTexture(u32 address, u32 width, u32 height, const TextureFormat texformat,
+                          const int textureCacheSafetyColorSampleSize, u32 tlutaddr = 0,
+                          TLUTFormat tlutfmt = TLUTFormat::IA8, bool use_mipmaps = false,
+                          u32 tex_levels = 1, bool from_tmem = false, u32 tmem_address_even = 0,
+                          u32 tmem_address_odd = 0);
   TCacheEntry* GetXFBTexture(u32 address, u32 width, u32 height, u32 stride,
                              MathUtil::Rectangle<int>* display_rect);
 
-  virtual void BindTextures(BitSet32 used_textures);
+  virtual void BindTextures();
   void CopyRenderTargetToTexture(u32 dstAddr, EFBCopyFormat dstFormat, u32 width, u32 height,
                                  u32 dstStride, bool is_depth_copy,
                                  const MathUtil::Rectangle<int>& srcRect, bool isIntensity,
@@ -302,11 +305,11 @@ private:
 
   TCacheEntry* GetXFBFromCache(u32 address, u32 width, u32 height, u32 stride);
 
-  TCacheEntry* ApplyPaletteToEntry(TCacheEntry* entry, const u8* palette, TLUTFormat tlutfmt);
+  TCacheEntry* ApplyPaletteToEntry(TCacheEntry* entry, u8* palette, TLUTFormat tlutfmt);
 
   TCacheEntry* ReinterpretEntry(const TCacheEntry* existing_entry, TextureFormat new_format);
 
-  TCacheEntry* DoPartialTextureUpdates(TCacheEntry* entry_to_update, const u8* palette,
+  TCacheEntry* DoPartialTextureUpdates(TCacheEntry* entry_to_update, u8* palette,
                                        TLUTFormat tlutfmt);
   void StitchXFBCopy(TCacheEntry* entry_to_update);
 
diff --git a/Source/Core/VideoCommon/TextureConfig.cpp b/Source/Core/VideoCommon/TextureConfig.cpp
index 34fd932..e63850d 100644
--- a/Source/Core/VideoCommon/TextureConfig.cpp
+++ b/Source/Core/VideoCommon/TextureConfig.cpp
@@ -2,11 +2,10 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoCommon/TextureConfig.h"
+#include "VideoCommon/AbstractTexture.h"
 
 #include <tuple>
 
-#include "VideoCommon/AbstractTexture.h"
-
 bool TextureConfig::operator==(const TextureConfig& o) const
 {
   return std::tie(width, height, levels, layers, samples, format, flags) ==
diff --git a/Source/Core/VideoCommon/TextureDecoder_Generic.cpp b/Source/Core/VideoCommon/TextureDecoder_Generic.cpp
index 46a2252..f563394 100644
--- a/Source/Core/VideoCommon/TextureDecoder_Generic.cpp
+++ b/Source/Core/VideoCommon/TextureDecoder_Generic.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/TextureDecoder.h"
-
 #include <algorithm>
 #include <cmath>
 
@@ -11,7 +9,9 @@
 #include "Common/Swap.h"
 
 #include "VideoCommon/LookUpTables.h"
+#include "VideoCommon/TextureDecoder.h"
 #include "VideoCommon/TextureDecoder_Util.h"
+//#include "VideoCommon/VideoCommon.h" // to get debug logs
 #include "VideoCommon/VideoConfig.h"
 
 // GameCube/Wii texture decoder
@@ -116,8 +116,8 @@ static inline void DecodeBytes_IA4(u32* dst, const u8* src)
 static inline void DecodeBytes_RGB5A3(u32* dst, const u16* src)
 {
 #if 0
-  for (int x = 0; x < 4; x++)
-    dst[x] = DecodePixel_RGB5A3(Common::swap16(src[x]));
+	for (int x = 0; x < 4; x++)
+		dst[x] = DecodePixel_RGB5A3(Common::swap16(src[x]));
 #else
   dst[0] = DecodePixel_RGB5A3(Common::swap16(src[0]));
   dst[1] = DecodePixel_RGB5A3(Common::swap16(src[1]));
@@ -129,10 +129,10 @@ static inline void DecodeBytes_RGB5A3(u32* dst, const u16* src)
 static inline void DecodeBytes_RGBA8(u32* dst, const u16* src, const u16* src2)
 {
 #if 0
-  for (int x = 0; x < 4; x++)
-  {
-    dst[x] =  ((src[x] & 0xFF) << 24) | ((src[x] & 0xFF00)>>8)  | (src2[x] << 8);
-  }
+	for (int x = 0; x < 4; x++)
+	{
+		dst[x] =  ((src[x] & 0xFF) << 24) | ((src[x] & 0xFF00)>>8)  | (src2[x] << 8);
+	}
 #else
   dst[0] = ((src[0] & 0xFF) << 24) | ((src[0] & 0xFF00) >> 8) | (src2[0] << 8);
   dst[1] = ((src[1] & 0xFF) << 24) | ((src[1] & 0xFF00) >> 8) | (src2[1] << 8);
diff --git a/Source/Core/VideoCommon/TextureDecoder_x64.cpp b/Source/Core/VideoCommon/TextureDecoder_x64.cpp
index 761fc0c..7d60bd1 100644
--- a/Source/Core/VideoCommon/TextureDecoder_x64.cpp
+++ b/Source/Core/VideoCommon/TextureDecoder_x64.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/TextureDecoder.h"
-
 #include <algorithm>
 #include <cmath>
 #include <cstring>
@@ -18,6 +16,7 @@
 #include "Common/Swap.h"
 
 #include "VideoCommon/LookUpTables.h"
+#include "VideoCommon/TextureDecoder.h"
 #include "VideoCommon/TextureDecoder_Util.h"
 
 // GameCube/Wii texture decoder
diff --git a/Source/Core/VideoCommon/TextureInfo.cpp b/Source/Core/VideoCommon/TextureInfo.cpp
deleted file mode 100644
index 696f5b9..0000000
--- a/Source/Core/VideoCommon/TextureInfo.cpp
+++ /dev/null
@@ -1,315 +0,0 @@
-// Copyright 2021 Dolphin Emulator Project
-// SPDX-License-Identifier: GPL-2.0-or-later
-
-#include "VideoCommon/TextureInfo.h"
-
-#include <fmt/format.h>
-#include <xxhash.h>
-
-#include "Common/Align.h"
-#include "Core/HW/Memmap.h"
-#include "VideoCommon/BPMemory.h"
-#include "VideoCommon/TextureDecoder.h"
-
-TextureInfo TextureInfo::FromStage(u32 stage)
-{
-  const auto tex = bpmem.tex.GetUnit(stage);
-
-  const auto texture_format = tex.texImage0.format;
-  const auto tlut_format = tex.texTlut.tlut_format;
-
-  const auto width = tex.texImage0.width + 1;
-  const auto height = tex.texImage0.height + 1;
-
-  const u32 address = (tex.texImage3.image_base /* & 0x1FFFFF*/) << 5;
-
-  const u32 tlutaddr = tex.texTlut.tmem_offset << 9;
-  const u8* tlut_ptr = &texMem[tlutaddr];
-
-  std::optional<u32> mip_count;
-  const bool has_mipmaps = tex.texMode0.mipmap_filter != MipMode::None;
-  if (has_mipmaps)
-  {
-    mip_count = (tex.texMode1.max_lod + 0xf) / 0x10;
-  }
-
-  const bool from_tmem = tex.texImage1.cache_manually_managed != 0;
-  const u32 tmem_address_even = from_tmem ? tex.texImage1.tmem_even * TMEM_LINE_SIZE : 0;
-  const u32 tmem_address_odd = from_tmem ? tex.texImage2.tmem_odd * TMEM_LINE_SIZE : 0;
-
-  if (from_tmem)
-  {
-    return TextureInfo(&texMem[tmem_address_even], tlut_ptr, address, texture_format, tlut_format,
-                       width, height, true, &texMem[tmem_address_odd], &texMem[tmem_address_even],
-                       mip_count);
-  }
-
-  return TextureInfo(Memory::GetPointer(address), tlut_ptr, address, texture_format, tlut_format,
-                     width, height, false, nullptr, nullptr, mip_count);
-}
-
-TextureInfo::TextureInfo(const u8* ptr, const u8* tlut_ptr, u32 address,
-                         TextureFormat texture_format, TLUTFormat tlut_format, u32 width,
-                         u32 height, bool from_tmem, const u8* tmem_odd, const u8* tmem_even,
-                         std::optional<u32> mip_count)
-    : m_ptr(ptr), m_tlut_ptr(tlut_ptr), m_address(address), m_from_tmem(from_tmem),
-      m_tmem_odd(tmem_odd), m_texture_format(texture_format), m_tlut_format(tlut_format),
-      m_raw_width(width), m_raw_height(height)
-{
-  const bool is_palette_texture = IsColorIndexed(m_texture_format);
-  if (is_palette_texture)
-    m_palette_size = TexDecoder_GetPaletteSize(m_texture_format);
-
-  // TexelSizeInNibbles(format) * width * height / 16;
-  m_block_width = TexDecoder_GetBlockWidthInTexels(m_texture_format);
-  m_block_height = TexDecoder_GetBlockHeightInTexels(m_texture_format);
-
-  m_expanded_width = Common::AlignUp(m_raw_width, m_block_width);
-  m_expanded_height = Common::AlignUp(m_raw_height, m_block_height);
-
-  m_texture_size =
-      TexDecoder_GetTextureSizeInBytes(m_expanded_width, m_expanded_height, m_texture_format);
-
-  if (mip_count)
-  {
-    m_mipmaps_enabled = true;
-    const u32 raw_mip_count = *mip_count;
-
-    // GPUs don't like when the specified mipmap count would require more than one 1x1-sized LOD in
-    // the mipmap chain
-    // e.g. 64x64 with 7 LODs would have the mipmap chain 64x64,32x32,16x16,8x8,4x4,2x2,1x1,0x0, so
-    // we limit the mipmap count to 6 there
-    const u32 limited_mip_count =
-        std::min<u32>(IntLog2(std::max(width, height)) + 1, raw_mip_count + 1) - 1;
-
-    // load mips
-    const u8* src_data = m_ptr + GetTextureSize();
-    if (tmem_even)
-      tmem_even += GetTextureSize();
-
-    for (u32 i = 0; i < limited_mip_count; i++)
-    {
-      MipLevel mip_level(i + 1, *this, m_from_tmem, src_data, tmem_even, tmem_odd);
-      m_mip_levels.push_back(std::move(mip_level));
-    }
-  }
-}
-
-std::string TextureInfo::NameDetails::GetFullName() const
-{
-  return fmt::format("{}_{}{}_{}", base_name, texture_name, tlut_name, format_name);
-}
-
-TextureInfo::NameDetails TextureInfo::CalculateTextureName()
-{
-  if (!m_ptr)
-    return NameDetails{};
-
-  const u8* tlut = m_tlut_ptr;
-  size_t tlut_size = m_palette_size ? *m_palette_size : 0;
-
-  // checking for min/max on paletted textures
-  u32 min = 0xffff;
-  u32 max = 0;
-  switch (tlut_size)
-  {
-  case 0:
-    break;
-  case 16 * 2:
-    for (size_t i = 0; i < m_texture_size; i++)
-    {
-      const u32 low_nibble = m_ptr[i] & 0xf;
-      const u32 high_nibble = m_ptr[i] >> 4;
-
-      min = std::min({min, low_nibble, high_nibble});
-      max = std::max({max, low_nibble, high_nibble});
-    }
-    break;
-  case 256 * 2:
-  {
-    for (size_t i = 0; i < m_texture_size; i++)
-    {
-      const u32 texture_byte = m_ptr[i];
-
-      min = std::min(min, texture_byte);
-      max = std::max(max, texture_byte);
-    }
-    break;
-  }
-  case 16384 * 2:
-    for (size_t i = 0; i < m_texture_size; i += sizeof(u16))
-    {
-      const u32 texture_halfword = Common::swap16(m_ptr[i]) & 0x3fff;
-
-      min = std::min(min, texture_halfword);
-      max = std::max(max, texture_halfword);
-    }
-    break;
-  }
-  if (tlut_size > 0)
-  {
-    tlut_size = 2 * (max + 1 - min);
-    tlut += 2 * min;
-  }
-
-  const u64 tex_hash = XXH64(m_ptr, m_texture_size, 0);
-  const u64 tlut_hash = tlut_size ? XXH64(tlut, tlut_size, 0) : 0;
-
-  NameDetails result;
-  result.base_name = fmt::format("{}{}x{}{}", format_prefix, m_raw_width, m_raw_height,
-                                 m_mipmaps_enabled ? "_m" : "");
-  result.texture_name = fmt::format("{:016x}", tex_hash);
-  result.tlut_name = tlut_size ? fmt::format("_{:016x}", tlut_hash) : "";
-  result.format_name = fmt::to_string(static_cast<int>(m_texture_format));
-
-  return result;
-}
-
-const u8* TextureInfo::GetData() const
-{
-  return m_ptr;
-}
-
-const u8* TextureInfo::GetTlutAddress() const
-{
-  return m_tlut_ptr;
-}
-
-u32 TextureInfo::GetRawAddress() const
-{
-  return m_address;
-}
-
-bool TextureInfo::IsFromTmem() const
-{
-  return m_from_tmem;
-}
-
-const u8* TextureInfo::GetTmemOddAddress() const
-{
-  return m_tmem_odd;
-}
-
-TextureFormat TextureInfo::GetTextureFormat() const
-{
-  return m_texture_format;
-}
-
-TLUTFormat TextureInfo::GetTlutFormat() const
-{
-  return m_tlut_format;
-}
-
-std::optional<u32> TextureInfo::GetPaletteSize() const
-{
-  return m_palette_size;
-}
-
-u32 TextureInfo::GetTextureSize() const
-{
-  return m_texture_size;
-}
-
-u32 TextureInfo::GetBlockWidth() const
-{
-  return m_block_width;
-}
-
-u32 TextureInfo::GetBlockHeight() const
-{
-  return m_block_height;
-}
-
-u32 TextureInfo::GetExpandedWidth() const
-{
-  return m_expanded_width;
-}
-
-u32 TextureInfo::GetExpandedHeight() const
-{
-  return m_expanded_height;
-}
-
-u32 TextureInfo::GetRawWidth() const
-{
-  return m_raw_width;
-}
-
-u32 TextureInfo::GetRawHeight() const
-{
-  return m_raw_height;
-}
-
-bool TextureInfo::HasMipMaps() const
-{
-  return !m_mip_levels.empty();
-}
-
-u32 TextureInfo::GetLevelCount() const
-{
-  return static_cast<u32>(m_mip_levels.size()) + 1;
-}
-
-const TextureInfo::MipLevel* TextureInfo::GetMipMapLevel(u32 level) const
-{
-  if (level < m_mip_levels.size())
-    return &m_mip_levels[level];
-
-  return nullptr;
-}
-
-TextureInfo::MipLevel::MipLevel(u32 level, const TextureInfo& parent, bool from_tmem,
-                                const u8*& src_data, const u8*& ptr_even, const u8*& ptr_odd)
-{
-  m_raw_width = std::max(parent.GetRawWidth() >> level, 1u);
-  m_raw_height = std::max(parent.GetRawHeight() >> level, 1u);
-  m_expanded_width = Common::AlignUp(m_raw_width, parent.GetBlockWidth());
-  m_expanded_height = Common::AlignUp(m_raw_height, parent.GetBlockHeight());
-
-  m_texture_size = TexDecoder_GetTextureSizeInBytes(m_expanded_width, m_expanded_height,
-                                                    parent.GetTextureFormat());
-
-  const u8*& ptr = from_tmem ? ((level % 2) ? ptr_odd : ptr_even) : src_data;
-  m_ptr = ptr;
-  ptr += m_texture_size;
-}
-
-u32 TextureInfo::GetFullLevelSize() const
-{
-  u32 all_mips_size = 0;
-  for (const auto& mip_map : m_mip_levels)
-  {
-    all_mips_size += mip_map.GetTextureSize();
-  }
-  return m_texture_size + all_mips_size;
-}
-
-const u8* TextureInfo::MipLevel::GetData() const
-{
-  return m_ptr;
-}
-
-u32 TextureInfo::MipLevel::GetTextureSize() const
-{
-  return m_texture_size;
-}
-
-u32 TextureInfo::MipLevel::GetExpandedWidth() const
-{
-  return m_expanded_width;
-}
-
-u32 TextureInfo::MipLevel::GetExpandedHeight() const
-{
-  return m_expanded_height;
-}
-
-u32 TextureInfo::MipLevel::GetRawWidth() const
-{
-  return m_raw_width;
-}
-
-u32 TextureInfo::MipLevel::GetRawHeight() const
-{
-  return m_raw_height;
-}
diff --git a/Source/Core/VideoCommon/TextureInfo.h b/Source/Core/VideoCommon/TextureInfo.h
deleted file mode 100644
index 109715b..0000000
--- a/Source/Core/VideoCommon/TextureInfo.h
+++ /dev/null
@@ -1,118 +0,0 @@
-// Copyright 2021 Dolphin Emulator Project
-// SPDX-License-Identifier: GPL-2.0-or-later
-
-#pragma once
-
-#include <optional>
-#include <string>
-#include <string_view>
-#include <vector>
-
-#include "Common/CommonTypes.h"
-
-enum class TextureFormat;
-enum class TLUTFormat;
-
-class TextureInfo
-{
-public:
-  static TextureInfo FromStage(u32 stage);
-  TextureInfo(const u8* ptr, const u8* tlut_ptr, u32 address, TextureFormat texture_format,
-              TLUTFormat tlut_format, u32 width, u32 height, bool from_tmem, const u8* tmem_odd,
-              const u8* tmem_even, std::optional<u32> mip_count);
-
-  struct NameDetails
-  {
-    std::string base_name;
-    std::string texture_name;
-    std::string tlut_name;
-    std::string format_name;
-
-    std::string GetFullName() const;
-  };
-  NameDetails CalculateTextureName();
-
-  const u8* GetData() const;
-  const u8* GetTlutAddress() const;
-
-  u32 GetRawAddress() const;
-
-  bool IsFromTmem() const;
-  const u8* GetTmemOddAddress() const;
-
-  TextureFormat GetTextureFormat() const;
-  TLUTFormat GetTlutFormat() const;
-
-  std::optional<u32> GetPaletteSize() const;
-  u32 GetTextureSize() const;
-
-  u32 GetBlockWidth() const;
-  u32 GetBlockHeight() const;
-
-  u32 GetExpandedWidth() const;
-  u32 GetExpandedHeight() const;
-
-  u32 GetRawWidth() const;
-  u32 GetRawHeight() const;
-
-  class MipLevel
-  {
-  public:
-    MipLevel(u32 level, const TextureInfo& parent, bool from_tmem, const u8*& src_data,
-             const u8*& ptr_even, const u8*& ptr_odd);
-
-    const u8* GetData() const;
-
-    u32 GetTextureSize() const;
-
-    u32 GetExpandedWidth() const;
-    u32 GetExpandedHeight() const;
-
-    u32 GetRawWidth() const;
-    u32 GetRawHeight() const;
-
-  private:
-    const u8* m_ptr;
-
-    u32 m_texture_size = 0;
-
-    u32 m_expanded_width;
-    u32 m_raw_width;
-
-    u32 m_expanded_height;
-    u32 m_raw_height;
-  };
-
-  bool HasMipMaps() const;
-  u32 GetLevelCount() const;
-  const MipLevel* GetMipMapLevel(u32 level) const;
-  u32 GetFullLevelSize() const;
-
-  static constexpr std::string_view format_prefix{"tex1_"};
-
-private:
-  const u8* m_ptr;
-  const u8* m_tlut_ptr;
-
-  u32 m_address;
-
-  bool m_from_tmem;
-  const u8* m_tmem_odd;
-
-  TextureFormat m_texture_format;
-  TLUTFormat m_tlut_format;
-
-  bool m_mipmaps_enabled = false;
-  std::vector<MipLevel> m_mip_levels;
-
-  u32 m_texture_size = 0;
-  std::optional<u32> m_palette_size;
-
-  u32 m_block_width;
-  u32 m_expanded_width;
-  u32 m_raw_width;
-
-  u32 m_block_height;
-  u32 m_expanded_height;
-  u32 m_raw_height;
-};
diff --git a/Source/Core/VideoCommon/UberShaderCommon.cpp b/Source/Core/VideoCommon/UberShaderCommon.cpp
index 4a8fba8..8b013fc 100644
--- a/Source/Core/VideoCommon/UberShaderCommon.cpp
+++ b/Source/Core/VideoCommon/UberShaderCommon.cpp
@@ -2,7 +2,6 @@
 // SPDX-License-Identifier: GPL-2.0-or-later
 
 #include "VideoCommon/UberShaderCommon.h"
-
 #include "VideoCommon/NativeVertexFormat.h"
 #include "VideoCommon/ShaderGenCommon.h"
 #include "VideoCommon/VideoCommon.h"
@@ -10,6 +9,24 @@
 
 namespace UberShader
 {
+void WriteUberShaderCommonHeader(ShaderCode& out, APIType api_type,
+                                 const ShaderHostConfig& host_config)
+{
+  // ==============================================
+  //  BitfieldExtract for APIs which don't have it
+  // ==============================================
+  if (!host_config.backend_bitfield)
+  {
+    out.Write("uint bitfieldExtract(uint val, int off, int size) {{\n"
+              "	// This built-in function is only support in OpenGL 4.0+ and ES 3.1+\n"
+              "	// Microsoft's HLSL compiler automatically optimises this to a bitfield extract "
+              "instruction.\n"
+              "	uint mask = uint((1 << size) - 1);\n"
+              "	return uint(val >> off) & mask;\n"
+              "}}\n\n");
+  }
+}
+
 void WriteLightingFunction(ShaderCode& out)
 {
   // ==============================================
diff --git a/Source/Core/VideoCommon/UberShaderCommon.h b/Source/Core/VideoCommon/UberShaderCommon.h
index 4e3b0ff..d1a736a 100644
--- a/Source/Core/VideoCommon/UberShaderCommon.h
+++ b/Source/Core/VideoCommon/UberShaderCommon.h
@@ -3,18 +3,37 @@
 
 #pragma once
 
+#include <string>
 #include <string_view>
 
+#include <fmt/format.h>
+
+#include "Common/CommonTypes.h"
+#include "Common/TypeUtils.h"
+
 class ShaderCode;
 enum class APIType;
 union ShaderHostConfig;
 
 namespace UberShader
 {
+// Common functions across all ubershaders
+void WriteUberShaderCommonHeader(ShaderCode& out, APIType api_type,
+                                 const ShaderHostConfig& host_config);
+
 // Vertex lighting
 void WriteLightingFunction(ShaderCode& out);
 void WriteVertexLighting(ShaderCode& out, APIType api_type, std::string_view world_pos_var,
                          std::string_view normal_var, std::string_view in_color_0_var,
                          std::string_view in_color_1_var, std::string_view out_color_0_var,
                          std::string_view out_color_1_var);
+
+// bitfieldExtract generator for BitField types
+template <auto ptr_to_bitfield_member>
+std::string BitfieldExtract(std::string_view source)
+{
+  using BitFieldT = Common::MemberType<ptr_to_bitfield_member>;
+  return fmt::format("bitfieldExtract({}, {}, {})", source, static_cast<u32>(BitFieldT::StartBit()),
+                     static_cast<u32>(BitFieldT::NumBits()));
+}
 }  // namespace UberShader
diff --git a/Source/Core/VideoCommon/UberShaderPixel.cpp b/Source/Core/VideoCommon/UberShaderPixel.cpp
index 178de46..1520111 100644
--- a/Source/Core/VideoCommon/UberShaderPixel.cpp
+++ b/Source/Core/VideoCommon/UberShaderPixel.cpp
@@ -55,9 +55,6 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
   const bool stereo = host_config.stereo;
   const bool use_dual_source = host_config.backend_dual_source_blend;
   const bool use_shader_blend = !use_dual_source && host_config.backend_shader_framebuffer_fetch;
-  const bool use_shader_logic_op =
-      !host_config.backend_logic_op && host_config.backend_shader_framebuffer_fetch;
-  const bool use_framebuffer_fetch = use_shader_blend || use_shader_logic_op;
   const bool early_depth = uid_data->early_depth != 0;
   const bool per_pixel_depth = uid_data->per_pixel_depth != 0;
   const bool bounding_box = host_config.bounding_box;
@@ -66,59 +63,45 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
 
   out.Write("// Pixel UberShader for {} texgens{}{}\n", numTexgen,
             early_depth ? ", early-depth" : "", per_pixel_depth ? ", per-pixel depth" : "");
-  WriteBitfieldExtractHeader(out, api_type, host_config);
   WritePixelShaderCommonHeader(out, api_type, host_config, bounding_box);
+  WriteUberShaderCommonHeader(out, api_type, host_config);
   if (per_pixel_lighting)
     WriteLightingFunction(out);
 
   // Shader inputs/outputs in GLSL (HLSL is in main).
   if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
   {
-#ifdef __APPLE__
-    // Framebuffer fetch is only supported by Metal, so ensure that we're running Vulkan (MoltenVK)
-    // if we want to use it.
-    if (api_type == APIType::Vulkan)
+    if (use_dual_source)
     {
-      if (use_dual_source)
+      if (DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION))
+      {
+        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n"
+                  "FRAGMENT_OUTPUT_LOCATION(1) out vec4 ocol1;\n");
+      }
+      else
       {
         out.Write("FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0) out vec4 ocol0;\n"
                   "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 1) out vec4 ocol1;\n");
       }
-      else if (use_shader_blend)
+    }
+    else if (use_shader_blend)
+    {
+      // QComm's Adreno driver doesn't seem to like using the framebuffer_fetch value as an
+      // intermediate value with multiple reads & modifications, so pull out the "real" output value
+      // and use a temporary for calculations, then set the output value once at the end of the
+      // shader
+      if (DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION))
       {
-        // Metal doesn't support a single unified variable for both input and output, so we declare
-        // the output separately. The input will be defined later below.
-        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 real_ocol0;\n");
+        out.Write("FRAGMENT_OUTPUT_LOCATION(0) FRAGMENT_INOUT vec4 real_ocol0;\n");
       }
       else
       {
-        out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n");
-      }
-
-      if (use_framebuffer_fetch)
-      {
-        // Subpass inputs will be converted to framebuffer fetch by SPIRV-Cross.
-        out.Write("INPUT_ATTACHMENT_BINDING(0, 0, 0) uniform subpassInput in_ocol0;\n");
+        out.Write("FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0) FRAGMENT_INOUT vec4 real_ocol0;\n");
       }
     }
     else
-#endif
     {
-      bool has_broken_decoration =
-          DriverDetails::HasBug(DriverDetails::BUG_BROKEN_FRAGMENT_SHADER_INDEX_DECORATION);
-
-      out.Write("{} {} vec4 {};\n",
-                has_broken_decoration ? "FRAGMENT_OUTPUT_LOCATION(0)" :
-                                        "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 0)",
-                use_framebuffer_fetch ? "FRAGMENT_INOUT" : "out",
-                use_shader_blend ? "real_ocol0" : "ocol0");
-
-      if (use_dual_source)
-      {
-        out.Write("{} out vec4 ocol1;\n", has_broken_decoration ?
-                                              "FRAGMENT_OUTPUT_LOCATION(1)" :
-                                              "FRAGMENT_OUTPUT_LOCATION_INDEXED(0, 1)");
-      }
+      out.Write("FRAGMENT_OUTPUT_LOCATION(0) out vec4 ocol0;\n");
     }
 
     if (per_pixel_depth)
@@ -243,17 +226,17 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
   {
     // Doesn't look like DirectX supports this. Oh well the code path is here just in case it
     // supports this in the future.
-    out.Write("int4 sampleTextureWrapper(uint texmap, int2 uv, int layer) {{\n");
+    out.Write("int4 sampleTexture(uint sampler_num, float3 uv) {{\n");
     if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-      out.Write("  return sampleTexture(texmap, samp[texmap], uv, layer);\n");
+      out.Write("  return iround(texture(samp[sampler_num], uv) * 255.0);\n");
     else if (api_type == APIType::D3D)
-      out.Write("  return sampleTexture(texmap, tex[texmap], samp[texmap], uv, layer);\n");
+      out.Write("  return iround(Tex[sampler_num].Sample(samp[sampler_num], uv) * 255.0);\n");
     out.Write("}}\n\n");
   }
   else
   {
-    out.Write("int4 sampleTextureWrapper(uint sampler_num, int2 uv, int layer) {{\n"
-              "  // This is messy, but DirectX, OpenGL 3.3, and OpenGL ES 3.0 don't support "
+    out.Write("int4 sampleTexture(uint sampler_num, float3 uv) {{\n"
+              "  // This is messy, but DirectX, OpenGL 3.3 and OpenGL ES 3.0 doesn't support "
               "dynamic indexing of the sampler array\n"
               "  // With any luck the shader compiler will optimise this if the hardware supports "
               "dynamic indexing.\n"
@@ -261,14 +244,9 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
     for (int i = 0; i < 8; i++)
     {
       if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
-      {
-        out.Write("  case {0}u: return sampleTexture({0}u, samp[{0}u], uv, layer);\n", i);
-      }
+        out.Write("  case {}u: return iround(texture(samp[{}], uv) * 255.0);\n", i, i);
       else if (api_type == APIType::D3D)
-      {
-        out.Write("  case {0}u: return sampleTexture({0}u, tex[{0}u], samp[{0}u], uv, layer);\n",
-                  i);
-      }
+        out.Write("  case {}u: return iround(Tex[{}].Sample(samp[{}], uv) * 255.0);\n", i, i, i);
     }
     out.Write("  }}\n"
               "}}\n\n");
@@ -306,8 +284,8 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
   // ======================
   //    Indirect Lookup
   // ======================
-  const auto LookupIndirectTexture = [&out](std::string_view out_var_name,
-                                            std::string_view in_index_name) {
+  const auto LookupIndirectTexture = [&out, stereo](std::string_view out_var_name,
+                                                    std::string_view in_index_name) {
     // in_index_name is the indirect stage, not the tev stage
     // bpmem_iref is packed differently from RAS1_IREF
     // This function assumes bpmem_iref is nonzero (i.e. matrix is not off, and the
@@ -323,9 +301,11 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
               "  else\n"
               "    fixedPoint_uv = fixedPoint_uv >> " I_INDTEXSCALE "[{} >> 1].zw;\n"
               "\n"
-              "  {} = sampleTextureWrapper(texmap, fixedPoint_uv, layer).abg;\n"
-              "}}\n",
-              in_index_name, in_index_name, in_index_name, in_index_name, out_var_name);
+              "  {} = sampleTexture(texmap, float3(float2(fixedPoint_uv) * " I_TEXDIMS
+              "[texmap].xy, {})).abg;\n"
+              "}}",
+              in_index_name, in_index_name, in_index_name, in_index_name, out_var_name,
+              stereo ? "float(layer)" : "0.0");
   };
 
   // ======================
@@ -528,28 +508,11 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
 
     out.Write("void main()\n{{\n");
     out.Write("  float4 rawpos = gl_FragCoord;\n");
-
-    if (use_framebuffer_fetch)
-    {
-      // Store off a copy of the initial framebuffer value.
-      //
-      // If FB_FETCH_VALUE isn't defined (i.e. no special keyword for fetching from the
-      // framebuffer), we read from real_ocol0 or ocol0, depending if shader blending is enabled.
-      out.Write("#ifdef FB_FETCH_VALUE\n"
-                "  float4 initial_ocol0 = FB_FETCH_VALUE;\n"
-                "#else\n"
-                "  float4 initial_ocol0 = {};\n"
-                "#endif\n",
-                use_shader_blend ? "real_ocol0" : "ocol0");
-    }
-
     if (use_shader_blend)
     {
-      // QComm's Adreno driver doesn't seem to like using the framebuffer_fetch value as an
-      // intermediate value with multiple reads & modifications, so we pull out the "real" output
-      // value above and use a temporary for calculations, then set the output value once at the
-      // end of the shader if we are using shader blending.
-      out.Write("  float4 ocol0;\n"
+      // Store off a copy of the initial fb value for blending
+      out.Write("  float4 initial_ocol0 = FB_FETCH_VALUE;\n"
+                "  float4 ocol0;\n"
                 "  float4 ocol1;\n");
     }
   }
@@ -598,8 +561,6 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
       out.Write(",\n  in uint layer : SV_RenderTargetArrayIndex\n");
     out.Write("\n        ) {{\n");
   }
-  if (!stereo)
-    out.Write("  int layer = 0;\n");
 
   out.Write("  int3 tevcoord = int3(0, 0, 0);\n"
             "  State s;\n"
@@ -657,7 +618,7 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
     {
       out.Write("    int2 fixpoint_uv{} = int2(", i);
       out.Write("(tex{}.z == 0.0 ? tex{}.xy : tex{}.xy / tex{}.z)", i, i, i, i);
-      out.Write(" * float2(" I_TEXDIMS "[{}].zw * 128));\n", i);
+      out.Write(" * " I_TEXDIMS "[{}].zw);\n", i);
       // TODO: S24 overflows here?
     }
 
@@ -691,7 +652,7 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
     // For the undefined case, we just skip applying the indirect operation, which is close enough.
     // Viewtiful Joe hits the undefined case (bug 12525).
     // Wrapping and add to previous still apply in this case (and when the stage is disabled).
-    out.Write("      if (bpmem_iref(bt) != 0u) {{\n");
+    out.Write("      if (bpmem_iref(bt) != 0u) {{");
     out.Write("        int3 indcoord;\n");
     LookupIndirectTexture("indcoord", "bt");
     out.Write("        if (bs != 0u)\n"
@@ -781,8 +742,10 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
               "      uint sampler_num = {};\n",
               BitfieldExtract<&TwoTevStageOrders::texmap0>("ss.order"));
     out.Write("\n"
-              "      int4 color = sampleTextureWrapper(sampler_num, tevcoord.xy, layer);\n"
-              "      uint swap = {};\n",
+              "      float2 uv = (float2(tevcoord.xy)) * " I_TEXDIMS "[sampler_num].xy;\n");
+    out.Write("      int4 color = sampleTexture(sampler_num, float3(uv, {}));\n",
+              stereo ? "float(layer)" : "0.0");
+    out.Write("      uint swap = {};\n",
               BitfieldExtract<&TevStageCombiner::AlphaCombiner::tswap>("ss.ac"));
     out.Write("      s.TexColor = Swizzle(swap, color);\n");
     out.Write("    }} else {{\n"
@@ -1109,40 +1072,6 @@ ShaderCode GenPixelShader(APIType api_type, const ShaderHostConfig& host_config,
             "  }}\n"
             "\n");
 
-  if (use_shader_logic_op)
-  {
-    static constexpr std::array<const char*, 16> logic_op_mode{
-        "int4(0, 0, 0, 0)",          // CLEAR
-        "TevResult & fb_value",      // AND
-        "TevResult & ~fb_value",     // AND_REVERSE
-        "TevResult",                 // COPY
-        "~TevResult & fb_value",     // AND_INVERTED
-        "fb_value",                  // NOOP
-        "TevResult ^ fb_value",      // XOR
-        "TevResult | fb_value",      // OR
-        "~(TevResult | fb_value)",   // NOR
-        "~(TevResult ^ fb_value)",   // EQUIV
-        "~fb_value",                 // INVERT
-        "TevResult | ~fb_value",     // OR_REVERSE
-        "~TevResult",                // COPY_INVERTED
-        "~TevResult | fb_value",     // OR_INVERTED
-        "~(TevResult & fb_value)",   // NAND
-        "int4(255, 255, 255, 255)",  // SET
-    };
-
-    out.Write("  // Logic Ops\n"
-              "  if (logic_op_enable) {{\n"
-              "    int4 fb_value = iround(initial_ocol0 * 255.0);"
-              "    switch (logic_op_mode) {{\n");
-    for (size_t i = 0; i < logic_op_mode.size(); i++)
-    {
-      out.Write("      case {}u: TevResult = {}; break;\n", i, logic_op_mode[i]);
-    }
-
-    out.Write("    }}\n"
-              "  }}\n");
-  }
-
   // D3D requires that the shader outputs be uint when writing to a uint render target for logic op.
   if (api_type == APIType::D3D && uid_data->uint_output)
   {
diff --git a/Source/Core/VideoCommon/UberShaderVertex.cpp b/Source/Core/VideoCommon/UberShaderVertex.cpp
index 6891535..8d3b128 100644
--- a/Source/Core/VideoCommon/UberShaderVertex.cpp
+++ b/Source/Core/VideoCommon/UberShaderVertex.cpp
@@ -49,8 +49,8 @@ ShaderCode GenVertexShader(APIType api_type, const ShaderHostConfig& host_config
   GenerateVSOutputMembers(out, api_type, num_texgen, host_config, "");
   out.Write("}};\n\n");
 
+  WriteUberShaderCommonHeader(out, api_type, host_config);
   WriteIsNanHeader(out, api_type);
-  WriteBitfieldExtractHeader(out, api_type, host_config);
   WriteLightingFunction(out);
 
   if (api_type == APIType::OpenGL || api_type == APIType::Vulkan)
diff --git a/Source/Core/VideoCommon/VertexLoaderBase.h b/Source/Core/VideoCommon/VertexLoaderBase.h
index 26ec5c6..94489da 100644
--- a/Source/Core/VideoCommon/VertexLoaderBase.h
+++ b/Source/Core/VideoCommon/VertexLoaderBase.h
@@ -79,9 +79,8 @@ public:
 
 protected:
   VertexLoaderBase(const TVtxDesc& vtx_desc, const VAT& vtx_attr)
-      : m_vertex_size{GetVertexSize(vtx_desc, vtx_attr)}, m_native_components{GetVertexComponents(
-                                                              vtx_desc, vtx_attr)},
-        m_VtxAttr{vtx_attr}, m_VtxDesc{vtx_desc}
+      : m_VtxDesc{vtx_desc}, m_VtxAttr{vtx_attr}, m_vertex_size{GetVertexSize(vtx_desc, vtx_attr)},
+        m_native_components{GetVertexComponents(vtx_desc, vtx_attr)}
   {
   }
 
diff --git a/Source/Core/VideoCommon/VertexLoader_Color.cpp b/Source/Core/VideoCommon/VertexLoader_Color.cpp
index b41272c..93c5658 100644
--- a/Source/Core/VideoCommon/VertexLoader_Color.cpp
+++ b/Source/Core/VideoCommon/VertexLoader_Color.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/VertexLoader_Color.h"
-
 #include <cstring>
 
 #include "Common/CommonTypes.h"
@@ -13,6 +11,7 @@
 #include "VideoCommon/VertexLoader.h"
 #include "VideoCommon/VertexLoaderManager.h"
 #include "VideoCommon/VertexLoaderUtils.h"
+#include "VideoCommon/VertexLoader_Color.h"
 
 namespace
 {
diff --git a/Source/Core/VideoCommon/VertexManagerBase.cpp b/Source/Core/VideoCommon/VertexManagerBase.cpp
index 5fa85b2..0ebb385 100644
--- a/Source/Core/VideoCommon/VertexManagerBase.cpp
+++ b/Source/Core/VideoCommon/VertexManagerBase.cpp
@@ -28,6 +28,7 @@
 #include "VideoCommon/PerfQueryBase.h"
 #include "VideoCommon/PixelShaderManager.h"
 #include "VideoCommon/RenderBase.h"
+#include "VideoCommon/SamplerCommon.h"
 #include "VideoCommon/Statistics.h"
 #include "VideoCommon/TextureCacheBase.h"
 #include "VideoCommon/VertexLoaderManager.h"
@@ -352,7 +353,7 @@ void VertexManagerBase::LoadTextures()
   for (unsigned int i : usedtextures)
     g_texture_cache->Load(i);
 
-  g_texture_cache->BindTextures(usedtextures);
+  g_texture_cache->BindTextures();
 }
 
 void VertexManagerBase::Flush()
diff --git a/Source/Core/VideoCommon/VideoBackendBase.cpp b/Source/Core/VideoCommon/VideoBackendBase.cpp
index b84f6f9..bc50d39 100644
--- a/Source/Core/VideoCommon/VideoBackendBase.cpp
+++ b/Source/Core/VideoCommon/VideoBackendBase.cpp
@@ -47,7 +47,6 @@
 #include "VideoCommon/PixelEngine.h"
 #include "VideoCommon/PixelShaderManager.h"
 #include "VideoCommon/RenderBase.h"
-#include "VideoCommon/TMEM.h"
 #include "VideoCommon/TextureCacheBase.h"
 #include "VideoCommon/VertexLoaderManager.h"
 #include "VideoCommon/VertexManagerBase.h"
@@ -323,7 +322,6 @@ void VideoBackendBase::InitializeShared()
   VertexShaderManager::Init();
   GeometryShaderManager::Init();
   PixelShaderManager::Init();
-  TMEM::Init();
 
   g_Config.VerifyValidity();
   UpdateActiveConfig();
diff --git a/Source/Core/VideoCommon/VideoConfig.cpp b/Source/Core/VideoCommon/VideoConfig.cpp
index a4aa9bd..3482c0a 100644
--- a/Source/Core/VideoCommon/VideoConfig.cpp
+++ b/Source/Core/VideoCommon/VideoConfig.cpp
@@ -137,7 +137,6 @@ void VideoConfig::Refresh()
   bVertexRounding = Config::Get(Config::GFX_HACK_VERTEX_ROUDING);
   iEFBAccessTileSize = Config::Get(Config::GFX_HACK_EFB_ACCESS_TILE_SIZE);
   iMissingColorValue = Config::Get(Config::GFX_HACK_MISSING_COLOR_VALUE);
-  bFastTextureSampling = Config::Get(Config::GFX_HACK_FAST_TEXTURE_SAMPLING);
 
   bPerfQueriesEnable = Config::Get(Config::GFX_PERF_QUERIES_ENABLE);
 
diff --git a/Source/Core/VideoCommon/VideoConfig.h b/Source/Core/VideoCommon/VideoConfig.h
index 5bb3e52..81b47cf 100644
--- a/Source/Core/VideoCommon/VideoConfig.h
+++ b/Source/Core/VideoCommon/VideoConfig.h
@@ -136,7 +136,6 @@ struct VideoConfig final
   int iLog = 0;           // CONF_ bits
   int iSaveTargetId = 0;  // TODO: Should be dropped
   u32 iMissingColorValue = 0;
-  bool bFastTextureSampling = false;
 
   // Stereoscopy
   StereoMode stereo_mode{};
@@ -232,9 +231,6 @@ struct VideoConfig final
     bool bSupportsDepthReadback = false;
     bool bSupportsShaderBinaries = false;
     bool bSupportsPipelineCacheData = false;
-    bool bSupportsCoarseDerivatives = false;
-    bool bSupportsTextureQueryLevels = false;
-    bool bSupportsLodBiasInSampler = false;
   } backend_info;
 
   // Utility
@@ -248,16 +244,6 @@ struct VideoConfig final
     return backend_info.bSupportsGPUTextureDecoding && bEnableGPUTextureDecoding;
   }
   bool UseVertexRounding() const { return bVertexRounding && iEFBScale != 1; }
-  bool ManualTextureSamplingWithHiResTextures() const
-  {
-    // Hi-res textures (including hi-res EFB copies, but not native-resolution EFB copies at higher
-    // internal resolutions) breaks the wrapping logic used by manual texture sampling.
-    if (bFastTextureSampling)
-      return false;
-    if (iEFBScale != 1 && bCopyEFBScaled)
-      return true;
-    return bHiresTextures;
-  }
   bool UsingUberShaders() const;
   u32 GetShaderCompilerThreads() const;
   u32 GetShaderPrecompilerThreads() const;
diff --git a/Source/Core/VideoCommon/VideoState.cpp b/Source/Core/VideoCommon/VideoState.cpp
index c348649..f954ca7 100644
--- a/Source/Core/VideoCommon/VideoState.cpp
+++ b/Source/Core/VideoCommon/VideoState.cpp
@@ -1,8 +1,6 @@
 // Copyright 2008 Dolphin Emulator Project
 // SPDX-License-Identifier: GPL-2.0-or-later
 
-#include "VideoCommon/VideoState.h"
-
 #include <cstring>
 
 #include "Common/ChunkFile.h"
@@ -15,11 +13,11 @@
 #include "VideoCommon/PixelEngine.h"
 #include "VideoCommon/PixelShaderManager.h"
 #include "VideoCommon/RenderBase.h"
-#include "VideoCommon/TMEM.h"
 #include "VideoCommon/TextureCacheBase.h"
 #include "VideoCommon/TextureDecoder.h"
 #include "VideoCommon/VertexManagerBase.h"
 #include "VideoCommon/VertexShaderManager.h"
+#include "VideoCommon/VideoState.h"
 #include "VideoCommon/XFMemory.h"
 
 void VideoCommon_DoState(PointerWrap& p)
@@ -48,10 +46,6 @@ void VideoCommon_DoState(PointerWrap& p)
   p.DoArray(texMem);
   p.DoMarker("texMem");
 
-  // TMEM
-  TMEM::DoState(p);
-  p.DoMarker("TMEM");
-
   // FIFO
   Fifo::DoState(p);
   p.DoMarker("Fifo");
-- 
2.34.1

