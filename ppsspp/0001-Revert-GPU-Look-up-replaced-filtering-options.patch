From c99d26a8609befa031081af65cdce8eaf6c529be Mon Sep 17 00:00:00 2001
From: Phantom X <PhantomX@users.noreply.github.com>
Date: Sun, 28 Feb 2021 20:04:53 -0300
Subject: [PATCH] Revert GPU: Look up replaced filtering options

Revert commit 82a7a264096560c6f1e244712bb8e091532a4f1d
---
 GPU/Common/TextureCacheCommon.cpp | 58 ++++++++++++-------------------
 GPU/Common/TextureCacheCommon.h   |  2 +-
 GPU/D3D11/TextureCacheD3D11.cpp   |  2 +-
 GPU/Directx9/TextureCacheDX9.cpp  |  2 +-
 GPU/GLES/TextureCacheGLES.cpp     |  2 +-
 GPU/Vulkan/TextureCacheVulkan.cpp |  2 +-
 6 files changed, 28 insertions(+), 40 deletions(-)

diff --git a/GPU/Common/TextureCacheCommon.cpp b/GPU/Common/TextureCacheCommon.cpp
index 47dcf6d..180cbfa 100644
--- a/GPU/Common/TextureCacheCommon.cpp
+++ b/GPU/Common/TextureCacheCommon.cpp
@@ -147,7 +147,7 @@ static int TexLog2(float delta) {
 	return useful - 127 * 256;
 }
 
-SamplerCacheKey TextureCacheCommon::GetSamplingParams(int maxLevel, const TexCacheEntry *entry) {
+SamplerCacheKey TextureCacheCommon::GetSamplingParams(int maxLevel, u32 texAddr) {
 	SamplerCacheKey key;
 
 	int minFilt = gstate.texfilter & 0x7;
@@ -214,49 +214,37 @@ SamplerCacheKey TextureCacheCommon::GetSamplingParams(int maxLevel, const TexCac
 	}
 
 	// Video bilinear override
-	if (!key.magFilt && entry != nullptr && IsVideo(entry->addr)) {
+	if (!key.magFilt && texAddr != 0 && IsVideo(texAddr)) {
 		// Enforce bilinear filtering on magnification.
 		key.magFilt = 1;
 	}
 
-	// Filtering overrides from replacements or settings.
-	TextureFiltering forceFiltering = TEX_FILTER_AUTO;
-	u64 cachekey = replacer_.Enabled() ? entry->CacheKey() : 0;
-	if (!replacer_.Enabled() || !replacer_.FindFiltering(cachekey, entry->fullhash, &forceFiltering)) {
-		switch (g_Config.iTexFiltering) {
-		case TEX_FILTER_AUTO:
-			// Follow what the game wants. We just do a single heuristic change to avoid bleeding of wacky color test colors
-			// in higher resolution (used by some games for sprites, and they accidentally have linear filter on).
-			if (gstate.isModeThrough() && g_Config.iInternalResolution != 1) {
-				bool uglyColorTest = gstate.isColorTestEnabled() && !IsColorTestTriviallyTrue() && gstate.getColorTestRef() != 0;
-				if (uglyColorTest)
-					forceFiltering = TEX_FILTER_FORCE_NEAREST;
-			}
-			break;
-		case TEX_FILTER_FORCE_LINEAR:
-			// Override to linear filtering if there's no alpha or color testing going on.
-			if ((!gstate.isColorTestEnabled() || IsColorTestTriviallyTrue()) &&
-				(!gstate.isAlphaTestEnabled() || IsAlphaTestTriviallyTrue())) {
-				forceFiltering = TEX_FILTER_FORCE_LINEAR;
+	// Filtering overrides
+	switch (g_Config.iTexFiltering) {
+	case TEX_FILTER_AUTO:
+		// Follow what the game wants. We just do a single heuristic change to avoid bleeding of wacky color test colors
+		// in higher resolution (used by some games for sprites, and they accidentally have linear filter on).
+		if (gstate.isModeThrough() && g_Config.iInternalResolution != 1) {
+			bool uglyColorTest = gstate.isColorTestEnabled() && !IsColorTestTriviallyTrue() && gstate.getColorTestRef() != 0;
+			if (uglyColorTest) {
+				// Force to nearest.
+				key.magFilt = 0;
+				key.minFilt = 0;
 			}
-			break;
-		case TEX_FILTER_FORCE_NEAREST:
-		default:
-			// Just force to nearest without checks. Safe (but ugly).
-			forceFiltering = TEX_FILTER_FORCE_NEAREST;
-			break;
 		}
-	}
-
-	switch (forceFiltering) {
-	case TEX_FILTER_AUTO:
 		break;
 	case TEX_FILTER_FORCE_LINEAR:
-		key.magFilt = 1;
-		key.minFilt = 1;
-		key.mipFilt = 1;
+		// Override to linear filtering if there's no alpha or color testing going on.
+		if ((!gstate.isColorTestEnabled() || IsColorTestTriviallyTrue()) &&
+			(!gstate.isAlphaTestEnabled() || IsAlphaTestTriviallyTrue())) {
+			key.magFilt = 1;
+			key.minFilt = 1;
+			key.mipFilt = 1;
+		}
 		break;
 	case TEX_FILTER_FORCE_NEAREST:
+	default:
+		// Just force to nearest without checks. Safe (but ugly).
 		key.magFilt = 0;
 		key.minFilt = 0;
 		break;
@@ -266,7 +254,7 @@ SamplerCacheKey TextureCacheCommon::GetSamplingParams(int maxLevel, const TexCac
 }
 
 SamplerCacheKey TextureCacheCommon::GetFramebufferSamplingParams(u16 bufferWidth, u16 bufferHeight) {
-	SamplerCacheKey key = GetSamplingParams(0, nullptr);
+	SamplerCacheKey key = GetSamplingParams(0, 0);
 
 	// Kill any mipmapping settings.
 	key.mipEnable = false;
diff --git a/GPU/Common/TextureCacheCommon.h b/GPU/Common/TextureCacheCommon.h
index 9b16ade..79eac7b 100644
--- a/GPU/Common/TextureCacheCommon.h
+++ b/GPU/Common/TextureCacheCommon.h
@@ -285,7 +285,7 @@ class TextureCacheCommon {
 
 	u32 EstimateTexMemoryUsage(const TexCacheEntry *entry);
 
-	SamplerCacheKey GetSamplingParams(int maxLevel, const TexCacheEntry *entry);
+	SamplerCacheKey GetSamplingParams(int maxLevel, u32 texAddr);
 	SamplerCacheKey GetFramebufferSamplingParams(u16 bufferWidth, u16 bufferHeight);
 	void UpdateMaxSeenV(TexCacheEntry *entry, bool throughMode);
 
diff --git a/GPU/D3D11/TextureCacheD3D11.cpp b/GPU/D3D11/TextureCacheD3D11.cpp
index 2fde747..7fd40e2 100644
--- a/GPU/D3D11/TextureCacheD3D11.cpp
+++ b/GPU/D3D11/TextureCacheD3D11.cpp
@@ -229,7 +229,7 @@ void TextureCacheD3D11::BindTexture(TexCacheEntry *entry) {
 		lastBoundTexture = textureView;
 	}
 	int maxLevel = (entry->status & TexCacheEntry::STATUS_BAD_MIPS) ? 0 : entry->maxLevel;
-	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry);
+	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry->addr);
 	ID3D11SamplerState *state = samplerCache_.GetOrCreateSampler(device_, samplerKey);
 	context_->PSSetSamplers(0, 1, &state);
 }
diff --git a/GPU/Directx9/TextureCacheDX9.cpp b/GPU/Directx9/TextureCacheDX9.cpp
index 9475424..a38df74 100644
--- a/GPU/Directx9/TextureCacheDX9.cpp
+++ b/GPU/Directx9/TextureCacheDX9.cpp
@@ -200,7 +200,7 @@ void TextureCacheDX9::BindTexture(TexCacheEntry *entry) {
 		lastBoundTexture = texture;
 	}
 	int maxLevel = (entry->status & TexCacheEntry::STATUS_BAD_MIPS) ? 0 : entry->maxLevel;
-	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry);
+	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry->addr);
 	ApplySamplingParams(samplerKey);
 }
 
diff --git a/GPU/GLES/TextureCacheGLES.cpp b/GPU/GLES/TextureCacheGLES.cpp
index d53d180..d055b64 100644
--- a/GPU/GLES/TextureCacheGLES.cpp
+++ b/GPU/GLES/TextureCacheGLES.cpp
@@ -232,7 +232,7 @@ void TextureCacheGLES::BindTexture(TexCacheEntry *entry) {
 		lastBoundTexture = entry->textureName;
 	}
 	int maxLevel = (entry->status & TexCacheEntry::STATUS_BAD_MIPS) ? 0 : entry->maxLevel;
-	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry);
+	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry->addr);
 	ApplySamplingParams(samplerKey);
 	gstate_c.SetUseShaderDepal(false);
 }
diff --git a/GPU/Vulkan/TextureCacheVulkan.cpp b/GPU/Vulkan/TextureCacheVulkan.cpp
index ecb7209..dd3986d 100644
--- a/GPU/Vulkan/TextureCacheVulkan.cpp
+++ b/GPU/Vulkan/TextureCacheVulkan.cpp
@@ -523,7 +523,7 @@ void TextureCacheVulkan::BindTexture(TexCacheEntry *entry) {
 	entry->vkTex->Touch();
 	imageView_ = entry->vkTex->GetImageView();
 	int maxLevel = (entry->status & TexCacheEntry::STATUS_BAD_MIPS) ? 0 : entry->maxLevel;
-	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry);
+	SamplerCacheKey samplerKey = GetSamplingParams(maxLevel, entry->addr);
 	curSampler_ = samplerCache_.GetOrCreateSampler(samplerKey);
 	drawEngine_->SetDepalTexture(VK_NULL_HANDLE);
 	gstate_c.SetUseShaderDepal(false);
-- 
2.29.2

