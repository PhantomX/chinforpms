From 4a1d92339ad254501d788deb0fc74d1a1ce5178a Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 12 Mar 2021 18:27:41 +0100
Subject: [PATCH 01/16] winex11.drv: Store swapchain surfaces associations.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 21 ++++++++++++++++++++-
 1 file changed, 20 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 39a76c0..7a7e57d 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -52,6 +52,7 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 static pthread_mutex_t vulkan_mutex;
 
 static XContext vulkan_hwnd_context;
+static XContext vulkan_swapchain_context;
 
 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
 
@@ -232,6 +233,8 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
 {
     struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
+    VkResult result;
+
     TRACE("%p %p %p %p\n", device, create_info, allocator, swapchain);
 
     if (allocator)
@@ -243,7 +246,14 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->host_surface;
 
-    return pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
+    if (result == VK_SUCCESS)
+    {
+        pthread_mutex_lock(&vulkan_mutex);
+        XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
+        pthread_mutex_unlock(&vulkan_mutex);
+    }
+    return result;
 }
 
 static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
@@ -341,12 +351,20 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
 static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
          const VkAllocationCallbacks *allocator)
 {
+    struct wine_vk_surface *surface;
+
     TRACE("%p, 0x%s %p\n", device, wine_dbgstr_longlong(swapchain), allocator);
 
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
     pvkDestroySwapchainKHR(device, swapchain, NULL /* allocator */);
+
+    pthread_mutex_lock(&vulkan_mutex);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+        wine_vk_surface_release(surface);
+    XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
+    pthread_mutex_unlock(&vulkan_mutex);
 }
 
 static VkResult X11DRV_vkEnumerateInstanceExtensionProperties(const char *layer_name,
@@ -489,6 +507,7 @@ UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, struct vulkan_funcs *
 #undef LOAD_FUNCPTR
 
     vulkan_hwnd_context = XUniqueContext();
+    vulkan_swapchain_context = XUniqueContext();
     *driver_funcs = vulkan_funcs;
     return STATUS_SUCCESS;
 }
-- 
2.44.0

From 9c6c5f7e155a4575156d9054d09d6b98cb34375c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 22 Apr 2021 23:38:16 +0200
Subject: [PATCH 02/16] winex11.drv: Hook vkAcquireNextImage(2)KHR functions.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
---
 dlls/win32u/vulkan.c         |  3 +++
 dlls/winemac.drv/vulkan.c    |  2 ++
 dlls/winevulkan/make_vulkan  |  2 ++
 dlls/winex11.drv/vulkan.c    | 19 +++++++++++++++++++
 include/wine/vulkan_driver.h |  2 ++
 5 files changed, 28 insertions(+)

diff --git a/dlls/win32u/vulkan.c b/dlls/win32u/vulkan.c
index 853e0a9..2cefe09 100644
--- a/dlls/win32u/vulkan.c
+++ b/dlls/win32u/vulkan.c
@@ -63,6 +63,9 @@ static void *win32u_vkGetInstanceProcAddr( VkInstance instance, const char *name
 {
     TRACE( "instance %p, name %s\n", instance, debugstr_a(name) );
 
+    if (!strcmp( name, "AcquireNextImage2KHR")) return vulkan_funcs.p_vkAcquireNextImage2KHR;
+    if (!strcmp( name, "AcquireNextImageKHR")) return vulkan_funcs.p_vkAcquireNextImageKHR;
+
     if (!strcmp( name, "vkCreateInstance" )) return vulkan_funcs.p_vkCreateInstance;
     if (!strcmp( name, "vkEnumerateInstanceExtensionProperties" )) return vulkan_funcs.p_vkEnumerateInstanceExtensionProperties;
 
diff --git a/dlls/winemac.drv/vulkan.c b/dlls/winemac.drv/vulkan.c
index 52928ec..1d0775b 100644
--- a/dlls/winemac.drv/vulkan.c
+++ b/dlls/winemac.drv/vulkan.c
@@ -426,6 +426,8 @@ static VkSurfaceKHR macdrv_wine_get_host_surface(VkSurfaceKHR surface)
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    NULL,
+    NULL,
     macdrv_vkCreateInstance,
     macdrv_vkCreateSwapchainKHR,
     macdrv_vkCreateWin32SurfaceKHR,
diff --git a/dlls/winevulkan/make_vulkan b/dlls/winevulkan/make_vulkan
index 809591b..76c9351 100755
--- a/dlls/winevulkan/make_vulkan
+++ b/dlls/winevulkan/make_vulkan
@@ -196,6 +196,8 @@ FUNCTION_OVERRIDES = {
 # functions for which a user driver entry must be generated
 USER_DRIVER_FUNCS = {
     "vkCreateInstance",
+    "vkAcquireNextImageKHR",
+    "vkAcquireNextImage2KHR",
     "vkCreateSwapchainKHR",
     "vkCreateWin32SurfaceKHR",
     "vkDestroyInstance",
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 7a7e57d..00293a1 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -77,6 +77,7 @@ typedef struct VkXlibSurfaceCreateInfoKHR
     Window window;
 } VkXlibSurfaceCreateInfoKHR;
 
+static VkResult (*pvkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
 static VkResult (*pvkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
 static VkResult (*pvkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
 static VkResult (*pvkCreateXlibSurfaceKHR)(VkInstance, const VkXlibSurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
@@ -227,6 +228,21 @@ static VkResult X11DRV_vkCreateInstance(const VkInstanceCreateInfo *create_info,
     return res;
 }
 
+static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
+        VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
+        VkFence fence, uint32_t *image_index)
+{
+    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+}
+
+static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
+        const VkAcquireNextImageInfoKHR *acquire_info, uint32_t *image_index)
+{
+    static int once;
+    if (!once++) FIXME("Emulating vkGetPhysicalDeviceSurfaceCapabilities2KHR with vkGetPhysicalDeviceSurfaceCapabilitiesKHR, pNext is ignored.\n");
+    return X11DRV_vkAcquireNextImageKHR(device, acquire_info->swapchain, acquire_info->timeout, acquire_info->semaphore, acquire_info->fence, image_index);
+}
+
 static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
@@ -467,6 +483,8 @@ static VkSurfaceKHR X11DRV_wine_get_host_surface( VkSurfaceKHR surface )
 
 static const struct vulkan_funcs vulkan_funcs =
 {
+    X11DRV_vkAcquireNextImage2KHR,
+    X11DRV_vkAcquireNextImageKHR,
     X11DRV_vkCreateInstance,
     X11DRV_vkCreateSwapchainKHR,
     X11DRV_vkCreateWin32SurfaceKHR,
@@ -494,6 +512,7 @@ UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, struct vulkan_funcs *
     init_recursive_mutex( &vulkan_mutex );
 
 #define LOAD_FUNCPTR( f ) if (!(p##f = dlsym( vulkan_handle, #f ))) return STATUS_PROCEDURE_NOT_FOUND;
+    LOAD_FUNCPTR( vkAcquireNextImageKHR );
     LOAD_FUNCPTR( vkCreateInstance );
     LOAD_FUNCPTR( vkCreateSwapchainKHR );
     LOAD_FUNCPTR( vkCreateXlibSurfaceKHR );
diff --git a/include/wine/vulkan_driver.h b/include/wine/vulkan_driver.h
index 6c72548..ef1668b 100644
--- a/include/wine/vulkan_driver.h
+++ b/include/wine/vulkan_driver.h
@@ -29,6 +29,8 @@ struct vulkan_funcs
      * needs to provide. Other function calls will be provided indirectly by dispatch
      * tables part of dispatchable Vulkan objects such as VkInstance or vkDevice.
      */
+    VkResult (*p_vkAcquireNextImage2KHR)(VkDevice, const VkAcquireNextImageInfoKHR *, uint32_t *);
+    VkResult (*p_vkAcquireNextImageKHR)(VkDevice, VkSwapchainKHR, uint64_t, VkSemaphore, VkFence, uint32_t *);
     VkResult (*p_vkCreateInstance)(const VkInstanceCreateInfo *, const VkAllocationCallbacks *, VkInstance *);
     VkResult (*p_vkCreateSwapchainKHR)(VkDevice, const VkSwapchainCreateInfoKHR *, const VkAllocationCallbacks *, VkSwapchainKHR *);
     VkResult (*p_vkCreateWin32SurfaceKHR)(VkInstance, const VkWin32SurfaceCreateInfoKHR *, const VkAllocationCallbacks *, VkSurfaceKHR *);
-- 
2.44.0

From c766d79d4092c1b3c842ebf44d9ba0d0baf509fa Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:23:49 +0200
Subject: [PATCH 03/16] winex11.drv: Rename X11DRV_FLUSH_GL_DRAWABLE to
 X11DRV_PRESENT_DRAWABLE.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/init.c   |  8 ++++----
 dlls/winex11.drv/opengl.c | 40 +++++++++++++++++++--------------------
 dlls/winex11.drv/x11drv.h |  8 ++++----
 3 files changed, 28 insertions(+), 28 deletions(-)

diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index c5f9234..7d93fb7 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -243,16 +243,16 @@ static INT X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOID in_d
                     return TRUE;
                 }
                 break;
-            case X11DRV_FLUSH_GL_DRAWABLE:
-                if (in_count >= sizeof(struct x11drv_escape_flush_gl_drawable))
+            case X11DRV_PRESENT_DRAWABLE:
+                if (in_count >= sizeof(struct x11drv_escape_present_drawable))
                 {
-                    const struct x11drv_escape_flush_gl_drawable *data = in_data;
+                    const struct x11drv_escape_present_drawable *data = in_data;
                     RECT rect = physDev->dc_rect;
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
                     XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->gl_drawable, physDev->drawable, physDev->gc,
+                    XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
                                0, 0, rect.right, rect.bottom,
                                physDev->dc_rect.left, physDev->dc_rect.top );
                     add_device_bounds( physDev, &rect );
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index 02a4758..c28a974 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1980,20 +1980,20 @@ static BOOL glxdrv_wglShareLists(struct wgl_context *org, struct wgl_context *de
 
 static void wglFinish(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -2001,26 +2001,26 @@ static void wglFinish(void)
     }
 
     pglFinish();
-    if (escape.gl_drawable)
+    if (escape.drawable)
         NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
 static void wglFlush(void)
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = FALSE;
 
     if ((gl = get_gl_drawable( NtUserWindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
         {
-        case DC_GL_PIXMAP_WIN: escape.gl_drawable = gl->pixmap; break;
-        case DC_GL_CHILD_WIN:  escape.gl_drawable = gl->window; break;
+        case DC_GL_PIXMAP_WIN: escape.drawable = gl->pixmap; break;
+        case DC_GL_CHILD_WIN:  escape.drawable = gl->window; break;
         default: break;
         }
         sync_context(ctx);
@@ -2028,7 +2028,7 @@ static void wglFlush(void)
     }
 
     pglFlush();
-    if (escape.gl_drawable)
+    if (escape.drawable)
         NtGdiExtEscape( ctx->hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
 }
 
@@ -3348,15 +3348,15 @@ static void X11DRV_WineGL_LoadExtensions(void)
  */
 static BOOL glxdrv_wglSwapBuffers( HDC hdc )
 {
-    struct x11drv_escape_flush_gl_drawable escape;
+    struct x11drv_escape_present_drawable escape;
     struct gl_drawable *gl;
     struct wgl_context *ctx = NtCurrentTeb()->glContext;
     INT64 ust, msc, sbc, target_sbc = 0;
 
     TRACE("(%p)\n", hdc);
 
-    escape.code = X11DRV_FLUSH_GL_DRAWABLE;
-    escape.gl_drawable = 0;
+    escape.code = X11DRV_PRESENT_DRAWABLE;
+    escape.drawable = 0;
     escape.flush = !pglXWaitForSbcOML;
 
     if (!(gl = get_gl_drawable( NtUserWindowFromDC( hdc ), hdc )))
@@ -3377,7 +3377,7 @@ static BOOL glxdrv_wglSwapBuffers( HDC hdc )
     {
     case DC_GL_PIXMAP_WIN:
         if (ctx) sync_context( ctx );
-        escape.gl_drawable = gl->pixmap;
+        escape.drawable = gl->pixmap;
         if (ctx && pglXCopySubBufferMESA) {
             /* (glX)SwapBuffers has an implicit glFlush effect, however
              * GLX_MESA_copy_sub_buffer doesn't. Make sure GL is flushed before
@@ -3398,10 +3398,10 @@ static BOOL glxdrv_wglSwapBuffers( HDC hdc )
     case DC_GL_WINDOW:
     case DC_GL_CHILD_WIN:
         if (ctx) sync_context( ctx );
-        if (gl->type == DC_GL_CHILD_WIN) escape.gl_drawable = gl->window;
+        if (gl->type == DC_GL_CHILD_WIN) escape.drawable = gl->window;
         /* fall through */
     default:
-        if (ctx && escape.gl_drawable && pglXSwapBuffersMscOML)
+        if (ctx && escape.drawable && pglXSwapBuffersMscOML)
         {
             pglFlush();
             target_sbc = pglXSwapBuffersMscOML( gdi_display, gl->drawable, 0, 0, 0 );
@@ -3411,12 +3411,12 @@ static BOOL glxdrv_wglSwapBuffers( HDC hdc )
         break;
     }
 
-    if (ctx && escape.gl_drawable && pglXWaitForSbcOML)
+    if (ctx && escape.drawable && pglXWaitForSbcOML)
         pglXWaitForSbcOML( gdi_display, gl->drawable, target_sbc, &ust, &msc, &sbc );
 
     release_gl_drawable( gl );
 
-    if (escape.gl_drawable)
+    if (escape.drawable)
         NtGdiExtEscape( ctx ? ctx->hdc : hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (LPSTR)&escape, 0, NULL );
     return TRUE;
 }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 798ce07..b6d54b6 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -347,7 +347,7 @@ enum x11drv_escape_codes
     X11DRV_GET_DRAWABLE,     /* get current drawable for a DC */
     X11DRV_START_EXPOSURES,  /* start graphics exposures */
     X11DRV_END_EXPOSURES,    /* end graphics exposures */
-    X11DRV_FLUSH_GL_DRAWABLE, /* flush changes made to the gl drawable */
+    X11DRV_PRESENT_DRAWABLE, /* flush changes made to the gl drawable */
     X11DRV_FLUSH_GDI_DISPLAY /* flush the gdi display */
 };
 
@@ -367,10 +367,10 @@ struct x11drv_escape_get_drawable
     int                      pixel_format; /* internal GL pixel format */
 };
 
-struct x11drv_escape_flush_gl_drawable
+struct x11drv_escape_present_drawable
 {
-    enum x11drv_escape_codes code;         /* escape code (X11DRV_FLUSH_GL_DRAWABLE) */
-    Drawable                 gl_drawable;  /* GL drawable */
+    enum x11drv_escape_codes code;         /* escape code (X11DRV_PRESENT_DRAWABLE) */
+    Drawable                 drawable;     /* GL / VK drawable */
     BOOL                     flush;        /* flush X11 before copying */
 };
 
-- 
2.44.0

From 01655bcd959255ff58c67ed8348c5ec13a74236d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sun, 17 Apr 2022 22:26:59 +0200
Subject: [PATCH 04/16] winex11.drv: Support child window vulkan rendering.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 85 ++++++++++++++++++++++++++++++++++-----
 dlls/winex11.drv/window.c | 17 ++++++++
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 94 insertions(+), 9 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 00293a1..9662e3e 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -37,6 +37,7 @@
 
 #include "wine/debug.h"
 #include "x11drv.h"
+#include "xcomposite.h"
 
 #define VK_NO_PROTOTYPES
 #define WINE_VK_HOST
@@ -64,6 +65,8 @@ struct wine_vk_surface
     struct list entry;
     Window window;
     VkSurfaceKHR host_surface;
+    BOOL offscreen; /* drawable is offscreen */
+    HDC hdc;
     HWND hwnd;
     DWORD hwnd_thread_id;
 };
@@ -174,12 +177,49 @@ void wine_vk_surface_destroy(HWND hwnd)
     pthread_mutex_lock(&vulkan_mutex);
     if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
     {
+        hdc = surface->hdc;
         surface->hwnd_thread_id = 0;
-        surface->hwnd = NULL;
+        surface->hwnd = 0;
+        surface->hdc = 0;
         wine_vk_surface_release(surface);
     }
     XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     pthread_mutex_unlock(&vulkan_mutex);
+    if (hdc) NtUserReleaseDC(hwnd, hdc);
+}
+
+static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
+{
+#ifdef SONAME_LIBXCOMPOSITE
+    if (usexcomposite)
+    {
+        if (!surface->offscreen && offscreen)
+        {
+            FIXME("Redirecting vulkan surface offscreen, expect degraded performance.\n");
+            pXCompositeRedirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        else if (surface->offscreen && !offscreen)
+        {
+            FIXME("Putting vulkan surface back onscreen, expect standard performance.\n");
+            pXCompositeUnredirectWindow(gdi_display, surface->window, CompositeRedirectManual);
+        }
+        surface->offscreen = offscreen;
+        return TRUE;
+    }
+#endif
+
+    if (offscreen) FIXME("Application requires child window rendering, which is not implemented yet!\n");
+    surface->offscreen = offscreen;
+    return !offscreen;
+}
+
+void sync_vk_surface(HWND hwnd, BOOL known_child)
+{
+    struct wine_vk_surface *surface;
+    pthread_mutex_lock(&vulkan_mutex);
+    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+        wine_vk_surface_set_offscreen(surface, known_child);
+    pthread_mutex_unlock(&vulkan_mutex);
 }
 
 void vulkan_thread_detach(void)
@@ -232,7 +272,30 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
-    return pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    struct x11drv_escape_present_drawable escape;
+    struct wine_vk_surface *surface = NULL;
+    VkResult result;
+    HDC hdc = 0;
+
+    pthread_mutex_lock(&vulkan_mutex);
+    if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        wine_vk_surface_grab(surface);
+        hdc = surface->hdc;
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+
+    result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
+    if (result == VK_SUCCESS && hdc && surface && surface->offscreen)
+    {
+        escape.code = X11DRV_PRESENT_DRAWABLE;
+        escape.drawable = surface->window;
+        escape.flush = TRUE;
+        NtGdiExtEscape(hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+    }
+
+    if (surface) wine_vk_surface_release(surface);
+    return result;
 }
 
 static VkResult X11DRV_vkAcquireNextImage2KHR(VkDevice device,
@@ -285,19 +348,13 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (allocator)
         FIXME("Support for allocation callbacks not implemented yet\n");
 
-    /* TODO: support child window rendering. */
-    if (NtUserGetAncestor( create_info->hwnd, GA_PARENT ) != NtUserGetDesktopWindow())
-    {
-        FIXME("Application requires child window rendering, which is not implemented yet!\n");
-        return VK_ERROR_INCOMPATIBLE_DRIVER;
-    }
-
     x11_surface = calloc(1, sizeof(*x11_surface));
     if (!x11_surface)
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
     x11_surface->ref = 1;
     x11_surface->hwnd = create_info->hwnd;
+    x11_surface->hdc = NtUserGetDCEx(x11_surface->hwnd, 0, DCX_USESTYLE);
     x11_surface->window = create_client_window( create_info->hwnd, &default_visual );
     x11_surface->hwnd_thread_id = NtUserGetWindowThread( x11_surface->hwnd, NULL );
 
@@ -310,6 +367,16 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         goto err;
     }
 
+    if (create_info->hwnd && (NtUserGetWindowRelative(create_info->hwnd, GW_CHILD) ||
+                              NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow()))
+    {
+        if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
+        {
+            res = VK_ERROR_INCOMPATIBLE_DRIVER;
+            goto err;
+        }
+    }
+
     create_info_host.sType = VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR;
     create_info_host.pNext = NULL;
     create_info_host.flags = 0; /* reserved */
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index bc6b376..4322b3e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1868,6 +1868,16 @@ void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
 {
     struct x11drv_win_data *data;
     DWORD changed = style->styleNew ^ style->styleOld;
+    HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
+
+    if (offset == GWL_STYLE && (changed & WS_CHILD))
+    {
+        if (NtUserGetWindowRelative( parent, GW_CHILD ) ||
+            NtUserGetAncestor( parent, GA_PARENT ) != NtUserGetDesktopWindow())
+            sync_vk_surface( parent, TRUE );
+        else
+            sync_vk_surface( parent, FALSE );
+    }
 
     if (hwnd == NtUserGetDesktopWindow()) return;
     if (!(data = get_win_data( hwnd ))) return;
@@ -1894,6 +1904,11 @@ void X11DRV_DestroyWindow( HWND hwnd )
 {
     struct x11drv_thread_data *thread_data = x11drv_thread_data();
     struct x11drv_win_data *data;
+    HWND parent = NtUserGetAncestor( hwnd, GA_PARENT );
+
+    if (!NtUserGetWindowRelative( parent, GW_CHILD ) &&
+        NtUserGetAncestor( parent, GA_PARENT ) == NtUserGetDesktopWindow())
+        sync_vk_surface( parent, FALSE );
 
     if (!(data = get_win_data( hwnd ))) return;
 
@@ -2131,6 +2146,7 @@ static struct x11drv_win_data *X11DRV_create_win_data( HWND hwnd, const RECT *wi
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     display = thread_init_display();
     init_clip_window();  /* make sure the clip window is initialized in this thread */
@@ -2607,6 +2623,7 @@ done:
      * that will need clipping support.
      */
     sync_gl_drawable( parent, TRUE );
+    sync_vk_surface( parent, TRUE );
 
     fetch_icon_data( hwnd, 0, 0 );
 }
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index b6d54b6..aa1dcc3 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -654,6 +654,7 @@ extern void sync_gl_drawable( HWND hwnd, BOOL known_child );
 extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
 extern void destroy_gl_drawable( HWND hwnd );
 extern void wine_vk_surface_destroy( HWND hwnd );
+extern void sync_vk_surface( HWND hwnd, BOOL known_child );
 extern void vulkan_thread_detach(void);
 
 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set );
-- 
2.44.0

From eeab4429b2f6543f01cd8133989d80710c5c6dea Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 7 May 2022 01:00:23 +0200
Subject: [PATCH 05/16] winex11.drv: Wait on vkAcquireNextImageKHR before
 flushing.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

To prevent tearing, when present mode is mailbox or fifo.

Based on a patch from Felix HÃ¤dicke <felixhaedicke@web.de>.
Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 35 +++++++++++++++++++++++++++++++++++
 1 file changed, 35 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 9662e3e..2fbd890 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -65,6 +65,7 @@ struct wine_vk_surface
     struct list entry;
     Window window;
     VkSurfaceKHR host_surface;
+    VkPresentModeKHR present_mode;
     BOOL offscreen; /* drawable is offscreen */
     HDC hdc;
     HWND hwnd;
@@ -91,6 +92,9 @@ static VkResult (*pvkEnumerateInstanceExtensionProperties)(const char *, uint32_
 static VkBool32 (*pvkGetPhysicalDeviceXlibPresentationSupportKHR)(VkPhysicalDevice, uint32_t, Display *, VisualID);
 static VkResult (*pvkGetSwapchainImagesKHR)(VkDevice, VkSwapchainKHR, uint32_t *, VkImage *);
 static VkResult (*pvkQueuePresentKHR)(VkQueue, const VkPresentInfoKHR *);
+static VkResult (*pvkWaitForFences)(VkDevice device, uint32_t fenceCount, const VkFence *pFences, VkBool32 waitAll, uint64_t timeout);
+static VkResult (*pvkCreateFence)(VkDevice device, const VkFenceCreateInfo *pCreateInfo, const VkAllocationCallbacks *pAllocator, VkFence *pFence);
+static void (*pvkDestroyFence)(VkDevice device, VkFence fence, const VkAllocationCallbacks *pAllocator);
 
 static const struct vulkan_funcs vulkan_funcs;
 
@@ -272,9 +276,12 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         VkSwapchainKHR swapchain, uint64_t timeout, VkSemaphore semaphore,
         VkFence fence, uint32_t *image_index)
 {
+    static int once;
     struct x11drv_escape_present_drawable escape;
     struct wine_vk_surface *surface = NULL;
     VkResult result;
+    VkFence orig_fence;
+    BOOL wait_fence = FALSE;
     HDC hdc = 0;
 
     pthread_mutex_lock(&vulkan_mutex);
@@ -285,15 +292,35 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
     }
     pthread_mutex_unlock(&vulkan_mutex);
 
+    if (!surface || !surface->offscreen)
+        wait_fence = FALSE;
+    else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
+             surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
+        wait_fence = TRUE;
+
+    orig_fence = fence;
+    if (wait_fence && !fence)
+    {
+        VkFenceCreateInfo create_info;
+        create_info.sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO;
+        create_info.pNext = NULL;
+        create_info.flags = 0;
+        pvkCreateFence(device, &create_info, NULL, &fence);
+    }
+
     result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
     if (result == VK_SUCCESS && hdc && surface && surface->offscreen)
     {
+        if (wait_fence) pvkWaitForFences(device, 1, &fence, 0, timeout);
         escape.code = X11DRV_PRESENT_DRAWABLE;
         escape.drawable = surface->window;
         escape.flush = TRUE;
         NtGdiExtEscape(hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
+        if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+            if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
     }
 
+    if (fence != orig_fence) pvkDestroyFence(device, fence, NULL);
     if (surface) wine_vk_surface_release(surface);
     return result;
 }
@@ -325,6 +352,11 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->host_surface;
 
+    /* force fifo when running offscreen so the acquire fence is more likely to be vsynced */
+    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR)
+        create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
+    x11_surface->present_mode = create_info->presentMode;
+
     result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
     if (result == VK_SUCCESS)
     {
@@ -590,6 +622,9 @@ UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, struct vulkan_funcs *
     LOAD_FUNCPTR( vkGetPhysicalDeviceXlibPresentationSupportKHR );
     LOAD_FUNCPTR( vkGetSwapchainImagesKHR );
     LOAD_FUNCPTR( vkQueuePresentKHR );
+    LOAD_FUNCPTR( vkWaitForFences );
+    LOAD_FUNCPTR( vkCreateFence );
+    LOAD_FUNCPTR( vkDestroyFence );
 #undef LOAD_FUNCPTR
 
     vulkan_hwnd_context = XUniqueContext();
-- 
2.44.0

From e9c56b2dfa937b35434db5616ff083f5e1a6858d Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 7 May 2022 01:01:16 +0200
Subject: [PATCH 06/16] winex11.drv: Move Xfixes extension query to
 process_attach.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/clipboard.c   | 26 ++------------
 dlls/winex11.drv/x11drv.h      |  2 ++
 dlls/winex11.drv/x11drv_main.c | 63 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/xfixes.h      | 36 +++++++++++++++++++
 4 files changed, 103 insertions(+), 24 deletions(-)
 create mode 100644 dlls/winex11.drv/xfixes.h

diff --git a/dlls/winex11.drv/clipboard.c b/dlls/winex11.drv/clipboard.c
index 087e0aa..3714e15 100644
--- a/dlls/winex11.drv/clipboard.c
+++ b/dlls/winex11.drv/clipboard.c
@@ -83,6 +83,7 @@
 #include "ntstatus.h"
 #define WIN32_NO_STATUS
 #include "x11drv.h"
+#include "xfixes.h"
 
 #ifdef HAVE_X11_EXTENSIONS_XFIXES_H
 #include <X11/extensions/Xfixes.h>
@@ -199,7 +200,6 @@ static UINT rendered_formats;
 static ULONG last_clipboard_update;
 static struct clipboard_format **current_x11_formats;
 static unsigned int nb_current_x11_formats;
-static BOOL use_xfixes;
 
 Display *clipboard_display = NULL;
 
@@ -2170,28 +2170,6 @@ static BOOL selection_notify_event( HWND hwnd, XEvent *event )
 static void xfixes_init(void)
 {
 #ifdef SONAME_LIBXFIXES
-    typeof(XFixesSelectSelectionInput) *pXFixesSelectSelectionInput;
-    typeof(XFixesQueryExtension) *pXFixesQueryExtension;
-    typeof(XFixesQueryVersion) *pXFixesQueryVersion;
-
-    int event_base, error_base;
-    int major = 3, minor = 0;
-    void *handle;
-
-    handle = dlopen(SONAME_LIBXFIXES, RTLD_NOW);
-    if (!handle) return;
-
-    pXFixesQueryExtension = dlsym(handle, "XFixesQueryExtension");
-    if (!pXFixesQueryExtension) return;
-    pXFixesQueryVersion = dlsym(handle, "XFixesQueryVersion");
-    if (!pXFixesQueryVersion) return;
-    pXFixesSelectSelectionInput = dlsym(handle, "XFixesSelectSelectionInput");
-    if (!pXFixesSelectSelectionInput) return;
-
-    if (!pXFixesQueryExtension(clipboard_display, &event_base, &error_base))
-        return;
-    pXFixesQueryVersion(clipboard_display, &major, &minor);
-    use_xfixes = (major >= 1);
     if (!use_xfixes) return;
 
     pXFixesSelectSelectionInput(clipboard_display, import_window, x11drv_atom(CLIPBOARD),
@@ -2205,7 +2183,7 @@ static void xfixes_init(void)
                 XFixesSelectionWindowDestroyNotifyMask |
                 XFixesSelectionClientCloseNotifyMask);
     }
-    X11DRV_register_event_handler(event_base + XFixesSelectionNotify,
+    X11DRV_register_event_handler(xfixes_event_base + XFixesSelectionNotify,
             selection_notify_event, "XFixesSelectionNotify");
     TRACE("xfixes succesully initialized\n");
 #else
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index aa1dcc3..ec26e0e 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -446,6 +446,7 @@ extern BOOL grab_fullscreen;
 extern int keyboard_layout;
 extern BOOL keyboard_scancode_detect;
 extern BOOL usexcomposite;
+extern BOOL use_xfixes;
 extern BOOL managed_mode;
 extern BOOL decorated_mode;
 extern BOOL private_color_map;
@@ -453,6 +454,7 @@ extern int primary_monitor;
 extern int copy_default_colors;
 extern int alloc_system_colors;
 extern int xrender_error_base;
+extern int xfixes_event_base;
 extern char *process_name;
 extern Display *clipboard_display;
 extern WNDPROC client_foreign_window_proc;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 1b87fa2..9ed8894 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -50,6 +50,7 @@
 #include "x11drv.h"
 #include "winreg.h"
 #include "xcomposite.h"
+#include "xfixes.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "wine/list.h"
@@ -71,6 +72,7 @@ Window root_window;
 BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
+BOOL use_xfixes = FALSE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
@@ -87,6 +89,7 @@ BOOL shape_layered_windows = TRUE;
 int copy_default_colors = 128;
 int alloc_system_colors = 256;
 int xrender_error_base = 0;
+int xfixes_event_base = 0;
 char *process_name = NULL;
 WNDPROC client_foreign_window_proc = NULL;
 
@@ -666,6 +669,63 @@ sym_not_found:
 }
 #endif /* defined(SONAME_LIBXCOMPOSITE) */
 
+#ifdef SONAME_LIBXFIXES
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xfixes(void)
+{
+    int event, error, major = 3, minor = 0;
+    void *xfixes;
+
+    if (!(xfixes = dlopen(SONAME_LIBXFIXES, RTLD_NOW)))
+    {
+        WARN("Xfixes library %s not found, disabled.\n", SONAME_LIBXFIXES);
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym(xfixes, #f)))                          \
+    {                                                         \
+        WARN("Xfixes function %s not found, disabled\n", #f); \
+        dlclose(xfixes);                                      \
+        return;                                               \
+    }
+    LOAD_FUNCPTR(XFixesQueryExtension)
+    LOAD_FUNCPTR(XFixesQueryVersion)
+    LOAD_FUNCPTR(XFixesCreateRegion)
+    LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesSelectSelectionInput)
+#undef LOAD_FUNCPTR
+
+    if (!pXFixesQueryExtension(gdi_display, &event, &error))
+    {
+        WARN("Xfixes extension not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    if (!pXFixesQueryVersion(gdi_display, &major, &minor) ||
+        major < 2)
+    {
+        WARN("Xfixes version 2.0 not found, disabled.\n");
+        dlclose(xfixes);
+        return;
+    }
+
+    TRACE("Xfixes, error %d, event %d, version %d.%d found\n",
+          error, event, major, minor);
+    use_xfixes = TRUE;
+    xfixes_event_base = event;
+}
+#endif /* SONAME_LIBXFIXES */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -771,6 +831,9 @@ static NTSTATUS x11drv_init( void *arg )
     X11DRV_XF86VM_Init();
     /* initialize XRandR */
     X11DRV_XRandR_Init();
+#ifdef SONAME_LIBXFIXES
+    x11drv_load_xfixes();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
diff --git a/dlls/winex11.drv/xfixes.h b/dlls/winex11.drv/xfixes.h
new file mode 100644
index 0000000..684b5f4
--- /dev/null
+++ b/dlls/winex11.drv/xfixes.h
@@ -0,0 +1,36 @@
+/*
+ * Wine X11DRV Xfixes interface
+ *
+ * Copyright 2021 Rémi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __WINE_XFIXES_H
+#define __WINE_XFIXES_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#ifdef SONAME_LIBXFIXES
+#include <X11/extensions/Xfixes.h>
+#define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
+MAKE_FUNCPTR(XFixesQueryExtension)
+MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesSelectSelectionInput)
+#undef MAKE_FUNCPTR
+#endif /* defined(SONAME_LIBXFIXES) */
+
+#endif /* __WINE_XFIXES_H */
-- 
2.44.0

From 93fdb5a68d8572996eef5bf1f1458c9fd80c2f23 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 7 May 2022 01:01:50 +0200
Subject: [PATCH 07/16] winex11.drv: Use XPresentPixmap instead of XCopyArea
 when available.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 configure.ac                   | 13 ++++++++
 dlls/winex11.drv/init.c        | 34 +++++++++++++++++---
 dlls/winex11.drv/vulkan.c      |  9 ++++--
 dlls/winex11.drv/x11drv.h      |  1 +
 dlls/winex11.drv/x11drv_main.c | 58 ++++++++++++++++++++++++++++++++++
 dlls/winex11.drv/xfixes.h      |  3 ++
 dlls/winex11.drv/xpresent.h    | 36 +++++++++++++++++++++
 7 files changed, 147 insertions(+), 7 deletions(-)
 create mode 100644 dlls/winex11.drv/xpresent.h

diff --git a/configure.ac b/configure.ac
index 0db1a14..62afdc9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -72,6 +72,8 @@ AC_ARG_WITH(xinput,    AS_HELP_STRING([--without-xinput],[do not use the Xinput
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput_h=no; fi])
 AC_ARG_WITH(xinput2,   AS_HELP_STRING([--without-xinput2],[do not use the Xinput 2 extension]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_XInput2_h=no; fi])
+AC_ARG_WITH(xpresent,  AS_HELP_STRING([--without-xpresent],[do not use the Xpresent extension]),
+            [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xpresent_h=no; fi])
 AC_ARG_WITH(xrandr,    AS_HELP_STRING([--without-xrandr],[do not use Xrandr (multi-monitor support)]),
             [if test "x$withval" = "xno"; then ac_cv_header_X11_extensions_Xrandr_h=no; fi])
 AC_ARG_WITH(xrender,   AS_HELP_STRING([--without-xrender],[do not use the Xrender extension]),
@@ -1189,6 +1191,7 @@ then
                       X11/extensions/XShm.h \
                       X11/extensions/Xfixes.h \
                       X11/extensions/Xinerama.h \
+                      X11/extensions/Xpresent.h \
                       X11/extensions/Xrandr.h \
                       X11/extensions/Xrender.h \
                       X11/extensions/xf86vmode.h \
@@ -1292,6 +1295,16 @@ then
         WINE_NOTICE_WITH(xinerama,[test "x$ac_cv_lib_soname_Xinerama" = "x"],
                          [libxinerama ${notice_platform}development files not found, multi-monitor setups won't be supported.])
 
+        dnl *** Check for Xpresent extension
+        if test "$ac_cv_header_X11_extensions_Xpresent_h" = "yes"
+        then
+                AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <X11/Xlib.h>
+#include <X11/extensions/Xpresent.h>]], [[static typeof(XPresentQueryVersion) * func; if (func) return 0;]])],
+                  [WINE_CHECK_SONAME(Xpresent,XPresentQueryVersion,,,[$X_LIBS $X_EXTRA_LIBS])])
+        fi
+        WINE_NOTICE_WITH(Xpresent,[test "x$ac_cv_lib_soname_Xpresent" = "x"],
+                         [libXpresent ${notice_platform}development files not found, Xpresent won't be supported.])
+
         dnl *** Check for X Composite extension
         AC_CHECK_HEADER([X11/extensions/Xcomposite.h],
                         [WINE_CHECK_SONAME(Xcomposite,XCompositeRedirectWindow,,,[$X_LIBS $X_EXTRA_LIBS])],,
diff --git a/dlls/winex11.drv/init.c b/dlls/winex11.drv/init.c
index 7d93fb7..26d711a 100644
--- a/dlls/winex11.drv/init.c
+++ b/dlls/winex11.drv/init.c
@@ -31,6 +31,9 @@
 #include "winbase.h"
 #include "winreg.h"
 #include "x11drv.h"
+#include "xfixes.h"
+#include "xpresent.h"
+#include "xcomposite.h"
 #include "wine/debug.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(x11drv);
@@ -251,10 +254,33 @@ static INT X11DRV_ExtEscape( PHYSDEV dev, INT escape, INT in_count, LPCVOID in_d
 
                     OffsetRect( &rect, -physDev->dc_rect.left, -physDev->dc_rect.top );
                     if (data->flush) XFlush( gdi_display );
-                    XSetFunction( gdi_display, physDev->gc, GXcopy );
-                    XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
-                               0, 0, rect.right, rect.bottom,
-                               physDev->dc_rect.left, physDev->dc_rect.top );
+
+#if defined(SONAME_LIBXPRESENT) && defined(SONAME_LIBXFIXES)
+                    if (use_xpresent && use_xfixes && usexcomposite)
+                    {
+                        XserverRegion update, valid;
+                        XRectangle xrect = {0, 0, rect.right - rect.left, rect.bottom - rect.top};
+                        Drawable drawable = data->drawable;
+                        update = pXFixesCreateRegionFromGC( gdi_display, physDev->gc );
+                        valid = pXFixesCreateRegion( gdi_display, &xrect, 1 );
+#ifdef SONAME_LIBXCOMPOSITE
+                        if (usexcomposite) drawable = pXCompositeNameWindowPixmap( gdi_display, drawable );
+#endif
+                        pXPresentPixmap( gdi_display, physDev->drawable, drawable, XNextRequest( gdi_display ),
+                                         valid, update, physDev->dc_rect.left, physDev->dc_rect.top, None, None,
+                                         None, 0, 0, 0, 0, NULL, 0 );
+                        pXFixesDestroyRegion( gdi_display, update );
+                        pXFixesDestroyRegion( gdi_display, valid );
+                    }
+                    else
+#endif
+                    {
+                        XSetFunction( gdi_display, physDev->gc, GXcopy );
+                        XCopyArea( gdi_display, data->drawable, physDev->drawable, physDev->gc,
+                                   0, 0, rect.right, rect.bottom,
+                                   physDev->dc_rect.left, physDev->dc_rect.top );
+                    }
+
                     add_device_bounds( physDev, &rect );
                     return TRUE;
                 }
diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 2fbd890..698076f 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -294,6 +294,8 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
 
     if (!surface || !surface->offscreen)
         wait_fence = FALSE;
+    else if (use_xpresent && use_xfixes && usexcomposite) /* X11DRV_PRESENT_DRAWABLE will use XPresentPixmap */
+        wait_fence = FALSE;
     else if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR ||
              surface->present_mode == VK_PRESENT_MODE_FIFO_KHR)
         wait_fence = TRUE;
@@ -316,7 +318,7 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
         escape.drawable = surface->window;
         escape.flush = TRUE;
         NtGdiExtEscape(hdc, NULL, 0, X11DRV_ESCAPE, sizeof(escape), (char *)&escape, 0, NULL);
-        if (surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
+        if (wait_fence && surface->present_mode == VK_PRESENT_MODE_MAILBOX_KHR)
             if (once++) FIXME("Application requires child window rendering with mailbox present mode, expect possible tearing!\n");
     }
 
@@ -352,8 +354,9 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
     create_info_host = *create_info;
     create_info_host.surface = x11_surface->host_surface;
 
-    /* force fifo when running offscreen so the acquire fence is more likely to be vsynced */
-    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR)
+    /* unless we use XPresentPixmap, force fifo when running offscreen so the acquire fence is more likely to be vsynced */
+    if (x11_surface->offscreen && create_info->presentMode == VK_PRESENT_MODE_MAILBOX_KHR &&
+        !(use_xpresent && use_xfixes && usexcomposite))
         create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
     x11_surface->present_mode = create_info->presentMode;
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index ec26e0e..fa8077b 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -447,6 +447,7 @@ extern int keyboard_layout;
 extern BOOL keyboard_scancode_detect;
 extern BOOL usexcomposite;
 extern BOOL use_xfixes;
+extern BOOL use_xpresent;
 extern BOOL managed_mode;
 extern BOOL decorated_mode;
 extern BOOL private_color_map;
diff --git a/dlls/winex11.drv/x11drv_main.c b/dlls/winex11.drv/x11drv_main.c
index 9ed8894..9ba50e6 100644
--- a/dlls/winex11.drv/x11drv_main.c
+++ b/dlls/winex11.drv/x11drv_main.c
@@ -51,6 +51,7 @@
 #include "winreg.h"
 #include "xcomposite.h"
 #include "xfixes.h"
+#include "xpresent.h"
 #include "wine/server.h"
 #include "wine/debug.h"
 #include "wine/list.h"
@@ -73,6 +74,7 @@ BOOL usexvidmode = TRUE;
 BOOL usexrandr = TRUE;
 BOOL usexcomposite = TRUE;
 BOOL use_xfixes = FALSE;
+BOOL use_xpresent = FALSE;
 BOOL use_take_focus = TRUE;
 BOOL use_primary_selection = FALSE;
 BOOL use_system_cursors = TRUE;
@@ -676,6 +678,7 @@ MAKE_FUNCPTR(XFixesQueryExtension)
 MAKE_FUNCPTR(XFixesQueryVersion)
 MAKE_FUNCPTR(XFixesCreateRegion)
 MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesDestroyRegion)
 MAKE_FUNCPTR(XFixesSelectSelectionInput)
 #undef MAKE_FUNCPTR
 
@@ -701,6 +704,7 @@ static void x11drv_load_xfixes(void)
     LOAD_FUNCPTR(XFixesQueryVersion)
     LOAD_FUNCPTR(XFixesCreateRegion)
     LOAD_FUNCPTR(XFixesCreateRegionFromGC)
+    LOAD_FUNCPTR(XFixesDestroyRegion)
     LOAD_FUNCPTR(XFixesSelectSelectionInput)
 #undef LOAD_FUNCPTR
 
@@ -726,6 +730,57 @@ static void x11drv_load_xfixes(void)
 }
 #endif /* SONAME_LIBXFIXES */
 
+#ifdef SONAME_LIBXPRESENT
+
+#define MAKE_FUNCPTR(f) typeof(f) * p##f;
+MAKE_FUNCPTR(XPresentQueryExtension)
+MAKE_FUNCPTR(XPresentQueryVersion)
+MAKE_FUNCPTR(XPresentPixmap)
+#undef MAKE_FUNCPTR
+
+static void x11drv_load_xpresent(void)
+{
+    int opcode, event, error, major = 1, minor = 0;
+    void *xpresent;
+
+    if (!(xpresent = dlopen( SONAME_LIBXPRESENT, RTLD_NOW )))
+    {
+        WARN( "Xpresent library %s not found, disabled.\n", SONAME_LIBXPRESENT );
+        return;
+    }
+
+#define LOAD_FUNCPTR(f) \
+    if (!(p##f = dlsym( xpresent, #f )))                          \
+    {                                                             \
+        WARN( "Xpresent function %s not found, disabled\n", #f ); \
+        dlclose( xpresent );                                      \
+        return;                                                   \
+    }
+    LOAD_FUNCPTR(XPresentQueryExtension)
+    LOAD_FUNCPTR(XPresentQueryVersion)
+    LOAD_FUNCPTR(XPresentPixmap)
+#undef LOAD_FUNCPTR
+
+    if (!pXPresentQueryExtension( gdi_display, &opcode, &event, &error ))
+    {
+        WARN("Xpresent extension not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    if (!pXPresentQueryVersion( gdi_display, &major, &minor ))
+    {
+        WARN("Xpresent version not found, disabled.\n");
+        dlclose(xpresent);
+        return;
+    }
+
+    TRACE( "Xpresent, opcode %d, error %d, event %d, version %d.%d found\n",
+           opcode, error, event, major, minor );
+    use_xpresent = TRUE;
+}
+#endif /* SONAME_LIBXPRESENT */
+
 static void init_visuals( Display *display, int screen )
 {
     int count;
@@ -834,6 +889,9 @@ static NTSTATUS x11drv_init( void *arg )
 #ifdef SONAME_LIBXFIXES
     x11drv_load_xfixes();
 #endif
+#ifdef SONAME_LIBXPRESENT
+    x11drv_load_xpresent();
+#endif
 #ifdef SONAME_LIBXCOMPOSITE
     X11DRV_XComposite_Init();
 #endif
diff --git a/dlls/winex11.drv/xfixes.h b/dlls/winex11.drv/xfixes.h
index 684b5f4..658441a 100644
--- a/dlls/winex11.drv/xfixes.h
+++ b/dlls/winex11.drv/xfixes.h
@@ -29,6 +29,9 @@
 #define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
 MAKE_FUNCPTR(XFixesQueryExtension)
 MAKE_FUNCPTR(XFixesQueryVersion)
+MAKE_FUNCPTR(XFixesCreateRegion)
+MAKE_FUNCPTR(XFixesCreateRegionFromGC)
+MAKE_FUNCPTR(XFixesDestroyRegion)
 MAKE_FUNCPTR(XFixesSelectSelectionInput)
 #undef MAKE_FUNCPTR
 #endif /* defined(SONAME_LIBXFIXES) */
diff --git a/dlls/winex11.drv/xpresent.h b/dlls/winex11.drv/xpresent.h
new file mode 100644
index 0000000..3ccd9ff
--- /dev/null
+++ b/dlls/winex11.drv/xpresent.h
@@ -0,0 +1,36 @@
+/*
+ * Wine X11DRV Xpresent interface
+ *
+ * Copyright 2021 RÃ©mi Bernon for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+#ifndef __WINE_XPRESENT_H
+#define __WINE_XPRESENT_H
+
+#ifndef __WINE_CONFIG_H
+# error You must include config.h to use this header
+#endif
+
+#ifdef SONAME_LIBXPRESENT
+#include <X11/extensions/Xpresent.h>
+#define MAKE_FUNCPTR(f) extern typeof(f) * p##f;
+MAKE_FUNCPTR(XPresentQueryExtension)
+MAKE_FUNCPTR(XPresentQueryVersion)
+MAKE_FUNCPTR(XPresentPixmap)
+#undef MAKE_FUNCPTR
+#endif /* defined(SONAME_LIBXPRESENT) */
+
+#endif /* __WINE_XPRESENT_H */
-- 
2.44.0

From 02897040f569f25b71aad196222719aec8cd07f2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Sat, 7 May 2022 01:02:53 +0200
Subject: [PATCH 08/16] winex11.drv: Support multiple vulkan surfaces per HWND.

Fixes games failing to render after displaying a video, e.g. Age of
Empires II (2013).

    https://github.com/doitsujin/dxvk/issues/1726
---
 dlls/winex11.drv/vulkan.c | 46 ++++++++++++++++++++++-----------------
 dlls/winex11.drv/window.c |  2 +-
 dlls/winex11.drv/x11drv.h |  2 +-
 3 files changed, 28 insertions(+), 22 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 698076f..313dbaa 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -52,7 +52,6 @@ WINE_DECLARE_DEBUG_CHANNEL(fps);
 
 static pthread_mutex_t vulkan_mutex;
 
-static XContext vulkan_hwnd_context;
 static XContext vulkan_swapchain_context;
 
 #define VK_STRUCTURE_TYPE_XLIB_SURFACE_CREATE_INFO_KHR 1000004000
@@ -175,21 +174,30 @@ static void wine_vk_surface_release(struct wine_vk_surface *surface)
     free(surface);
 }
 
-void wine_vk_surface_destroy(HWND hwnd)
+void wine_vk_surface_destroy(struct wine_vk_surface *surface)
 {
-    struct wine_vk_surface *surface;
+    TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
+    XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
+    XSync(gdi_display, False);
+
+    if (surface->hdc) NtUserReleaseDC(surface->hwnd, surface->hdc);
+    surface->hwnd_thread_id = 0;
+    surface->hwnd = 0;
+    surface->hdc = 0;
+    wine_vk_surface_release(surface);
+}
+
+void destroy_vk_surface(HWND hwnd)
+{
+    struct wine_vk_surface *surface, *next;
     pthread_mutex_lock(&vulkan_mutex);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    LIST_FOR_EACH_ENTRY_SAFE(surface, next, &surface_list, struct wine_vk_surface, entry)
     {
-        hdc = surface->hdc;
-        surface->hwnd_thread_id = 0;
-        surface->hwnd = 0;
-        surface->hdc = 0;
-        wine_vk_surface_release(surface);
+        if (surface->hwnd != hwnd)
+            continue;
+        wine_vk_surface_destroy(surface);
     }
-    XDeleteContext(gdi_display, (XID)hwnd, vulkan_hwnd_context);
     pthread_mutex_unlock(&vulkan_mutex);
-    if (hdc) NtUserReleaseDC(hwnd, hdc);
 }
 
 static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL offscreen)
@@ -221,8 +229,12 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
     pthread_mutex_lock(&vulkan_mutex);
-    if (!XFindContext(gdi_display, (XID)hwnd, vulkan_hwnd_context, (char **)&surface))
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd)
+            continue;
         wine_vk_surface_set_offscreen(surface, known_child);
+    }
     pthread_mutex_unlock(&vulkan_mutex);
 }
 
@@ -237,10 +249,7 @@ void vulkan_thread_detach(void)
         if (surface->hwnd_thread_id != thread_id)
             continue;
 
-        TRACE("Detaching surface %p, hwnd %p.\n", surface, surface->hwnd);
-        XReparentWindow(gdi_display, surface->window, get_dummy_parent(), 0, 0);
-        XSync(gdi_display, False);
-        wine_vk_surface_destroy(surface->hwnd);
+        wine_vk_surface_destroy(surface);
     }
     pthread_mutex_unlock(&vulkan_mutex);
 }
@@ -405,6 +414,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (create_info->hwnd && (NtUserGetWindowRelative(create_info->hwnd, GW_CHILD) ||
                               NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow()))
     {
+        TRACE("hwnd %p creating offscreen child window surface\n", x11_surface->hwnd);
         if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
         {
             res = VK_ERROR_INCOMPATIBLE_DRIVER;
@@ -426,9 +436,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }
 
     pthread_mutex_lock(&vulkan_mutex);
-    wine_vk_surface_destroy( x11_surface->hwnd );
-    XSaveContext( gdi_display, (XID)create_info->hwnd, vulkan_hwnd_context,
-                  (char *)wine_vk_surface_grab( x11_surface ) );
     list_add_tail(&surface_list, &x11_surface->entry);
     pthread_mutex_unlock(&vulkan_mutex);
 
@@ -630,7 +637,6 @@ UINT X11DRV_VulkanInit( UINT version, void *vulkan_handle, struct vulkan_funcs *
     LOAD_FUNCPTR( vkDestroyFence );
 #undef LOAD_FUNCPTR
 
-    vulkan_hwnd_context = XUniqueContext();
     vulkan_swapchain_context = XUniqueContext();
     *driver_funcs = vulkan_funcs;
     return STATUS_SUCCESS;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 4322b3e..5ee3d5d 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1923,7 +1923,7 @@ void X11DRV_DestroyWindow( HWND hwnd )
     release_win_data( data );
     free( data );
     destroy_gl_drawable( hwnd );
-    wine_vk_surface_destroy( hwnd );
+    destroy_vk_surface( hwnd );
 }
 
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index fa8077b..ae8fcee 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -656,7 +656,7 @@ extern Window get_dummy_parent(void);
 extern void sync_gl_drawable( HWND hwnd, BOOL known_child );
 extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
 extern void destroy_gl_drawable( HWND hwnd );
-extern void wine_vk_surface_destroy( HWND hwnd );
+extern void destroy_vk_surface( HWND hwnd );
 extern void sync_vk_surface( HWND hwnd, BOOL known_child );
 extern void vulkan_thread_detach(void);
 
-- 
2.44.0

From 600f66c8167266f0192a0d1c1fe5d615d3793f69 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:12:16 +0200
Subject: [PATCH 09/16] winex11.drv: Resize vulkan surfaces client rect size
 changes.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 12 ++++++++++++
 dlls/winex11.drv/window.c |  1 +
 dlls/winex11.drv/x11drv.h |  1 +
 3 files changed, 14 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 313dbaa..1be4f76 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -225,6 +225,18 @@ static BOOL wine_vk_surface_set_offscreen(struct wine_vk_surface *surface, BOOL
     return !offscreen;
 }
 
+void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *changes)
+{
+    struct wine_vk_surface *surface;
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface->window != active) XConfigureWindow(gdi_display, surface->window, mask, changes);
+    }
+    pthread_mutex_unlock(&vulkan_mutex);
+}
+
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 5ee3d5d..2a74445 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1492,6 +1492,7 @@ static void sync_client_position( struct x11drv_win_data *data,
         TRACE( "setting client win %lx pos %d,%d,%dx%d changes=%x\n",
                data->client_window, changes.x, changes.y, changes.width, changes.height, mask );
         XConfigureWindow( gdi_display, data->client_window, mask, &changes );
+        resize_vk_surfaces( data->hwnd, data->client_window, mask, &changes );
     }
 }
 
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index ae8fcee..3917761 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -658,6 +658,7 @@ extern void set_gl_drawable_parent( HWND hwnd, HWND parent );
 extern void destroy_gl_drawable( HWND hwnd );
 extern void destroy_vk_surface( HWND hwnd );
 extern void sync_vk_surface( HWND hwnd, BOOL known_child );
+extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes );
 extern void vulkan_thread_detach(void);
 
 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set );
-- 
2.44.0

From 22310d6d0b3fa2bce1ae8e37b228da1dffef91a6 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Oct 2021 00:22:00 +0200
Subject: [PATCH 10/16] winex11.drv: Update client_window pointer on surface
 destroy.

To prevent reusing already destroyed client_window with the thread
display requests.

This lets us restore another client window, as the primary client
window.

Wine-Bug: https://bugs.winehq.org/show_bug.cgi?id=45277
CW-Bug-Id: 16608
---
 dlls/winex11.drv/vulkan.c | 20 ++++++++++++++++++++
 dlls/winex11.drv/window.c | 16 ++++++++++++++++
 dlls/winex11.drv/x11drv.h |  2 ++
 3 files changed, 38 insertions(+)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 1be4f76..4397c92 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -250,6 +250,24 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
     pthread_mutex_unlock(&vulkan_mutex);
 }
 
+Window wine_vk_active_surface( HWND hwnd )
+{
+    struct wine_vk_surface *surface, *active = NULL;
+    Window window;
+
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        active = surface;
+    }
+    if (!active) window = None;
+    else window = active->window;
+    pthread_mutex_unlock(&vulkan_mutex);
+
+    return window;
+}
+
 void vulkan_thread_detach(void)
 {
     struct wine_vk_surface *surface, *next;
@@ -475,6 +493,7 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
         const VkAllocationCallbacks *allocator)
 {
     struct wine_vk_surface *x11_surface = surface_from_handle(surface);
+    HWND hwnd = x11_surface->hwnd;
 
     TRACE("%p 0x%s %p\n", instance, wine_dbgstr_longlong(surface), allocator);
 
@@ -483,6 +502,7 @@ static void X11DRV_vkDestroySurfaceKHR(VkInstance instance, VkSurfaceKHR surface
 
     pvkDestroySurfaceKHR( instance, x11_surface->host_surface, NULL /* allocator */ );
     wine_vk_surface_release(x11_surface);
+    update_client_window(hwnd);
 }
 
 static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapchain,
diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 2a74445..7af6ac0 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1610,6 +1610,22 @@ Window get_dummy_parent(void)
 }
 
 
+/**********************************************************************
+ *		update_client_window
+ */
+void update_client_window( HWND hwnd )
+{
+    struct x11drv_win_data *data;
+    if ((data = get_win_data( hwnd )))
+    {
+        data->client_window = wine_vk_active_surface( hwnd );
+        /* make sure any request that could use old client window has been flushed */
+        XFlush( data->display );
+        release_win_data( data );
+    }
+}
+
+
 /**********************************************************************
  *		create_client_window
  */
diff --git a/dlls/winex11.drv/x11drv.h b/dlls/winex11.drv/x11drv.h
index 3917761..a687595 100644
--- a/dlls/winex11.drv/x11drv.h
+++ b/dlls/winex11.drv/x11drv.h
@@ -659,6 +659,7 @@ extern void destroy_gl_drawable( HWND hwnd );
 extern void destroy_vk_surface( HWND hwnd );
 extern void sync_vk_surface( HWND hwnd, BOOL known_child );
 extern void resize_vk_surfaces( HWND hwnd, Window active, int mask, XWindowChanges *changes );
+extern Window wine_vk_active_surface( HWND hwnd );
 extern void vulkan_thread_detach(void);
 
 extern void wait_for_withdrawn_state( HWND hwnd, BOOL set );
@@ -668,6 +669,7 @@ extern void read_net_wm_states( Display *display, struct x11drv_win_data *data )
 extern void update_net_wm_states( struct x11drv_win_data *data );
 extern void make_window_embedded( struct x11drv_win_data *data );
 extern Window create_client_window( HWND hwnd, const XVisualInfo *visual );
+extern void update_client_window( HWND hwnd );
 extern void set_window_visual( struct x11drv_win_data *data, const XVisualInfo *vis, BOOL use_alpha );
 extern void change_systray_owner( Display *display, Window systray_window );
 extern HWND create_foreign_window( Display *display, Window window );
-- 
2.44.0

From 8c90a88880ede76a81bd01b9f6d13c5567fd9f4c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Apr 2022 23:23:25 +0200
Subject: [PATCH 11/16] winex11.drv: Support concurrent Vulkan surfaces using
 XComposite.

---
 dlls/winex11.drv/vulkan.c | 37 ++++++++++++++++++++++++++++++++-----
 1 file changed, 32 insertions(+), 5 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 4397c92..0dd33ba 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -65,6 +65,7 @@ struct wine_vk_surface
     Window window;
     VkSurfaceKHR host_surface;
     VkPresentModeKHR present_mode;
+    BOOL known_child; /* hwnd is or has a child */
     BOOL offscreen; /* drawable is offscreen */
     HDC hdc;
     HWND hwnd;
@@ -240,12 +241,21 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *chan
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
+    DWORD surface_count = 0;
+
     pthread_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
-        if (surface->hwnd != hwnd)
-            continue;
-        wine_vk_surface_set_offscreen(surface, known_child);
+        if (surface->hwnd != hwnd) continue;
+        surface->known_child = known_child;
+        surface_count++;
+    }
+    TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, known_child);
+    LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (surface->hwnd != hwnd) continue;
+        if (surface_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
+        else wine_vk_surface_set_offscreen(surface, known_child);
     }
     pthread_mutex_unlock(&vulkan_mutex);
 }
@@ -253,6 +263,7 @@ void sync_vk_surface(HWND hwnd, BOOL known_child)
 Window wine_vk_active_surface( HWND hwnd )
 {
     struct wine_vk_surface *surface, *active = NULL;
+    DWORD surface_count = 0;
     Window window;
 
     pthread_mutex_lock(&vulkan_mutex);
@@ -260,9 +271,16 @@ Window wine_vk_active_surface( HWND hwnd )
     {
         if (surface->hwnd != hwnd) continue;
         active = surface;
+        surface_count++;
     }
     if (!active) window = None;
-    else window = active->window;
+    else
+    {
+        TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, active->known_child);
+        if (surface_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
+        else wine_vk_surface_set_offscreen(active, active->known_child);
+        window = active->window;
+    }
     pthread_mutex_unlock(&vulkan_mutex);
 
     return window;
@@ -415,7 +433,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 {
     VkResult res;
     VkXlibSurfaceCreateInfoKHR create_info_host;
-    struct wine_vk_surface *x11_surface;
+    struct wine_vk_surface *x11_surface, *other;
 
     TRACE("%p %p %p %p\n", instance, create_info, allocator, surface);
 
@@ -427,6 +445,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
         return VK_ERROR_OUT_OF_HOST_MEMORY;
 
     x11_surface->ref = 1;
+    x11_surface->known_child = FALSE;
     x11_surface->hwnd = create_info->hwnd;
     x11_surface->hdc = NtUserGetDCEx(x11_surface->hwnd, 0, DCX_USESTYLE);
     x11_surface->window = create_client_window( create_info->hwnd, &default_visual );
@@ -444,6 +463,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     if (create_info->hwnd && (NtUserGetWindowRelative(create_info->hwnd, GW_CHILD) ||
                               NtUserGetAncestor(create_info->hwnd, GA_PARENT) != NtUserGetDesktopWindow()))
     {
+        x11_surface->known_child = TRUE;
         TRACE("hwnd %p creating offscreen child window surface\n", x11_surface->hwnd);
         if (!wine_vk_surface_set_offscreen(x11_surface, TRUE))
         {
@@ -466,6 +486,13 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }
 
     pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (other->hwnd != x11_surface->hwnd) continue;
+        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
+        wine_vk_surface_set_offscreen(other, TRUE);
+        wine_vk_surface_set_offscreen(x11_surface, TRUE);
+    }
     list_add_tail(&surface_list, &x11_surface->entry);
     pthread_mutex_unlock(&vulkan_mutex);
 
-- 
2.44.0

From 9ce06cac288b54caa230b605845265c53f8857f0 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Fri, 22 Apr 2022 23:23:49 +0200
Subject: [PATCH 12/16] winex11.drv: Consider only Vulkan surfaces with
 swapchains for offscreen rendering.
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

"A native window cannot be associated with more than one non-retired
swapchain at a time."[1]

The hack introduced in 81f5a09134e5 ("winex11: Allow multiple vulkan
surfaces per hwnd") sends surfaces for offscreen rendering using
XComposite when there are multiple surfaces associated with a single
hwnd.

That's overzealous though, as some of the swapchains may be already
destroyed.

E.g. DOOM Eternal with vsync enabled does the following:

    vkCreateWin32SurfaceKHR(vk_inst, &surface_create_info, NULL, &old_surface)
    vkCreateSwapchainKHR(vk_inst, &sc_create_info, NULL, &old_sc);
    vkDestroySwapchainKHR(vk_inst, old_sc, NULL);
    /* old_surface never gets destroyed */

    vkCreateWin32SurfaceKHR(vk_inst, &surface_create_info, NULL, &new_surface);
    vkCreateSwapchainKHR(vk_inst, &sc_create_info, NULL, &new_swapchain);

Which makes the hack kick in and degrades the performance.

This change makes sure that we only count surfaces that have any
swapchains associated with them, whether they are retired or not.

That's a bit of oversimplification, as swapchain can get retired without
new swapchain being created:

"Upon calling vkCreateSwapchainKHR with an oldSwapchain that is not
VK_NULL_HANDLE, oldSwapchain is retiredâââeven if creation of the new
swapchain fails. The new swapchain is created in the non-retired state
whether or not oldSwapchain is VK_NULL_HANDLE."[2]

but that's unlikely to happen and cause problems.

[1]: https://khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainKHR.html
[2]: https://khronos.org/registry/vulkan/specs/1.2-extensions/man/html/VkSwapchainCreateInfoKHR.html

CW-Bug-Id: #19666
---
 dlls/winex11.drv/vulkan.c | 47 ++++++++++++++++++++++-----------------
 1 file changed, 27 insertions(+), 20 deletions(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 0dd33ba..7dad358 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -67,6 +67,7 @@ struct wine_vk_surface
     VkPresentModeKHR present_mode;
     BOOL known_child; /* hwnd is or has a child */
     BOOL offscreen; /* drawable is offscreen */
+    LONG swapchain_count; /* surface can have one active an many retired swapchains */
     HDC hdc;
     HWND hwnd;
     DWORD hwnd_thread_id;
@@ -241,43 +242,43 @@ void resize_vk_surfaces(HWND hwnd, Window active, int mask, XWindowChanges *chan
 void sync_vk_surface(HWND hwnd, BOOL known_child)
 {
     struct wine_vk_surface *surface;
-    DWORD surface_count = 0;
+    DWORD surface_with_swapchain_count = 0;
 
     pthread_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
+        if (surface->swapchain_count) surface_with_swapchain_count++;
         surface->known_child = known_child;
-        surface_count++;
     }
-    TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, known_child);
+    TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, known_child);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
-        if (surface_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(surface, TRUE);
         else wine_vk_surface_set_offscreen(surface, known_child);
     }
     pthread_mutex_unlock(&vulkan_mutex);
 }
 
-Window wine_vk_active_surface( HWND hwnd )
+Window wine_vk_active_surface(HWND hwnd)
 {
     struct wine_vk_surface *surface, *active = NULL;
-    DWORD surface_count = 0;
+    DWORD surface_with_swapchain_count = 0;
     Window window;
 
     pthread_mutex_lock(&vulkan_mutex);
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
+        if (surface->swapchain_count) surface_with_swapchain_count++;
         active = surface;
-        surface_count++;
     }
     if (!active) window = None;
     else
     {
-        TRACE("hwnd %p surface_count %u known_child %u\n", hwnd, surface_count, active->known_child);
-        if (surface_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
+        TRACE("hwnd %p surface_with_swapchain_count %u known_child %u\n", hwnd, surface_with_swapchain_count, active->known_child);
+        if (surface_with_swapchain_count > 1) wine_vk_surface_set_offscreen(active, TRUE);
         else wine_vk_surface_set_offscreen(active, active->known_child);
         window = active->window;
     }
@@ -396,7 +397,7 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         const VkSwapchainCreateInfoKHR *create_info,
         const VkAllocationCallbacks *allocator, VkSwapchainKHR *swapchain)
 {
-    struct wine_vk_surface *x11_surface = surface_from_handle(create_info->surface);
+    struct wine_vk_surface *other, *x11_surface = surface_from_handle(create_info->surface);
     VkSwapchainCreateInfoKHR create_info_host;
     VkResult result;
 
@@ -417,13 +418,22 @@ static VkResult X11DRV_vkCreateSwapchainKHR(VkDevice device,
         create_info_host.presentMode = VK_PRESENT_MODE_FIFO_KHR;
     x11_surface->present_mode = create_info->presentMode;
 
+    pthread_mutex_lock(&vulkan_mutex);
+    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
+    {
+        if (other->hwnd != x11_surface->hwnd) continue;
+        if (!other->swapchain_count) continue;
+        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
+        wine_vk_surface_set_offscreen(other, TRUE);
+        wine_vk_surface_set_offscreen(x11_surface, TRUE);
+    }
     result = pvkCreateSwapchainKHR(device, &create_info_host, NULL /* allocator */, swapchain);
     if (result == VK_SUCCESS)
     {
-        pthread_mutex_lock(&vulkan_mutex);
+        x11_surface->swapchain_count++;
         XSaveContext(gdi_display, (XID)(*swapchain), vulkan_swapchain_context, (char *)wine_vk_surface_grab(x11_surface));
-        pthread_mutex_unlock(&vulkan_mutex);
     }
+    pthread_mutex_unlock(&vulkan_mutex);
     return result;
 }
 
@@ -433,7 +443,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 {
     VkResult res;
     VkXlibSurfaceCreateInfoKHR create_info_host;
-    struct wine_vk_surface *x11_surface, *other;
+    struct wine_vk_surface *x11_surface;
 
     TRACE("%p %p %p %p\n", instance, create_info, allocator, surface);
 
@@ -446,6 +456,7 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
 
     x11_surface->ref = 1;
     x11_surface->known_child = FALSE;
+    x11_surface->swapchain_count = 0;
     x11_surface->hwnd = create_info->hwnd;
     x11_surface->hdc = NtUserGetDCEx(x11_surface->hwnd, 0, DCX_USESTYLE);
     x11_surface->window = create_client_window( create_info->hwnd, &default_visual );
@@ -486,13 +497,6 @@ static VkResult X11DRV_vkCreateWin32SurfaceKHR(VkInstance instance,
     }
 
     pthread_mutex_lock(&vulkan_mutex);
-    LIST_FOR_EACH_ENTRY(other, &surface_list, struct wine_vk_surface, entry)
-    {
-        if (other->hwnd != x11_surface->hwnd) continue;
-        TRACE("hwnd %p already has a swapchain, moving surface offscreen\n", x11_surface->hwnd);
-        wine_vk_surface_set_offscreen(other, TRUE);
-        wine_vk_surface_set_offscreen(x11_surface, TRUE);
-    }
     list_add_tail(&surface_list, &x11_surface->entry);
     pthread_mutex_unlock(&vulkan_mutex);
 
@@ -546,7 +550,10 @@ static void X11DRV_vkDestroySwapchainKHR(VkDevice device, VkSwapchainKHR swapcha
 
     pthread_mutex_lock(&vulkan_mutex);
     if (!XFindContext(gdi_display, (XID)swapchain, vulkan_swapchain_context, (char **)&surface))
+    {
+        surface->swapchain_count--;
         wine_vk_surface_release(surface);
+    }
     XDeleteContext(gdi_display, (XID)swapchain, vulkan_swapchain_context);
     pthread_mutex_unlock(&vulkan_mutex);
 }
-- 
2.44.0

From 0eabd4b4512ee466ed3e297d6c3e7f380150e1b2 Mon Sep 17 00:00:00 2001
From: Arkadiusz Hiler <ahiler@codeweavers.com>
Date: Tue, 23 Nov 2021 13:54:34 +0200
Subject: [PATCH 13/16] winex11.drv: Don't consider swapchain-less Vulkan
 surfaces active.

---
 dlls/winex11.drv/vulkan.c | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index 7dad358..bdd9bc4 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -271,8 +271,9 @@ Window wine_vk_active_surface(HWND hwnd)
     LIST_FOR_EACH_ENTRY(surface, &surface_list, struct wine_vk_surface, entry)
     {
         if (surface->hwnd != hwnd) continue;
-        if (surface->swapchain_count) surface_with_swapchain_count++;
+        if (!surface->swapchain_count) continue;
         active = surface;
+        surface_with_swapchain_count++;
     }
     if (!active) window = None;
     else
-- 
2.44.0

From f51f1001ee3ee0c1c8ddc4253ab27249566a6723 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Tue, 22 Feb 2022 18:11:13 +0300
Subject: [PATCH 14/16] winex11.drv: Also treat VK_SUBOPTIMAL_KHR as success in
 X11DRV_vkAcquireNextImageKHR().

CW-Bug-Id: #20200
---
 dlls/winex11.drv/vulkan.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/dlls/winex11.drv/vulkan.c b/dlls/winex11.drv/vulkan.c
index bdd9bc4..e227039 100644
--- a/dlls/winex11.drv/vulkan.c
+++ b/dlls/winex11.drv/vulkan.c
@@ -370,7 +370,7 @@ static VkResult X11DRV_vkAcquireNextImageKHR(VkDevice device,
     }
 
     result = pvkAcquireNextImageKHR(device, swapchain, timeout, semaphore, fence, image_index);
-    if (result == VK_SUCCESS && hdc && surface && surface->offscreen)
+    if ((result == VK_SUCCESS || result == VK_SUBOPTIMAL_KHR) && hdc && surface && surface->offscreen)
     {
         if (wait_fence) pvkWaitForFences(device, 1, &fence, 0, timeout);
         escape.code = X11DRV_PRESENT_DRAWABLE;
-- 
2.44.0

From 28130e8e8ce1197cc91b7b51de3df7297d07f37f Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Mon, 9 May 2022 12:44:00 -0500
Subject: [PATCH 15/16] winex11.drv: Reparent client window back to whole
 window when reactivating it.

CW-Bug-Id: #20614

Related to Vulkan child window / multiple swapchains handling,
specificall this commit:
"winex11.drv: Update client_window pointer on surface destroy."

When the client window is replaced by the new one it gets reparented to
dummy window (effectively hidden). When another swapchain gets deleted
and the previous client window is brought back onscreen, in the current
logic it makes sense to make it visible child of the whole window again.
---
 dlls/winex11.drv/window.c | 10 ++++++++++
 1 file changed, 10 insertions(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 7af6ac0..85b760e 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1616,9 +1616,19 @@ Window get_dummy_parent(void)
 void update_client_window( HWND hwnd )
 {
     struct x11drv_win_data *data;
+    Window old_active;
+
     if ((data = get_win_data( hwnd )))
     {
+        old_active = data->client_window;
         data->client_window = wine_vk_active_surface( hwnd );
+        if (data->client_window && data->whole_window && old_active != data->client_window)
+        {
+            TRACE( "%p reparent xwin %lx/%lx\n", data->hwnd, data->whole_window, data->client_window );
+            XReparentWindow( gdi_display, data->client_window, data->whole_window,
+                     data->client_rect.left - data->whole_rect.left,
+                     data->client_rect.top - data->whole_rect.top );
+        }
         /* make sure any request that could use old client window has been flushed */
         XFlush( data->display );
         release_win_data( data );
-- 
2.44.0

From b9fbad5008f930c2f2954c85c0da47c4a3b9a555 Mon Sep 17 00:00:00 2001
From: Paul Gofman <pgofman@codeweavers.com>
Date: Fri, 20 May 2022 16:20:29 -0500
Subject: [PATCH 16/16] winex11.drv: Also call sync_vk_surface() for the child
 window when WS_CHILD is changed.

CW-Bug-Id: #19945
---
 dlls/winex11.drv/window.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/dlls/winex11.drv/window.c b/dlls/winex11.drv/window.c
index 85b760e..5bf7454 100644
--- a/dlls/winex11.drv/window.c
+++ b/dlls/winex11.drv/window.c
@@ -1904,6 +1904,7 @@ void X11DRV_SetWindowStyle( HWND hwnd, INT offset, STYLESTRUCT *style )
             sync_vk_surface( parent, TRUE );
         else
             sync_vk_surface( parent, FALSE );
+        sync_vk_surface( hwnd, style->styleNew & WS_CHILD );
     }
 
     if (hwnd == NtUserGetDesktopWindow()) return;
-- 
2.44.0

