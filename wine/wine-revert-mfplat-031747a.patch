From 031747a5aaa7614a3982cda14a1714fc9b54d2f4 Mon Sep 17 00:00:00 2001
From: =?utf8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Mon, 21 Mar 2022 18:02:38 +0100
Subject: [PATCH] qasf/tests: Add more ASF Reader filter tests.
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

Signed-off-by: RÃ©mi Bernon <rbernon@codeweavers.com>
---
 dlls/qasf/tests/Makefile.in |   2 +
 dlls/qasf/tests/asfreader.c | 234 +++++++++++++++++++++++++++++++++++-
 4 files changed, 257 insertions(+), 4 deletions(-)

diff --git a/dlls/qasf/tests/Makefile.in b/dlls/qasf/tests/Makefile.in
index 4b8d40671fb..bc962ebb657 100644
--- a/dlls/qasf/tests/Makefile.in
+++ b/dlls/qasf/tests/Makefile.in
@@ -4,3 +4,5 @@ IMPORTS   = strmbase dmoguids strmiids uuid msdmo ole32
 C_SRCS = \
 	asfreader.c \
 	dmowrapper.c
+
+RC_SRCS = resource.rc
diff --git a/dlls/qasf/tests/asfreader.c b/dlls/qasf/tests/asfreader.c
index f4f8b9e2e19..54c38263464 100644
--- a/dlls/qasf/tests/asfreader.c
+++ b/dlls/qasf/tests/asfreader.c
@@ -21,18 +21,21 @@
 
 #define COBJMACROS
 
+#include <stdbool.h>
 #include "dshow.h"
+#include "mediaobj.h"
+#include "propsys.h"
+#include "dvdmedia.h"
 #include "wine/strmbase.h"
 #include "wine/test.h"
 
 #include "initguid.h"
+#include "wmsdk.h"
+#include "wmcodecdsp.h"
 
+DEFINE_GUID(WMMEDIASUBTYPE_WMV1,0x31564d57,0x0000,0x0010,0x80,0x00,0x00,0xaa,0x00,0x38,0x9b,0x71);
 static const GUID testguid = {0x22222222, 0x2222, 0x2222, {0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22}};
 
-DEFINE_GUID(IID_IWMHeaderInfo,      0x96406bda, 0x2b2b, 0x11d3, 0xb3, 0x6b, 0x00, 0xc0, 0x4f, 0x61, 0x08, 0xff);
-DEFINE_GUID(IID_IWMReaderAdvanced,  0x96406bea, 0x2b2b, 0x11d3, 0xb3, 0x6b, 0x00, 0xc0, 0x4f, 0x61, 0x08, 0xff);
-DEFINE_GUID(IID_IWMReaderAdvanced2, 0xae14a945, 0xb90c, 0x4d0d, 0x91, 0x27, 0x80, 0xd6, 0x65, 0xf7, 0xd7, 0x3e);
-
 static IBaseFilter *create_asf_reader(void)
 {
     IBaseFilter *filter = NULL;
@@ -45,6 +48,31 @@ static IBaseFilter *create_asf_reader(void)
     return filter;
 }
 
+static WCHAR *load_resource(const WCHAR *name)
+{
+    static WCHAR pathW[MAX_PATH];
+    DWORD written;
+    HANDLE file;
+    HRSRC res;
+    void *ptr;
+
+    GetTempPathW(ARRAY_SIZE(pathW), pathW);
+    wcscat(pathW, name);
+
+    file = CreateFileW(pathW, GENERIC_READ|GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 0, 0);
+    ok(file != INVALID_HANDLE_VALUE, "Failed to create file %s, error %lu.\n",
+            wine_dbgstr_w(pathW), GetLastError());
+
+    res = FindResourceW(NULL, name, (LPCWSTR)RT_RCDATA);
+    ok(!!res, "Failed to load resource, error %lu.\n", GetLastError());
+    ptr = LockResource(LoadResource(GetModuleHandleA(NULL), res));
+    WriteFile(file, ptr, SizeofResource( GetModuleHandleA(NULL), res), &written, NULL);
+    ok(written == SizeofResource(GetModuleHandleA(NULL), res), "Failed to write resource.\n");
+    CloseHandle(file);
+
+    return pathW;
+}
+
 static ULONG get_refcount(void *iface)
 {
     IUnknown *unknown = iface;
@@ -183,8 +211,146 @@ static void test_aggregation(void)
     ok(outer_ref == 1, "Got unexpected refcount %ld.\n", outer_ref);
 }
 
+static bool compare_media_types(const AM_MEDIA_TYPE *a, const AM_MEDIA_TYPE *b)
+{
+    return !memcmp(a, b, offsetof(AM_MEDIA_TYPE, pbFormat))
+            && !memcmp(a->pbFormat, b->pbFormat, a->cbFormat);
+}
+
+static void check_pin(IPin *pin, IBaseFilter *expect_filter, PIN_DIRECTION expect_dir,
+        const WCHAR *expect_name, const WCHAR *expect_id, AM_MEDIA_TYPE *expect_mt, unsigned int expect_mt_count)
+{
+    IEnumMediaTypes *enum_mt;
+    AM_MEDIA_TYPE *mt;
+    unsigned int i;
+    PIN_INFO info;
+    HRESULT hr;
+    WCHAR *id;
+
+    hr = IPin_QueryPinInfo(pin, &info);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(info.pFilter == expect_filter, "Got filter %p.\n", info.pFilter);
+    ok(info.dir == expect_dir, "Got dir %#x.\n", info.dir);
+    todo_wine
+    ok(!wcscmp(info.achName, expect_name), "Got name %s.\n", debugstr_w(info.achName));
+    IBaseFilter_Release(info.pFilter);
+
+    hr = IPin_QueryId(pin, &id);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    todo_wine
+    ok(!wcscmp(id, expect_id), "Got id %s.\n", debugstr_w(id));
+    CoTaskMemFree(id);
+
+    hr = IPin_EnumMediaTypes(pin, &enum_mt);
+    todo_wine
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    if (hr != S_OK) goto skip_enum_mt;
+    for (i = 0; (hr = IEnumMediaTypes_Next(enum_mt, 1, &mt, NULL)) == S_OK; i++)
+    {
+        if (i < expect_mt_count)
+        {
+            todo_wine
+            ok(compare_media_types(mt, expect_mt + i), "Media type %u didn't match.\n", i);
+        }
+        FreeMediaType(mt);
+        CoTaskMemFree(mt);
+    }
+    todo_wine
+    ok(i == expect_mt_count, "Got %u types.\n", i);
+    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    IEnumMediaTypes_Release(enum_mt);
+
+skip_enum_mt:
+    check_interface(pin, &IID_IPin, TRUE);
+    check_interface(pin, &IID_IUnknown, TRUE);
+    todo_wine
+    check_interface(pin, &IID_IMediaSeeking, TRUE);
+    todo_wine
+    check_interface(pin, &IID_IQualityControl, TRUE);
+    check_interface(pin, &IID_IServiceProvider, FALSE);
+    check_interface(pin, &IID_IWMStreamConfig, FALSE);
+}
+
 static void test_filesourcefilter(void)
 {
+    static const MSAUDIO1WAVEFORMAT msaudio1_format =
+    {
+        .wfx.wFormatTag = WAVE_FORMAT_MSAUDIO1,
+        .wfx.nChannels = 1,
+        .wfx.nSamplesPerSec = 44100,
+        .wfx.nBlockAlign = 743,
+        .wfx.nAvgBytesPerSec = 16000,
+        .wfx.wBitsPerSample = 16,
+        .wfx.cbSize = sizeof(MSAUDIO1WAVEFORMAT) - sizeof(WAVEFORMATEX),
+        .wEncodeOptions = 1,
+    };
+    static const VIDEOINFOHEADER2 wmv1_info2 =
+    {
+        .rcSource = {0, 0, 64, 48},
+        .rcTarget = {0, 0, 64, 48},
+        .dwBitRate = 189464,
+        .dwPictAspectRatioX = 64,
+        .dwPictAspectRatioY = 48,
+        .bmiHeader =
+        {
+            .biSize = sizeof(BITMAPINFOHEADER),
+            .biWidth = 64,
+            .biHeight = 48,
+            .biPlanes = 1,
+            .biBitCount = 24,
+            .biCompression = MAKEFOURCC('W','M','V','1'),
+            .biSizeImage = 64 * 48 * 3,
+        },
+    };
+    static const VIDEOINFOHEADER wmv1_info =
+    {
+        .rcSource = {0, 0, 64, 48},
+        .rcTarget = {0, 0, 64, 48},
+        .dwBitRate = 189464,
+        .bmiHeader =
+        {
+            .biSize = sizeof(BITMAPINFOHEADER),
+            .biWidth = 64,
+            .biHeight = 48,
+            .biPlanes = 1,
+            .biBitCount = 24,
+            .biCompression = MAKEFOURCC('W','M','V','1'),
+            .biSizeImage = 64 * 48 * 3,
+        },
+    };
+    AM_MEDIA_TYPE audio_mt[] =
+    {
+        {
+            .majortype = MEDIATYPE_Audio,
+            .subtype = MEDIASUBTYPE_MSAUDIO1,
+            .bFixedSizeSamples = TRUE,
+            .lSampleSize = 743,
+            .formattype = FORMAT_WaveFormatEx,
+            .cbFormat = sizeof(MSAUDIO1WAVEFORMAT),
+            .pbFormat = (BYTE *)&msaudio1_format,
+        },
+    };
+    AM_MEDIA_TYPE video_mt[] =
+    {
+        {
+            .majortype = MEDIATYPE_Video,
+            .subtype = WMMEDIASUBTYPE_WMV1,
+            .formattype = FORMAT_VideoInfo2,
+            .bTemporalCompression = TRUE,
+            .cbFormat = sizeof(VIDEOINFOHEADER2),
+            .pbFormat = (BYTE *)&wmv1_info2,
+        },
+        {
+            .majortype = MEDIATYPE_Video,
+            .subtype = WMMEDIASUBTYPE_WMV1,
+            .formattype = FORMAT_VideoInfo,
+            .bTemporalCompression = TRUE,
+            .cbFormat = sizeof(VIDEOINFOHEADER),
+            .pbFormat = (BYTE *)&wmv1_info,
+        },
+    };
+
+    const WCHAR *filename = load_resource(L"test.wmv");
     IBaseFilter *filter = create_asf_reader();
     IFileSourceFilter *filesource;
     IFilterGraph2 *graph;
@@ -289,6 +455,66 @@ static void test_filesourcefilter(void)
     ok(type.pbFormat == ptr, "Got format block %p.\n", type.pbFormat);
     CoTaskMemFree(olepath);
 
+    hr = IFileSourceFilter_Load(filesource, filename, NULL);
+    ok(hr == E_FAIL, "Got hr %#lx.\n", hr);
+
+    ref = IFilterGraph2_Release(graph);
+    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+    IBaseFilter_Release(filter);
+    ref = IFileSourceFilter_Release(filesource);
+    ok(!ref, "Got outstanding refcount %ld.\n", ref);
+
+
+    filter = create_asf_reader();
+    hr = IBaseFilter_QueryInterface(filter, &IID_IFileSourceFilter, (void **)&filesource);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IFileSourceFilter_Load(filesource, filename, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = CoCreateInstance(&CLSID_FilterGraph, NULL, CLSCTX_INPROC_SERVER,
+            &IID_IFilterGraph2, (void **)&graph);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    hr = IFilterGraph2_AddFilter(graph, filter, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    olepath = (void *)0xdeadbeef;
+    memset(&type, 0x22, sizeof(type));
+    hr = IFileSourceFilter_GetCurFile(filesource, &olepath, &type);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    ok(!wcscmp(olepath, filename), "Got file %s.\n", wine_dbgstr_w(olepath));
+    ok(IsEqualGUID(&type.majortype, &MEDIATYPE_NULL), "Got majortype %s.\n",
+            wine_dbgstr_guid(&type.majortype));
+    ok(IsEqualGUID(&type.subtype, &MEDIASUBTYPE_NULL), "Got subtype %s.\n",
+            wine_dbgstr_guid(&type.subtype));
+    ok(type.bFixedSizeSamples == 0x22222222, "Got fixed size %d.\n", type.bFixedSizeSamples);
+    ok(type.bTemporalCompression == 0x22222222, "Got temporal compression %d.\n", type.bTemporalCompression);
+    ok(!type.lSampleSize, "Got sample size %lu.\n", type.lSampleSize);
+    ok(IsEqualGUID(&type.formattype, &testguid), "Got format type %s.\n", wine_dbgstr_guid(&type.formattype));
+    ok(!type.pUnk, "Got pUnk %p.\n", type.pUnk);
+    ok(!type.cbFormat, "Got format size %lu.\n", type.cbFormat);
+    ok(type.pbFormat == ptr, "Got format block %p.\n", type.pbFormat);
+    CoTaskMemFree(olepath);
+
+    hr = IBaseFilter_EnumPins(filter, &enumpins);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+
+    hr = IEnumPins_Next(enumpins, 1, pins, NULL);
+    todo_wine
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    if (hr != S_OK) goto skip_pins;
+    check_pin(pins[0], filter, PINDIR_OUTPUT, L"Raw Video 0", L"Raw Video 0", video_mt, ARRAY_SIZE(video_mt));
+    IPin_Release(pins[0]);
+
+    hr = IEnumPins_Next(enumpins, 1, pins, NULL);
+    ok(hr == S_OK, "Got hr %#lx.\n", hr);
+    check_pin(pins[0], filter, PINDIR_OUTPUT, L"Raw Audio 1", L"Raw Audio 1", audio_mt, ARRAY_SIZE(audio_mt));
+    IPin_Release(pins[0]);
+
+    hr = IEnumPins_Next(enumpins, 1, pins, NULL);
+skip_pins:
+    ok(hr == S_FALSE, "Got hr %#lx.\n", hr);
+    IEnumPins_Release(enumpins);
+
     ref = IFilterGraph2_Release(graph);
     ok(!ref, "Got outstanding refcount %ld.\n", ref);
     IBaseFilter_Release(filter);
-- 
2.20.1

