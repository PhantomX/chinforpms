From b6a7a02159eccc7fb40aa119a828e48ae256313a Mon Sep 17 00:00:00 2001
From: =?utf8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 May 2022 23:52:45 +0200
Subject: [PATCH] winegstreamer: Register stub ResamplerMediaObject transform.
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

Signed-off-by: RÃ©mi Bernon <rbernon@codeweavers.com>
---
 dlls/mf/tests/mf.c                           |  42 +-
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/main.c                    |  13 +
 dlls/winegstreamer/mfplat.c                  |  20 +-
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 7 files changed, 681 insertions(+), 8 deletions(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 13f0e38b0b8..990b29302de 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -254,9 +254,7 @@ static BOOL create_transform(GUID category, MFT_REGISTER_TYPE_INFO *input_type,
         if (IsEqualGUID(expect_class_id, class_ids + i))
             break;
     }
-    todo_wine_if(IsEqualGUID(class_ids, &CLSID_WINEAudioConverter))
     ok(i < count, "failed to find %s transform\n", debugstr_w(expect_name));
-    if (i == count) return FALSE;
     *class_id = class_ids[i];
     CoTaskMemFree(class_ids);
     ok(IsEqualGUID(class_id, expect_class_id), "got class id %s\n", debugstr_guid(class_id));
@@ -7566,15 +7564,16 @@ static void test_audio_convert(void)
     check_interface(transform, &IID_IMFTransform, TRUE);
     check_interface(transform, &IID_IMediaObject, TRUE);
     check_interface(transform, &IID_IPropertyStore, TRUE);
-    todo_wine
     check_interface(transform, &IID_IPropertyBag, TRUE);
     /* check_interface(transform, &IID_IWMResamplerProps, TRUE); */
 
     /* check default media types */
 
     hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetInputStreamInfo returned %#lx\n", hr);
     hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetOutputStreamInfo returned %#lx\n", hr);
 
     i = -1;
@@ -7587,7 +7586,9 @@ static void test_audio_convert(void)
         ok(ret == 0, "Release returned %lu\n", ret);
         winetest_pop_context();
     }
+    todo_wine
     ok(hr == MF_E_NO_MORE_TYPES, "GetOutputAvailableType returned %#lx\n", hr);
+    todo_wine
     ok(i == 4, "%lu output media types\n", i);
 
     i = -1;
@@ -7602,7 +7603,9 @@ static void test_audio_convert(void)
         ok(ret == 0, "Release returned %lu\n", ret);
         winetest_pop_context();
     }
+    todo_wine
     ok(hr == MF_E_NO_MORE_TYPES, "GetInputAvailableType returned %#lx\n", hr);
+    todo_wine
     ok(i == 2, "%lu input media types\n", i);
 
     /* setting output media type first doesn't work */
@@ -7611,6 +7614,7 @@ static void test_audio_convert(void)
     ok(hr == S_OK, "MFCreateMediaType returned %#lx\n", hr);
     init_media_type(media_type, output_type_desc, -1);
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "SetOutputType returned %#lx.\n", hr);
     ret = IMFMediaType_Release(media_type);
     ok(ret == 0, "Release returned %lu\n", ret);
@@ -7620,25 +7624,31 @@ static void test_audio_convert(void)
     hr = MFCreateMediaType(&media_type);
     ok(hr == S_OK, "MFCreateMediaType returned %#lx\n", hr);
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetInputType returned %#lx.\n", hr);
     init_media_type(media_type, input_type_desc, 1);
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetInputType returned %#lx.\n", hr);
     init_media_type(media_type, input_type_desc, 2);
     for (i = 2; i < ARRAY_SIZE(input_type_desc) - 1; ++i)
     {
         hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+        todo_wine
         ok(hr == MF_E_INVALIDMEDIATYPE, "SetInputType returned %#lx.\n", hr);
         init_media_type(media_type, input_type_desc, i + 1);
     }
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
     ret = IMFMediaType_Release(media_type);
     ok(ret == 0, "Release returned %lu\n", ret);
 
     hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetInputStreamInfo returned %#lx\n", hr);
     hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetOutputStreamInfo returned %#lx\n", hr);
 
     /* check new output media types */
@@ -7653,7 +7663,9 @@ static void test_audio_convert(void)
         ok(ret == 0, "Release returned %lu\n", ret);
         winetest_pop_context();
     }
+    todo_wine
     ok(hr == MF_E_NO_MORE_TYPES, "GetOutputAvailableType returned %#lx\n", hr);
+    todo_wine
     ok(i == 4, "%lu output media types\n", i);
 
     /* check required output media type attributes */
@@ -7661,36 +7673,50 @@ static void test_audio_convert(void)
     hr = MFCreateMediaType(&media_type);
     ok(hr == S_OK, "MFCreateMediaType returned %#lx\n", hr);
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetOutputType returned %#lx.\n", hr);
     init_media_type(media_type, output_type_desc, 1);
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetOutputType returned %#lx.\n", hr);
     init_media_type(media_type, output_type_desc, 2);
     for (i = 2; i < ARRAY_SIZE(output_type_desc) - 1; ++i)
     {
         hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+        todo_wine
         ok(hr == MF_E_INVALIDMEDIATYPE, "SetOutputType returned %#lx.\n", hr);
         init_media_type(media_type, output_type_desc, i + 1);
     }
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == S_OK, "SetOutputType returned %#lx.\n", hr);
     ret = IMFMediaType_Release(media_type);
     ok(ret == 0, "Release returned %lu\n", ret);
 
     memset(&input_info, 0xcd, sizeof(input_info));
     hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    todo_wine
     ok(hr == S_OK, "GetInputStreamInfo returned %#lx\n", hr);
+    todo_wine
     ok(input_info.hnsMaxLatency == 0, "got hnsMaxLatency %s\n", wine_dbgstr_longlong(input_info.hnsMaxLatency));
+    todo_wine
     ok(input_info.dwFlags == 0, "got dwFlags %#lx\n", input_info.dwFlags);
+    todo_wine
     ok(input_info.cbSize == 8, "got cbSize %lu\n", input_info.cbSize);
+    todo_wine
     ok(input_info.cbMaxLookahead == 0, "got cbMaxLookahead %#lx\n", input_info.cbMaxLookahead);
+    todo_wine
     ok(input_info.cbAlignment == 1, "got cbAlignment %#lx\n", input_info.cbAlignment);
 
     memset(&output_info, 0xcd, sizeof(output_info));
     hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    todo_wine
     ok(hr == S_OK, "GetOutputStreamInfo returned %#lx\n", hr);
+    todo_wine
     ok(output_info.dwFlags == 0, "got dwFlags %#lx\n", output_info.dwFlags);
+    todo_wine
     ok(output_info.cbSize == 4, "got cbSize %#lx\n", output_info.cbSize);
+    todo_wine
     ok(output_info.cbAlignment == 1, "got cbAlignment %#lx\n", output_info.cbAlignment);
 
     resource = FindResourceW(NULL, L"audiodata.bin", (const WCHAR *)RT_RCDATA);
@@ -7705,10 +7731,13 @@ static void test_audio_convert(void)
     hr = IMFSample_SetSampleDuration(sample, 10000000);
     ok(hr == S_OK, "SetSampleDuration returned %#lx\n", hr);
     hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
+    todo_wine
     ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
     hr = IMFTransform_ProcessMessage(transform, MFT_MESSAGE_COMMAND_DRAIN, 0);
+    todo_wine
     ok(hr == S_OK, "ProcessMessage returned %#lx\n", hr);
     hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
+    todo_wine
     ok(hr == MF_E_NOTACCEPTING, "ProcessInput returned %#lx\n", hr);
     IMFSample_Release(sample);
 
@@ -7764,9 +7793,12 @@ static void test_audio_convert(void)
     }
 
     hr = IMFSample_GetSampleTime(sample, &time);
+    todo_wine
     ok(hr == S_OK, "GetSampleTime returned %#lx\n", hr);
+    todo_wine_if(i != 0)
     ok(time == i * 928798, "got time %I64d\n", time);
     hr = IMFSample_GetSampleDuration(sample, &duration);
+    todo_wine
     ok(hr == S_OK, "GetSampleDuration returned %#lx\n", hr);
     todo_wine
     ok(duration == 897506, "got duration %I64d\n", duration);
@@ -7774,6 +7806,7 @@ static void test_audio_convert(void)
     ok(hr == S_OK, "GetTotalLength returned %#lx\n", hr);
     todo_wine
     ok(length == 15832, "got length %lu\n", length);
+    todo_wine
     ok(audioconv_data_len == 16084, "got remaining length %lu\n", audioconv_data_len);
     check_sample_pcm16(sample, audioconv_data, output_file, FALSE);
     audioconv_data_len -= length;
@@ -7788,6 +7821,7 @@ static void test_audio_convert(void)
     todo_wine
     ok(output.dwStatus == MFT_OUTPUT_DATA_BUFFER_INCOMPLETE || broken(output.dwStatus == 0) /* win7 */,
             "got dwStatus %#lx\n", output.dwStatus);
+    todo_wine
     ok(status == 0, "got status %#lx\n", status);
 
     if (hr == S_OK)
@@ -7819,9 +7853,11 @@ static void test_audio_convert(void)
     memset(&output, 0, sizeof(output));
     output.pSample = sample;
     hr = IMFTransform_ProcessOutput(transform, 0, 1, &output, &status);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_NEED_MORE_INPUT, "ProcessOutput returned %#lx\n", hr);
     ok(output.pSample == sample, "got pSample %p\n", output.pSample);
     ok(output.dwStatus == 0, "got dwStatus %#lx\n", output.dwStatus);
+    todo_wine
     ok(status == 0, "got status %#lx\n", status);
     hr = IMFSample_GetTotalLength(sample, &length);
     ok(hr == S_OK, "GetTotalLength returned %#lx\n", hr);
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index 6e3517dcb36..f365608ed6a 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -14,6 +14,7 @@ C_SRCS = \
 	mfplat.c \
 	quartz_parser.c \
 	quartz_transform.c \
+	resampler.c \
 	wg_allocator.c \
 	wg_format.c \
 	wg_parser.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index e1abe7018da..c539084fa89 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -111,6 +111,7 @@ HRESULT mpeg_audio_codec_create(IUnknown *outer, IUnknown **out);
 HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out);
 HRESULT wave_parser_create(IUnknown *outer, IUnknown **out);
 HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out);
+HRESULT resampler_create(IUnknown *outer, IUnknown **out);
 
 bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm);
 bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index 5075b3118cd..fedf4e48538 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -437,6 +437,7 @@ static struct class_factory mpeg_audio_codec_cf = {{&class_factory_vtbl}, mpeg_a
 static struct class_factory mpeg_splitter_cf = {{&class_factory_vtbl}, mpeg_splitter_create};
 static struct class_factory wave_parser_cf = {{&class_factory_vtbl}, wave_parser_create};
 static struct class_factory wma_decoder_cf = {{&class_factory_vtbl}, wma_decoder_create};
+static struct class_factory resampler_cf = {{&class_factory_vtbl}, resampler_create};
 
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 {
@@ -463,6 +464,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
         factory = &wave_parser_cf;
     else if (IsEqualGUID(clsid, &CLSID_WMADecMediaObject))
         factory = &wma_decoder_cf;
+    else if (IsEqualGUID(clsid, &CLSID_CResamplerMediaObject))
+        factory = &resampler_cf;
     else
     {
         FIXME("%s not implemented, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
@@ -657,6 +660,11 @@ static const REGFILTER2 reg_decodebin_parser =
 
 HRESULT WINAPI DllRegisterServer(void)
 {
+    DMO_PARTIAL_MEDIATYPE audio_convert_types[2] =
+    {
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_PCM},
+        {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_IEEE_FLOAT},
+    };
     DMO_PARTIAL_MEDIATYPE wma_decoder_output[2] =
     {
         {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_PCM},
@@ -696,6 +704,9 @@ HRESULT WINAPI DllRegisterServer(void)
     if (FAILED(hr = DMORegister(L"WMA Decoder DMO", &CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER,
             0, ARRAY_SIZE(wma_decoder_input), wma_decoder_input, ARRAY_SIZE(wma_decoder_output), wma_decoder_output)))
         return hr;
+    if (FAILED(hr = DMORegister(L"Resampler DMO", &CLSID_CResamplerMediaObject, &DMOCATEGORY_AUDIO_EFFECT,
+            0, ARRAY_SIZE(audio_convert_types), audio_convert_types, ARRAY_SIZE(audio_convert_types), audio_convert_types)))
+        return hr;
 
     return mfplat_DllRegisterServer();
 }
@@ -722,6 +733,8 @@ HRESULT WINAPI DllUnregisterServer(void)
 
     IFilterMapper2_Release(mapper);
 
+    if (FAILED(hr = DMOUnregister(&CLSID_CResamplerMediaObject, &DMOCATEGORY_AUDIO_EFFECT)))
+        return hr;
     if (FAILED(hr = DMOUnregister(&CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER)))
         return hr;
 
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index c5ca4b15c0f..ee0a5d25056 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -440,7 +440,7 @@ HRESULT mfplat_get_class_object(REFCLSID rclsid, REFIID riid, void **obj)
 
 HRESULT mfplat_DllRegisterServer(void)
 {
-    MFT_REGISTER_TYPE_INFO audio_converter_supported_types[] =
+    MFT_REGISTER_TYPE_INFO resampler_types[] =
     {
         {MFMediaType_Audio, MFAudioFormat_PCM},
         {MFMediaType_Audio, MFAudioFormat_Float},
@@ -541,10 +541,10 @@ HRESULT mfplat_DllRegisterServer(void)
             MFT_CATEGORY_AUDIO_EFFECT,
             L"Audio Converter",
             MFT_ENUM_FLAG_SYNCMFT,
-            ARRAY_SIZE(audio_converter_supported_types),
-            audio_converter_supported_types,
-            ARRAY_SIZE(audio_converter_supported_types),
-            audio_converter_supported_types,
+            ARRAY_SIZE(resampler_types),
+            resampler_types,
+            ARRAY_SIZE(resampler_types),
+            resampler_types,
         },
         {
             CLSID_WMADecMediaObject,
@@ -576,6 +576,16 @@ HRESULT mfplat_DllRegisterServer(void)
             ARRAY_SIZE(video_processor_output_types),
             video_processor_output_types,
         },
+        {
+            CLSID_CResamplerMediaObject,
+            MFT_CATEGORY_AUDIO_EFFECT,
+            L"Resampler MFT",
+            MFT_ENUM_FLAG_SYNCMFT,
+            ARRAY_SIZE(resampler_types),
+            resampler_types,
+            ARRAY_SIZE(resampler_types),
+            resampler_types,
+        },
     };
 
     unsigned int i;
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index 037f0573b34..77a9f801fa3 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -86,3 +86,9 @@ coclass CWMADecMediaObject {};
     uuid(62ce7e72-4c71-4d20-b15d-452831a87d9d)
 ]
 coclass CMSH264DecoderMFT {}
+
+[
+    threading(both),
+    uuid(f447b69e-1884-4a7e-8055-346f74d6edb3)
+]
+coclass CResamplerMediaObject {}
-- 
2.20.1

