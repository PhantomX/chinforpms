From 5b178b2fa94b2fe3d0140d0c841695903cb39bd0 Mon Sep 17 00:00:00 2001
From: =?utf8?q?R=C3=A9mi=20Bernon?= <rbernon@codeweavers.com>
Date: Thu, 5 May 2022 23:54:58 +0200
Subject: [PATCH] winegstreamer: Register stub ColorConvertDMO transform.
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

Signed-off-by: RÃ©mi Bernon <rbernon@codeweavers.com>
---
 dlls/mf/tests/mf.c                           |  42 +-
 dlls/winegstreamer/Makefile.in               |   1 +
 dlls/winegstreamer/gst_private.h             |   1 +
 dlls/winegstreamer/main.c                    |  50 ++
 dlls/winegstreamer/mfplat.c                  |  60 ++
 dlls/winegstreamer/winegstreamer_classes.idl |   6 +
 7 files changed, 765 insertions(+), 1 deletion(-)

diff --git a/dlls/mf/tests/mf.c b/dlls/mf/tests/mf.c
index 11261342d35..329b770b344 100644
--- a/dlls/mf/tests/mf.c
+++ b/dlls/mf/tests/mf.c
@@ -8020,14 +8020,17 @@ static void test_color_convert(void)
     check_interface(transform, &IID_IMFTransform, TRUE);
     check_interface(transform, &IID_IMediaObject, TRUE);
     check_interface(transform, &IID_IPropertyStore, TRUE);
+    todo_wine
     check_interface(transform, &IID_IMFRealTimeClient, TRUE);
     /* check_interface(transform, &IID_IWMColorConvProps, TRUE); */
 
     /* check default media types */
 
     hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetInputStreamInfo returned %#lx\n", hr);
     hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_TYPE_NOT_SET, "GetOutputStreamInfo returned %#lx\n", hr);
 
     i = -1;
@@ -8041,7 +8044,9 @@ static void test_color_convert(void)
         ok(ret == 0, "Release returned %lu\n", ret);
         winetest_pop_context();
     }
+    todo_wine
     ok(hr == MF_E_NO_MORE_TYPES, "GetOutputAvailableType returned %#lx\n", hr);
+    todo_wine
     ok(i == 16, "%lu output media types\n", i);
 
     i = -1;
@@ -8063,7 +8068,9 @@ static void test_color_convert(void)
         ok(ret == 0, "Release returned %lu\n", ret);
         winetest_pop_context();
     }
+    todo_wine
     ok(hr == MF_E_NO_MORE_TYPES, "GetInputAvailableType returned %#lx\n", hr);
+    todo_wine
     ok(i == 20, "%lu input media types\n", i);
 
     /* check required output media type attributes */
@@ -8071,18 +8078,22 @@ static void test_color_convert(void)
     hr = MFCreateMediaType(&media_type);
     ok(hr == S_OK, "MFCreateMediaType returned %#lx\n", hr);
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetOutputType returned %#lx.\n", hr);
     init_media_type(media_type, output_type_desc, 1);
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetOutputType returned %#lx.\n", hr);
     init_media_type(media_type, output_type_desc, 2);
     for (i = 2; i < ARRAY_SIZE(output_type_desc) - 1; ++i)
     {
         hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+        todo_wine
         ok(hr == E_INVALIDARG, "SetOutputType returned %#lx.\n", hr);
         init_media_type(media_type, output_type_desc, i + 1);
     }
     hr = IMFTransform_SetOutputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == S_OK, "SetOutputType returned %#lx.\n", hr);
     ret = IMFMediaType_Release(media_type);
     ok(ret == 0, "Release returned %lu\n", ret);
@@ -8092,36 +8103,50 @@ static void test_color_convert(void)
     hr = MFCreateMediaType(&media_type);
     ok(hr == S_OK, "MFCreateMediaType returned %#lx\n", hr);
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetInputType returned %#lx.\n", hr);
     init_media_type(media_type, input_type_desc, 1);
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == MF_E_ATTRIBUTENOTFOUND, "SetInputType returned %#lx.\n", hr);
     init_media_type(media_type, input_type_desc, 2);
     for (i = 2; i < ARRAY_SIZE(input_type_desc) - 1; ++i)
     {
         hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+        todo_wine
         ok(hr == E_INVALIDARG, "SetInputType returned %#lx.\n", hr);
         init_media_type(media_type, input_type_desc, i + 1);
     }
     hr = IMFTransform_SetInputType(transform, 0, media_type, 0);
+    todo_wine
     ok(hr == S_OK, "SetInputType returned %#lx.\n", hr);
     ret = IMFMediaType_Release(media_type);
     ok(ret == 0, "Release returned %lu\n", ret);
 
     memset(&input_info, 0xcd, sizeof(input_info));
     hr = IMFTransform_GetInputStreamInfo(transform, 0, &input_info);
+    todo_wine
     ok(hr == S_OK, "GetInputStreamInfo returned %#lx\n", hr);
+    todo_wine
     ok(input_info.hnsMaxLatency == 0, "got hnsMaxLatency %s\n", wine_dbgstr_longlong(input_info.hnsMaxLatency));
+    todo_wine
     ok(input_info.dwFlags == 0, "got dwFlags %#lx\n", input_info.dwFlags);
+    todo_wine
     ok(input_info.cbSize == actual_width * actual_height * 3 / 2, "got cbSize %#lx\n", input_info.cbSize);
+    todo_wine
     ok(input_info.cbMaxLookahead == 0, "got cbMaxLookahead %#lx\n", input_info.cbMaxLookahead);
+    todo_wine
     ok(input_info.cbAlignment == 1, "got cbAlignment %#lx\n", input_info.cbAlignment);
 
     memset(&output_info, 0xcd, sizeof(output_info));
     hr = IMFTransform_GetOutputStreamInfo(transform, 0, &output_info);
+    todo_wine
     ok(hr == S_OK, "GetOutputStreamInfo returned %#lx\n", hr);
+    todo_wine
     ok(output_info.dwFlags == 0, "got dwFlags %#lx\n", output_info.dwFlags);
+    todo_wine
     ok(output_info.cbSize == actual_width * actual_height * 4, "got cbSize %#lx\n", output_info.cbSize);
+    todo_wine
     ok(output_info.cbAlignment == 1, "got cbAlignment %#lx\n", output_info.cbAlignment);
 
     resource = FindResourceW(NULL, L"nv12frame.bin", (const WCHAR *)RT_RCDATA);
@@ -8136,10 +8161,13 @@ static void test_color_convert(void)
     hr = IMFSample_SetSampleDuration(sample, 10000000);
     ok(hr == S_OK, "SetSampleDuration returned %#lx\n", hr);
     hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
+    todo_wine
     ok(hr == S_OK, "ProcessInput returned %#lx\n", hr);
     hr = IMFTransform_ProcessInput(transform, 0, sample, 0);
+    todo_wine
     ok(hr == MF_E_NOTACCEPTING, "ProcessInput returned %#lx\n", hr);
     hr = IMFTransform_ProcessMessage(transform, MFT_MESSAGE_COMMAND_DRAIN, 0);
+    todo_wine
     ok(hr == S_OK, "ProcessMessage returned %#lx\n", hr);
     IMFSample_Release(sample);
 
@@ -8147,7 +8175,9 @@ static void test_color_convert(void)
     ok(resource != 0, "FindResourceW failed, error %lu\n", GetLastError());
     rgb32_data = LockResource(LoadResource(GetModuleHandleW(NULL), resource));
     rgb32_data_len = SizeofResource(GetModuleHandleW(NULL), resource);
+    todo_wine
     ok(rgb32_data_len == output_info.cbSize, "got length %lu\n", rgb32_data_len);
+    if (rgb32_data_len != output_info.cbSize) output_info.cbSize = actual_width * actual_height * 4;
 
     /* and generate a new one as well in a temporary directory */
     GetTempPathW(ARRAY_SIZE(output_path), output_path);
@@ -8160,21 +8190,29 @@ static void test_color_convert(void)
     memset(&output, 0, sizeof(output));
     output.pSample = sample;
     hr = IMFTransform_ProcessOutput(transform, 0, 1, &output, &status);
+    todo_wine
     ok(hr == S_OK, "ProcessOutput returned %#lx\n", hr);
     ok(output.pSample == sample, "got pSample %p\n", output.pSample);
     ok(output.dwStatus == 0 || broken(output.dwStatus == 6) /* win7 */, "got dwStatus %#lx\n", output.dwStatus);
+    todo_wine
     ok(status == 0, "got status %#lx\n", status);
 
     hr = IMFSample_GetSampleTime(sample, &time);
+    todo_wine
     ok(hr == S_OK, "GetSampleTime returned %#lx\n", hr);
+    todo_wine
     ok(time == 0, "got time %I64d\n", time);
     hr = IMFSample_GetSampleDuration(sample, &duration);
+    todo_wine
     ok(hr == S_OK, "GetSampleDuration returned %#lx\n", hr);
+    todo_wine
     ok(duration == 10000000, "got duration %I64d\n", duration);
     hr = IMFSample_GetTotalLength(sample, &length);
     ok(hr == S_OK, "GetTotalLength returned %#lx\n", hr);
+    todo_wine
     ok(length == output_info.cbSize, "got length %lu\n", length);
-    check_sample_rgb32(sample, rgb32_data, output_file);
+    if (length == output_info.cbSize)
+        check_sample_rgb32(sample, rgb32_data, output_file);
     rgb32_data_len -= output_info.cbSize;
     rgb32_data += output_info.cbSize;
 
@@ -8189,9 +8227,11 @@ static void test_color_convert(void)
     memset(&output, 0, sizeof(output));
     output.pSample = sample;
     hr = IMFTransform_ProcessOutput(transform, 0, 1, &output, &status);
+    todo_wine
     ok(hr == MF_E_TRANSFORM_NEED_MORE_INPUT, "ProcessOutput returned %#lx\n", hr);
     ok(output.pSample == sample, "got pSample %p\n", output.pSample);
     ok(output.dwStatus == 0, "got dwStatus %#lx\n", output.dwStatus);
+    todo_wine
     ok(status == 0, "got status %#lx\n", status);
     hr = IMFSample_GetTotalLength(sample, &length);
     ok(hr == S_OK, "GetTotalLength returned %#lx\n", hr);
diff --git a/dlls/winegstreamer/Makefile.in b/dlls/winegstreamer/Makefile.in
index e7bffa92df0..462b54f2557 100644
--- a/dlls/winegstreamer/Makefile.in
+++ b/dlls/winegstreamer/Makefile.in
@@ -7,6 +7,7 @@ EXTRAINCL = $(GSTREAMER_CFLAGS)
 EXTRALIBS = $(GSTREAMER_LIBS) $(PTHREAD_LIBS)
 
 C_SRCS = \
+	color_convert.c \
 	h264_decoder.c \
 	main.c \
 	media_source.c \
diff --git a/dlls/winegstreamer/gst_private.h b/dlls/winegstreamer/gst_private.h
index 065849e9a8c..8348d2e8360 100644
--- a/dlls/winegstreamer/gst_private.h
+++ b/dlls/winegstreamer/gst_private.h
@@ -112,6 +112,7 @@ HRESULT mpeg_splitter_create(IUnknown *outer, IUnknown **out);
 HRESULT wave_parser_create(IUnknown *outer, IUnknown **out);
 HRESULT wma_decoder_create(IUnknown *outer, IUnknown **out);
 HRESULT resampler_create(IUnknown *outer, IUnknown **out);
+HRESULT color_convert_create(IUnknown *outer, IUnknown **out);
 
 bool amt_from_wg_format(AM_MEDIA_TYPE *mt, const struct wg_format *format, bool wm);
 bool amt_to_wg_format(const AM_MEDIA_TYPE *mt, struct wg_format *format);
diff --git a/dlls/winegstreamer/main.c b/dlls/winegstreamer/main.c
index fedf4e48538..fc7b9d73285 100644
--- a/dlls/winegstreamer/main.c
+++ b/dlls/winegstreamer/main.c
@@ -438,6 +438,7 @@ static struct class_factory mpeg_splitter_cf = {{&class_factory_vtbl}, mpeg_spli
 static struct class_factory wave_parser_cf = {{&class_factory_vtbl}, wave_parser_create};
 static struct class_factory wma_decoder_cf = {{&class_factory_vtbl}, wma_decoder_create};
 static struct class_factory resampler_cf = {{&class_factory_vtbl}, resampler_create};
+static struct class_factory color_convert_cf = {{&class_factory_vtbl}, color_convert_create};
 
 HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
 {
@@ -466,6 +467,8 @@ HRESULT WINAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void **out)
         factory = &wma_decoder_cf;
     else if (IsEqualGUID(clsid, &CLSID_CResamplerMediaObject))
         factory = &resampler_cf;
+    else if (IsEqualGUID(clsid, &CLSID_CColorConvertDMO))
+        factory = &color_convert_cf;
     else
     {
         FIXME("%s not implemented, returning CLASS_E_CLASSNOTAVAILABLE.\n", debugstr_guid(clsid));
@@ -677,6 +680,48 @@ HRESULT WINAPI DllRegisterServer(void)
         {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO3},
         {.type = MEDIATYPE_Audio, .subtype = MEDIASUBTYPE_WMAUDIO_LOSSLESS},
     };
+    DMO_PARTIAL_MEDIATYPE color_convert_input[20] =
+    {
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YV12},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YUY2},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_UYVY},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_AYUV},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_NV12},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB32},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB565},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_I420},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_IYUV},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YVYU},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB24},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB555},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB8},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_V216},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_V410},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_NV11},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_Y41P},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_Y41T},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_Y42T},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YVU9},
+    };
+    DMO_PARTIAL_MEDIATYPE color_convert_output[16] =
+    {
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YV12},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YUY2},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_UYVY},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_AYUV},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_NV12},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB32},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB565},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_I420},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_IYUV},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_YVYU},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB24},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB555},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_RGB8},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_V216},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_V410},
+        {.type = MEDIATYPE_Video, .subtype = MEDIASUBTYPE_NV11},
+    };
 
     IFilterMapper2 *mapper;
     HRESULT hr;
@@ -707,6 +752,9 @@ HRESULT WINAPI DllRegisterServer(void)
     if (FAILED(hr = DMORegister(L"Resampler DMO", &CLSID_CResamplerMediaObject, &DMOCATEGORY_AUDIO_EFFECT,
             0, ARRAY_SIZE(audio_convert_types), audio_convert_types, ARRAY_SIZE(audio_convert_types), audio_convert_types)))
         return hr;
+    if (FAILED(hr = DMORegister(L"Color Converter DMO", &CLSID_CColorConvertDMO, &DMOCATEGORY_VIDEO_EFFECT,
+            0, ARRAY_SIZE(color_convert_input), color_convert_input, ARRAY_SIZE(color_convert_output), color_convert_output)))
+        return hr;
 
     return mfplat_DllRegisterServer();
 }
@@ -733,6 +781,8 @@ HRESULT WINAPI DllUnregisterServer(void)
 
     IFilterMapper2_Release(mapper);
 
+    if (FAILED(hr = DMOUnregister(&CLSID_CColorConvertDMO, &DMOCATEGORY_VIDEO_EFFECT)))
+        return hr;
     if (FAILED(hr = DMOUnregister(&CLSID_CResamplerMediaObject, &DMOCATEGORY_AUDIO_EFFECT)))
         return hr;
     if (FAILED(hr = DMOUnregister(&CLSID_WMADecMediaObject, &DMOCATEGORY_AUDIO_DECODER)))
diff --git a/dlls/winegstreamer/mfplat.c b/dlls/winegstreamer/mfplat.c
index 779387009c2..33557211243 100644
--- a/dlls/winegstreamer/mfplat.c
+++ b/dlls/winegstreamer/mfplat.c
@@ -23,6 +23,7 @@
 #include "ksmedia.h"
 #include "wmcodecdsp.h"
 #include "initguid.h"
+#include "d3d9types.h"
 #include "mfapi.h"
 
 #include "wine/debug.h"
@@ -30,6 +31,12 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(mfplat);
 
+DEFINE_GUID(DMOVideoFormat_RGB32,D3DFMT_X8R8G8B8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+DEFINE_GUID(DMOVideoFormat_RGB24,D3DFMT_R8G8B8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+DEFINE_GUID(DMOVideoFormat_RGB565,D3DFMT_R5G6B5,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+DEFINE_GUID(DMOVideoFormat_RGB555,D3DFMT_X1R5G5B5,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+DEFINE_GUID(DMOVideoFormat_RGB8,D3DFMT_P8,0x524f,0x11ce,0x9f,0x53,0x00,0x20,0xaf,0x0b,0xa7,0x70);
+
 struct video_processor
 {
     IMFTransform IMFTransform_iface;
@@ -520,6 +527,49 @@ HRESULT mfplat_DllRegisterServer(void)
         {MFMediaType_Video, MFVideoFormat_YVYU},
     };
 
+    MFT_REGISTER_TYPE_INFO color_convert_input_types[] =
+    {
+        {MFMediaType_Video, MFVideoFormat_YV12},
+        {MFMediaType_Video, MFVideoFormat_YUY2},
+        {MFMediaType_Video, MFVideoFormat_UYVY},
+        {MFMediaType_Video, MFVideoFormat_AYUV},
+        {MFMediaType_Video, MFVideoFormat_NV12},
+        {MFMediaType_Video, DMOVideoFormat_RGB32},
+        {MFMediaType_Video, DMOVideoFormat_RGB565},
+        {MFMediaType_Video, MFVideoFormat_I420},
+        {MFMediaType_Video, MFVideoFormat_IYUV},
+        {MFMediaType_Video, MFVideoFormat_YVYU},
+        {MFMediaType_Video, DMOVideoFormat_RGB24},
+        {MFMediaType_Video, DMOVideoFormat_RGB555},
+        {MFMediaType_Video, DMOVideoFormat_RGB8},
+        {MFMediaType_Video, MEDIASUBTYPE_V216},
+        {MFMediaType_Video, MEDIASUBTYPE_V410},
+        {MFMediaType_Video, MFVideoFormat_NV11},
+        {MFMediaType_Video, MFVideoFormat_Y41P},
+        {MFMediaType_Video, MFVideoFormat_Y41T},
+        {MFMediaType_Video, MFVideoFormat_Y42T},
+        {MFMediaType_Video, MFVideoFormat_YVU9},
+    };
+    MFT_REGISTER_TYPE_INFO color_convert_output_types[] =
+    {
+        {MFMediaType_Video, MFVideoFormat_YV12},
+        {MFMediaType_Video, MFVideoFormat_YUY2},
+        {MFMediaType_Video, MFVideoFormat_UYVY},
+        {MFMediaType_Video, MFVideoFormat_AYUV},
+        {MFMediaType_Video, MFVideoFormat_NV12},
+        {MFMediaType_Video, DMOVideoFormat_RGB32},
+        {MFMediaType_Video, DMOVideoFormat_RGB565},
+        {MFMediaType_Video, MFVideoFormat_I420},
+        {MFMediaType_Video, MFVideoFormat_IYUV},
+        {MFMediaType_Video, MFVideoFormat_YVYU},
+        {MFMediaType_Video, DMOVideoFormat_RGB24},
+        {MFMediaType_Video, DMOVideoFormat_RGB555},
+        {MFMediaType_Video, DMOVideoFormat_RGB8},
+        {MFMediaType_Video, MEDIASUBTYPE_V216},
+        {MFMediaType_Video, MEDIASUBTYPE_V410},
+        {MFMediaType_Video, MFVideoFormat_NV11},
+    };
+
     struct mft
     {
         GUID clsid;
@@ -573,6 +623,16 @@ HRESULT mfplat_DllRegisterServer(void)
             ARRAY_SIZE(resampler_types),
             resampler_types,
         },
+        {
+            CLSID_CColorConvertDMO,
+            MFT_CATEGORY_VIDEO_EFFECT,
+            L"Color Converter MFT",
+            MFT_ENUM_FLAG_SYNCMFT,
+            ARRAY_SIZE(color_convert_input_types),
+            color_convert_input_types,
+            ARRAY_SIZE(color_convert_output_types),
+            color_convert_output_types,
+        },
     };
 
     unsigned int i;
diff --git a/dlls/winegstreamer/winegstreamer_classes.idl b/dlls/winegstreamer/winegstreamer_classes.idl
index bed1fc5281a..c95f4135835 100644
--- a/dlls/winegstreamer/winegstreamer_classes.idl
+++ b/dlls/winegstreamer/winegstreamer_classes.idl
@@ -86,3 +86,9 @@ coclass CMSH264DecoderMFT {}
     uuid(f447b69e-1884-4a7e-8055-346f74d6edb3)
 ]
 coclass CResamplerMediaObject {}
+
+[
+    threading(both),
+    uuid(98230571-0087-4204-b020-3282538e57d3)
+]
+coclass CColorConvertDMO {}
-- 
2.20.1

